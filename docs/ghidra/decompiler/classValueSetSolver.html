<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: ValueSetSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classValueSetSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ValueSetSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that determines a <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> for each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in a data-flow system.  
 <a href="classValueSetSolver.html#details">More...</a></p>

<p><code>#include &lt;rangeutil.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver_1_1ValueSetEdge.html">ValueSetEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over out-bound edges for a single <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> node in a data-flow system.  <a href="classValueSetSolver_1_1ValueSetEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43a4cb32e3aef1c1cb92cd5b8d6dd300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">establishValueSets</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;sinks, const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;reads, <a class="el" href="classVarnode.html">Varnode</a> *stackReg, bool indirectAsCopy)</td></tr>
<tr class="memdesc:a43a4cb32e3aef1c1cb92cd5b8d6dd300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build value sets for a data-flow system.  <a href="#a43a4cb32e3aef1c1cb92cd5b8d6dd300">More...</a><br /></td></tr>
<tr class="separator:a43a4cb32e3aef1c1cb92cd5b8d6dd300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa15bc46d2e28d094b6d4e9a2702a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfa15bc46d2e28d094b6d4e9a2702a52"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#adfa15bc46d2e28d094b6d4e9a2702a52">getNumIterations</a> (void) const </td></tr>
<tr class="memdesc:adfa15bc46d2e28d094b6d4e9a2702a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of iterations. <br /></td></tr>
<tr class="separator:adfa15bc46d2e28d094b6d4e9a2702a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dec4550f9502575b92ca93bf997185c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c">solve</a> (int4 max, <a class="el" href="classWidener.html">Widener</a> &amp;widener)</td></tr>
<tr class="memdesc:a8dec4550f9502575b92ca93bf997185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> system until it stabilizes.  <a href="#a8dec4550f9502575b92ca93bf997185c">More...</a><br /></td></tr>
<tr class="separator:a8dec4550f9502575b92ca93bf997185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c540268322451f560cfe664171a9b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c540268322451f560cfe664171a9b2"></a>
list&lt; <a class="el" href="classValueSet.html">ValueSet</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a13c540268322451f560cfe664171a9b2">beginValueSets</a> (void) const </td></tr>
<tr class="memdesc:a13c540268322451f560cfe664171a9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all ValueSets in the system. <br /></td></tr>
<tr class="separator:a13c540268322451f560cfe664171a9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3134ed33e025974a1893e55cb5f2834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3134ed33e025974a1893e55cb5f2834"></a>
list&lt; <a class="el" href="classValueSet.html">ValueSet</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#ad3134ed33e025974a1893e55cb5f2834">endValueSets</a> (void) const </td></tr>
<tr class="memdesc:ad3134ed33e025974a1893e55cb5f2834"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all ValueSets in the system. <br /></td></tr>
<tr class="separator:ad3134ed33e025974a1893e55cb5f2834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add872e1712b1f058a9ece3e9541e9952"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add872e1712b1f058a9ece3e9541e9952"></a>
map&lt; <a class="el" href="classSeqNum.html">SeqNum</a>, <a class="el" href="classValueSetRead.html">ValueSetRead</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#add872e1712b1f058a9ece3e9541e9952">beginValueSetReads</a> (void) const </td></tr>
<tr class="memdesc:add872e1712b1f058a9ece3e9541e9952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of ValueSetReads. <br /></td></tr>
<tr class="separator:add872e1712b1f058a9ece3e9541e9952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab54d2c626ca4c1175c4e1e8641578"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cab54d2c626ca4c1175c4e1e8641578"></a>
map&lt; <a class="el" href="classSeqNum.html">SeqNum</a>, <a class="el" href="classValueSetRead.html">ValueSetRead</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a7cab54d2c626ca4c1175c4e1e8641578">endValueSetReads</a> (void) const </td></tr>
<tr class="memdesc:a7cab54d2c626ca4c1175c4e1e8641578"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of ValueSetReads. <br /></td></tr>
<tr class="separator:a7cab54d2c626ca4c1175c4e1e8641578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52959c6069ee9e6cde934dd207d1e2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab52959c6069ee9e6cde934dd207d1e2f"></a>
const <a class="el" href="classValueSetRead.html">ValueSetRead</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#ab52959c6069ee9e6cde934dd207d1e2f">getValueSetRead</a> (const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;seq)</td></tr>
<tr class="memdesc:ab52959c6069ee9e6cde934dd207d1e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classValueSetRead.html" title="A special form of ValueSet associated with the read point of a Varnode. ">ValueSetRead</a> by <a class="el" href="classSeqNum.html" title="A class for uniquely labelling and comparing PcodeOps. ">SeqNum</a>. <br /></td></tr>
<tr class="separator:ab52959c6069ee9e6cde934dd207d1e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaa7e03150bb730888b0a41b470a845cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#aaa7e03150bb730888b0a41b470a845cb">newValueSet</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 tCode)</td></tr>
<tr class="memdesc:aaa7e03150bb730888b0a41b470a845cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for a new <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a>.  <a href="#aaa7e03150bb730888b0a41b470a845cb">More...</a><br /></td></tr>
<tr class="separator:aaa7e03150bb730888b0a41b470a845cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45d0eae011647af953863a4d9145f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#af45d0eae011647af953863a4d9145f47">partitionSurround</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:af45d0eae011647af953863a4d9145f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a full partition component.  <a href="#af45d0eae011647af953863a4d9145f47">More...</a><br /></td></tr>
<tr class="separator:af45d0eae011647af953863a4d9145f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a09332b5c711af6adc8b9603b5b9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a97a09332b5c711af6adc8b9603b5b9bc">component</a> (<a class="el" href="classValueSet.html">ValueSet</a> *vertex, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:a97a09332b5c711af6adc8b9603b5b9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a partition component given its head.  <a href="#a97a09332b5c711af6adc8b9603b5b9bc">More...</a><br /></td></tr>
<tr class="separator:a97a09332b5c711af6adc8b9603b5b9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d625b2cec5d8712551e63737f42b8"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#add4d625b2cec5d8712551e63737f42b8">visit</a> (<a class="el" href="classValueSet.html">ValueSet</a> *vertex, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:add4d625b2cec5d8712551e63737f42b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the data-flow graph finding partitions.  <a href="#add4d625b2cec5d8712551e63737f42b8">More...</a><br /></td></tr>
<tr class="separator:add4d625b2cec5d8712551e63737f42b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a3f29f53647357d726347855bc3df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a81a3f29f53647357d726347855bc3df7">establishTopologicalOrder</a> (void)</td></tr>
<tr class="memdesc:a81a3f29f53647357d726347855bc3df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the optimal order for iterating through the ValueSets.  <a href="#a81a3f29f53647357d726347855bc3df7">More...</a><br /></td></tr>
<tr class="separator:a81a3f29f53647357d726347855bc3df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d92ea3879a4ca9dc26d6b1c7d28ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a129d92ea3879a4ca9dc26d6b1c7d28ea">generateTrueEquation</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot, int4 type, const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;range)</td></tr>
<tr class="memdesc:a129d92ea3879a4ca9dc26d6b1c7d28ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an equation given a <b>true</b> constraint and the input/output Varnodes it affects.  <a href="#a129d92ea3879a4ca9dc26d6b1c7d28ea">More...</a><br /></td></tr>
<tr class="separator:a129d92ea3879a4ca9dc26d6b1c7d28ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e500970c198d5d59cf05dbb9b359ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a6e500970c198d5d59cf05dbb9b359ee0">generateFalseEquation</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot, int4 type, const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;range)</td></tr>
<tr class="memdesc:a6e500970c198d5d59cf05dbb9b359ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the complementary equation given a <b>true</b> constraint and the input/output Varnodes it affects.  <a href="#a6e500970c198d5d59cf05dbb9b359ee0">More...</a><br /></td></tr>
<tr class="separator:a6e500970c198d5d59cf05dbb9b359ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629f30eb1a0d4f35bc9bc3a855813be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a629f30eb1a0d4f35bc9bc3a855813be5">applyConstraints</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 type, const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;range, <a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a629f30eb1a0d4f35bc9bc3a855813be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for PcodeOps where the given constraint range applies and instantiate an equation.  <a href="#a629f30eb1a0d4f35bc9bc3a855813be5">More...</a><br /></td></tr>
<tr class="separator:a629f30eb1a0d4f35bc9bc3a855813be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874fc29428abfe7c8b503f8daae65558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a874fc29428abfe7c8b503f8daae65558">constraintsFromPath</a> (int4 type, <a class="el" href="classCircleRange.html">CircleRange</a> &amp;lift, <a class="el" href="classVarnode.html">Varnode</a> *startVn, <a class="el" href="classVarnode.html">Varnode</a> *endVn, <a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a874fc29428abfe7c8b503f8daae65558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate constraints given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> path.  <a href="#a874fc29428abfe7c8b503f8daae65558">More...</a><br /></td></tr>
<tr class="separator:a874fc29428abfe7c8b503f8daae65558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e256b19fd0b267fe7d356c2bbff0f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a69e256b19fd0b267fe7d356c2bbff0f4">constraintsFromCBranch</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a69e256b19fd0b267fe7d356c2bbff0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate constraints arising from the given branch.  <a href="#a69e256b19fd0b267fe7d356c2bbff0f4">More...</a><br /></td></tr>
<tr class="separator:a69e256b19fd0b267fe7d356c2bbff0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371470235d727b0981667f86fefa545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a4371470235d727b0981667f86fefa545">generateConstraints</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;worklist, const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;reads)</td></tr>
<tr class="memdesc:a4371470235d727b0981667f86fefa545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate constraints given a system of Varnodes.  <a href="#a4371470235d727b0981667f86fefa545">More...</a><br /></td></tr>
<tr class="separator:a4371470235d727b0981667f86fefa545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b5bc9d0a1550c2136e6c3e15595945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#ad2b5bc9d0a1550c2136e6c3e15595945">checkRelativeConstant</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 &amp;typeCode, uintb &amp;value) const </td></tr>
<tr class="memdesc:ad2b5bc9d0a1550c2136e6c3e15595945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a <em>relative</em> constant.  <a href="#ad2b5bc9d0a1550c2136e6c3e15595945">More...</a><br /></td></tr>
<tr class="separator:ad2b5bc9d0a1550c2136e6c3e15595945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842872867cb49258c51084165f4a0f20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a842872867cb49258c51084165f4a0f20">generateRelativeConstraint</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *compOp, <a class="el" href="classPcodeOp.html">PcodeOp</a> *cbranch)</td></tr>
<tr class="memdesc:a842872867cb49258c51084165f4a0f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a <em>relative</em> constraint.  <a href="#a842872867cb49258c51084165f4a0f20">More...</a><br /></td></tr>
<tr class="separator:a842872867cb49258c51084165f4a0f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a6368c360ac7ce1322173feef9635bbc4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a6368c360ac7ce1322173feef9635bbc4">partitionPrepend</a> (<a class="el" href="classValueSet.html">ValueSet</a> *vertex, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:a6368c360ac7ce1322173feef9635bbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend a vertex to a partition.  <a href="#a6368c360ac7ce1322173feef9635bbc4">More...</a><br /></td></tr>
<tr class="separator:a6368c360ac7ce1322173feef9635bbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e4960de77e935167bf388f934e1e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#aa73e4960de77e935167bf388f934e1e8">partitionPrepend</a> (const <a class="el" href="classPartition.html">Partition</a> &amp;head, <a class="el" href="classPartition.html">Partition</a> &amp;part)</td></tr>
<tr class="memdesc:aa73e4960de77e935167bf388f934e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend full <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> to given <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a>.  <a href="#aa73e4960de77e935167bf388f934e1e8">More...</a><br /></td></tr>
<tr class="separator:aa73e4960de77e935167bf388f934e1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2b98c0f17a24b50706fb322ee6145c14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b98c0f17a24b50706fb322ee6145c14"></a>
list&lt; <a class="el" href="classValueSet.html">ValueSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a2b98c0f17a24b50706fb322ee6145c14">valueNodes</a></td></tr>
<tr class="memdesc:a2b98c0f17a24b50706fb322ee6145c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for all the current value sets. <br /></td></tr>
<tr class="separator:a2b98c0f17a24b50706fb322ee6145c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb788965618ec854d93fcdb7c284f87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb788965618ec854d93fcdb7c284f87"></a>
map&lt; <a class="el" href="classSeqNum.html">SeqNum</a>, <a class="el" href="classValueSetRead.html">ValueSetRead</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#aebb788965618ec854d93fcdb7c284f87">readNodes</a></td></tr>
<tr class="memdesc:aebb788965618ec854d93fcdb7c284f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional, after iteration, add-on value sets. <br /></td></tr>
<tr class="separator:aebb788965618ec854d93fcdb7c284f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4daef35e9b2e16edabb0aee04c26919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4daef35e9b2e16edabb0aee04c26919"></a>
<a class="el" href="classPartition.html">Partition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#ac4daef35e9b2e16edabb0aee04c26919">orderPartition</a></td></tr>
<tr class="memdesc:ac4daef35e9b2e16edabb0aee04c26919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value sets in iteration order. <br /></td></tr>
<tr class="separator:ac4daef35e9b2e16edabb0aee04c26919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50feee21009569676cbc28dfb31904f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50feee21009569676cbc28dfb31904f6"></a>
list&lt; <a class="el" href="classPartition.html">Partition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a50feee21009569676cbc28dfb31904f6">recordStorage</a></td></tr>
<tr class="memdesc:a50feee21009569676cbc28dfb31904f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the Partitions establishing components. <br /></td></tr>
<tr class="separator:a50feee21009569676cbc28dfb31904f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3112c1fb71e8f9fa95d809a75c0d3916"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3112c1fb71e8f9fa95d809a75c0d3916"></a>
vector&lt; <a class="el" href="classValueSet.html">ValueSet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a3112c1fb71e8f9fa95d809a75c0d3916">rootNodes</a></td></tr>
<tr class="memdesc:a3112c1fb71e8f9fa95d809a75c0d3916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values treated as inputs. <br /></td></tr>
<tr class="separator:a3112c1fb71e8f9fa95d809a75c0d3916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4418321d42d23d4ee75f25230e974690"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4418321d42d23d4ee75f25230e974690"></a>
vector&lt; <a class="el" href="classValueSet.html">ValueSet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a4418321d42d23d4ee75f25230e974690">nodeStack</a></td></tr>
<tr class="memdesc:a4418321d42d23d4ee75f25230e974690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack used to generate the topological ordering. <br /></td></tr>
<tr class="separator:a4418321d42d23d4ee75f25230e974690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0295aa881504af04699a83348725e14a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0295aa881504af04699a83348725e14a"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a0295aa881504af04699a83348725e14a">depthFirstIndex</a></td></tr>
<tr class="memdesc:a0295aa881504af04699a83348725e14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Global) depth first numbering for topological ordering <br /></td></tr>
<tr class="separator:a0295aa881504af04699a83348725e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb7c05d75bf03cd7c7d50a05adce80f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb7c05d75bf03cd7c7d50a05adce80f"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#adfb7c05d75bf03cd7c7d50a05adce80f">numIterations</a></td></tr>
<tr class="memdesc:adfb7c05d75bf03cd7c7d50a05adce80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of individual <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> iterations. <br /></td></tr>
<tr class="separator:adfb7c05d75bf03cd7c7d50a05adce80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be76d1ba9fdfe55bcb003e490bfc3e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3be76d1ba9fdfe55bcb003e490bfc3e2"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueSetSolver.html#a3be76d1ba9fdfe55bcb003e490bfc3e2">maxIterations</a></td></tr>
<tr class="memdesc:a3be76d1ba9fdfe55bcb003e490bfc3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations before forcing termination. <br /></td></tr>
<tr class="separator:a3be76d1ba9fdfe55bcb003e490bfc3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that determines a <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> for each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in a data-flow system. </p>
<p>This class uses <em>value</em> <em>set</em> <em>analysis</em> to calculate (an overestimation of) the range of values that can reach each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The system is formed by providing a set of Varnodes for which the range is desired (the sinks) via <a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300" title="Build value sets for a data-flow system. ">establishValueSets()</a>. This creates a system of Varnodes (within the single function) that can flow to the sinks. Running the method <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c" title="Iterate the ValueSet system until it stabilizes. ">solve()</a> does the analysis, and the caller can examine the results by examining the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> attached to any of the Varnodes in the system (via <a class="el" href="classVarnode.html#a5885a1b0f28317004caf4f5f15f4e2bf" title="Get the temporary ValueSet record. ">Varnode::getValueSet()</a>). The <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c" title="Iterate the ValueSet system until it stabilizes. ">ValueSetSolver::solve()</a> starts with minimal value sets and does iteration steps by pushing them through the PcodeOps until stability is reached. A <a class="el" href="classWidener.html" title="Class holding a particular widening strategy for the ValueSetSolver iteration algorithm. ">Widener</a> object is passed to <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c" title="Iterate the ValueSet system until it stabilizes. ">solve()</a> which selects the specific strategy for accelerating convergence. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a629f30eb1a0d4f35bc9bc3a855813be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::applyConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look for PcodeOps where the given constraint range applies and instantiate an equation. </p>
<p>If a read of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is in a basic block dominated by the condition producing the constraint, then either the constraint or its complement applies to the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> reading the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. An equation holding the constraint is added to the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> output of the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">type</td><td>is the constraint characteristic </td></tr>
    <tr><td class="paramname">range</td><td>is the known constraint (assuming the <b>true</b> branch was taken) </td></tr>
    <tr><td class="paramname">cbranch</td><td>is conditional branch creating the constraint </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#aba05386f8342a24d5f9fd3b5e9bea4ac">ValueSet::addLandmark()</a>, <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classFlowBlock.html#a25e62c0a67e4eb420c38cd4b4af58376">FlowBlock::getFalseOut()</a>, <a class="el" href="classFlowBlock.html#af89021d9b4861fa2b1c6b8de466a2231">FlowBlock::getImmedDom()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classFlowBlock.html#a0b0257666ffe890581a19a4e1e712f07">FlowBlock::getTrueOut()</a>, <a class="el" href="classVarnode.html#a5885a1b0f28317004caf4f5f15f4e2bf">Varnode::getValueSet()</a>, <a class="el" href="classPcodeOp.html#a8446ab669a53d9306526a563ba0d77ed">PcodeOp::isBooleanFlip()</a>, <a class="el" href="classPcodeOp.html#af03aefce85152f7f638a5d87ceccc495">PcodeOp::isMark()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classValueSet.html#ad6178f7f7c6875a30070907559143ebf">ValueSet::opCode</a>, and <a class="el" href="classFlowBlock.html#a9eea3198bd3f6507b231cb40c5c2c5ee">FlowBlock::restrictedByConditional()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2b5bc9d0a1550c2136e6c3e15595945"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueSetSolver::checkRelativeConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>typeCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a <em>relative</em> constant. </p>
<p>Verify that the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is produced by a straight line sequence of COPYs, INT_ADDs with a constant, from the base register marked as <em>relative</em> for our system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">typeCode</td><td>will hold the base register code (if found) </td></tr>
    <tr><td class="paramname">value</td><td>will hold the additive value relative to the base register (if found) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a <em>relative</em> constant </dd></dl>

<p>References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acd169003bfcb2e8dde0cb2dc1f534449">CPUI_PTRSUB</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a5885a1b0f28317004caf4f5f15f4e2bf">Varnode::getValueSet()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, and <a class="el" href="classValueSet.html#a4a81331349a81dd4e1b9bb586f8de34d">ValueSet::typeCode</a>.</p>

</div>
</div>
<a class="anchor" id="a97a09332b5c711af6adc8b9603b5b9bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueSet.html">ValueSet</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a partition component given its head. </p>
<p>Knowing that the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is the head of a partition, generate the partition recursively and generate the formal <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the given <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> (attached to the head <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>) </td></tr>
    <tr><td class="paramname">part</td><td>will hold the constructed <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#aae21d8d6a782bbce080a7633a3b8272e">ValueSet::count</a>, and <a class="el" href="classValueSetSolver_1_1ValueSetEdge.html#a9d332bbfd70ec494811c0d98d7dad5a4">ValueSetSolver::ValueSetEdge::getNext()</a>.</p>

</div>
</div>
<a class="anchor" id="a69e256b19fd0b267fe7d356c2bbff0f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::constraintsFromCBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate constraints arising from the given branch. </p>
<p>Lift the set of values on the condition for the given CBRANCH to any <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the system, and label (the reads) of any such <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with the constraint. If the values cannot be lifted or no <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the system is found, no constraints are generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbranch</td><td>is the given condition branch </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a091539b02c09c885351f789b24afba7b">PcodeOp::isCall()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, and <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a874fc29428abfe7c8b503f8daae65558"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::constraintsFromPath </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>lift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>startVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>endVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate constraints given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> path. </p>
<p>Knowing that there is a lifting path from the given starting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to an ending <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the system, go ahead and lift the given range to a final constraint on the ending <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. Then look for reads of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> where the constraint applies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the constraint characteristic </td></tr>
    <tr><td class="paramname">lift</td><td>is the given range that will be lifted </td></tr>
    <tr><td class="paramname">startVn</td><td>is the starting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">endVn</td><td>is the given ending <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the system </td></tr>
    <tr><td class="paramname">cbranch</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> causing the control-flow split </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a091539b02c09c885351f789b24afba7b">PcodeOp::isCall()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, and <a class="el" href="classCircleRange.html#a8b2b3063264a1169940c7131628b9a4b">CircleRange::pullBack()</a>.</p>

</div>
</div>
<a class="anchor" id="a81a3f29f53647357d726347855bc3df7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::establishTopologicalOrder </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the optimal order for iterating through the ValueSets. </p>
<p>Establish the recursive node ordering for iteratively solving the value set system.</p>
<p>This algorithm is based on "Efficient chaotic iteration strategies with widenings" by Francois Bourdoncle. The Varnodes in the system are ordered and a set of nested <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> components are generated. Iterating the ValueSets proceeds in this order, looping through the components recursively until a fixed point is reached. This implementation assumes all Varnodes in the system are distinguished by <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1" title="Has this been visited by the current algorithm? ">Varnode::isMark()</a> returning <b>true</b>. </p>

<p>References <a class="el" href="classValueSet.html#a3dadcc9da8de045ec07dd214b8a70836">ValueSet::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a43a4cb32e3aef1c1cb92cd5b8d6dd300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::establishValueSets </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indirectAsCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build value sets for a data-flow system. </p>
<p>Given a set of sinks, find all the Varnodes that flow directly into them and set up their initial <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinks</td><td>is the list terminating Varnodes </td></tr>
    <tr><td class="paramname">reads</td><td>are add-on PcodeOps where we would like to know input ValueSets at the point of read </td></tr>
    <tr><td class="paramname">stackReg</td><td>(if non-NULL) gives the stack pointer (for keeping track of relative offsets) </td></tr>
    <tr><td class="paramname">indirectAsCopy</td><td>is <b>true</b> if solver should treat CPUI_INDIRECT as CPUI_COPY operations </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a7a2b625788b1d23eda50975b6baf7efb">CPUI_CALLOTHER</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5d4235f59c3d4320bae86e84f0cc9f62">CPUI_CPOOLREF</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a8c28845dbb4e140c5225a27b2bc999">CPUI_FLOAT_ABS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7adda2cf75b28cc922eb7c98a73c7f52c0">CPUI_FLOAT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a4db96873fdb4d248df39cb0db9520c0a">CPUI_FLOAT_CEIL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a0736fe93f55b50513a969c9403ce0f">CPUI_FLOAT_DIV</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aab409a4f8049204cbe5be65787497842">CPUI_FLOAT_FLOAT2FLOAT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a4d3f1b7b6743fe7d9f448961aa623196">CPUI_FLOAT_FLOOR</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2fd5fa2cce0871ff743a532f778f33a1">CPUI_FLOAT_INT2FLOAT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a31b993d1b210255c90306c5253fdb7f6">CPUI_FLOAT_MULT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a51d26f25c64bd9a9cf3cd7caaaf92b2c">CPUI_FLOAT_NEG</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acf38a393024ddf5b2d6e59c114a7fd60">CPUI_FLOAT_ROUND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0ae2b4db2d21aa9fc438f7017bd174a4">CPUI_FLOAT_SQRT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad99c56e45d45e1b405f9ba5d3fadcc44">CPUI_FLOAT_SUB</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a6a5722455afc241a3628add3b41efc73">CPUI_FLOAT_TRUNC</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a980255c6f8e1cd7c7c7b035554292735">CPUI_NEW</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab67fab74923ce6c8be1c2254b9afb4f9">CPUI_SEGMENTOP</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classVarnode.html#a5885a1b0f28317004caf4f5f15f4e2bf">Varnode::getValueSet()</a>, <a class="el" href="classVarnode.html#af7d640b593a55ac3eb63fa7322fb8a2a">Varnode::isAnnotation()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classPcodeOp.html#a7a604238b180a059aebdfb4e43f871ff">PcodeOp::isIndirectStore()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae">Varnode::isSpacebase()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classValueSet.html#a09b1c5b6979ef3151836fd3c98d7f725">ValueSet::setFull()</a>, <a class="el" href="classPcodeOp.html#ab2ba9f66448cd77b6f274de6fae433e2">PcodeOp::setMark()</a>, and <a class="el" href="classVarnode.html#a98825616d50a27a615057e625a61285e">Varnode::setMark()</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#a7d518d053e1834e600be703ba0ac91b1">Heritage::analyzeNewLoadGuards()</a>.</p>

</div>
</div>
<a class="anchor" id="a4371470235d727b0981667f86fefa545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateConstraints </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>worklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>reads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate constraints given a system of Varnodes. </p>
<p>Given a complete data-flow system of Varnodes, look for any <em>constraint:</em> </p><ul>
<li>For a particular <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a></li>
<li>A limited set of values</li>
<li>Due to its involvement in a branch condition</li>
<li>Which applies at a particular <em>read</em> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worklist</td><td>is the set of Varnodes in the data-flow system (all marked) </td></tr>
    <tr><td class="paramname">reads</td><td>is the additional set of PcodeOps that read a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from the system </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classFlowBlock.html#af89021d9b4861fa2b1c6b8de466a2231">FlowBlock::getImmedDom()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classFlowBlock.html#a2487635c6f46d1ee4b0e14c67af760e6">FlowBlock::isMark()</a>, <a class="el" href="classBlockBasic.html#a94b8b6786b04a8cb00e5d0fc2977a675">BlockBasic::lastOp()</a>, <a class="el" href="classFlowBlock.html#a3a64aa8a8182a65f5e1e361d23ecc3c8">FlowBlock::setMark()</a>, <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>, and <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e500970c198d5d59cf05dbb9b359ee0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateFalseEquation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the complementary equation given a <b>true</b> constraint and the input/output Varnodes it affects. </p>
<p>The equation is expressed as: only <b>false</b> values can reach the indicated input to a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. The equation is attached to the output of the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> the equation will be attached to </td></tr>
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the constrained input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">type</td><td>is the type of values </td></tr>
    <tr><td class="paramname">range</td><td>is the range of <b>true</b> values, which must be complemented </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#ae82dcc004178e8a85d13e36d084cb336">ValueSet::addEquation()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classVarnode.html#a5885a1b0f28317004caf4f5f15f4e2bf">Varnode::getValueSet()</a>, and <a class="el" href="classCircleRange.html#a7e05a9a4816b825f76d823742b2775b4">CircleRange::invert()</a>.</p>

</div>
</div>
<a class="anchor" id="a842872867cb49258c51084165f4a0f20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateRelativeConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>compOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>cbranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find a <em>relative</em> constraint. </p>
<p>Given a binary <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> producing a conditional branch, check if it can be interpreted as a constraint relative to (the) base register specified for this system. If it can be, a <em>relative</em> Equation is generated, which will apply to <em>relative</em> ValueSets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compOp</td><td>is the comparison <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">cbranch</td><td>is the conditional branch </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7abfca59d2db4cdc6126afa1d60e4aba51">CPUI_INT_EQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9fd7576d8174c8e8ad99a71b1bed2518">CPUI_INT_LESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2c6c583f14722fee36325c926280cbcc">CPUI_INT_LESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a82aa9ec8e7933e35b09e963cd87c2f30">CPUI_INT_NOTEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a05aafda58e54690ae841c3642e3b82">CPUI_INT_SLESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a49d2a9e93a7a397287ea70f8d6c6a132">CPUI_INT_SLESSEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acd169003bfcb2e8dde0cb2dc1f534449">CPUI_PTRSUB</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, and <a class="el" href="classCircleRange.html#a740302ad37ddc285b0527fb6b3c69703">CircleRange::pullBackBinary()</a>.</p>

</div>
</div>
<a class="anchor" id="a129d92ea3879a4ca9dc26d6b1c7d28ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::generateTrueEquation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCircleRange.html">CircleRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an equation given a <b>true</b> constraint and the input/output Varnodes it affects. </p>
<p>The equation is expressed as: only <b>true</b> values can reach the indicated input to a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. The equation is attached to the output of the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> the equation will be attached to </td></tr>
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the constrained input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">type</td><td>is the type of values </td></tr>
    <tr><td class="paramname">range</td><td>is the range of <b>true</b> values </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#ae82dcc004178e8a85d13e36d084cb336">ValueSet::addEquation()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, and <a class="el" href="classVarnode.html#a5885a1b0f28317004caf4f5f15f4e2bf">Varnode::getValueSet()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa7e03150bb730888b0a41b470a845cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::newValueSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>tCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate storage for a new <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a>. </p>
<p>The new <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> is attached to the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">tCode</td><td>is the type to associate with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6368c360ac7ce1322173feef9635bbc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::partitionPrepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueSet.html">ValueSet</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend a vertex to a partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the node that will be prepended </td></tr>
    <tr><td class="paramname">part</td><td>is the <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> being modified </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>, and <a class="el" href="classPartition.html#a69fb837215064c4654f59139c02f73d8">Partition::stopNode</a>.</p>

</div>
</div>
<a class="anchor" id="aa73e4960de77e935167bf388f934e1e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::partitionPrepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend full <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> to given <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>is the partition to be prepended </td></tr>
    <tr><td class="paramname">part</td><td>is the given partition being modified (prepended to) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>, and <a class="el" href="classPartition.html#a69fb837215064c4654f59139c02f73d8">Partition::stopNode</a>.</p>

</div>
</div>
<a class="anchor" id="af45d0eae011647af953863a4d9145f47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::partitionSurround </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a full partition component. </p>
<p>This method saves a <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> to permanent storage. It marks the starting node of the partition and sets up for the iterating algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>is the partition to store </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classValueSet.html#a20a15827de3f50e15eb8a70198bae5c8">ValueSet::partHead</a>, and <a class="el" href="classPartition.html#a63681ffecc917c6bf11dd78e891f7c67">Partition::startNode</a>.</p>

</div>
</div>
<a class="anchor" id="a8dec4550f9502575b92ca93bf997185c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueSetSolver::solve </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWidener.html">Widener</a> &amp;&#160;</td>
          <td class="paramname"><em>widener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate the <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> system until it stabilizes. </p>
<p>The ValueSets are recalculated in the established topological ordering, with looping at various levels until a fixed point is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>is the maximum number of iterations to allow before forcing termination </td></tr>
    <tr><td class="paramname">widener</td><td>is the Widening strategy to use to accelerate stabilization </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classWidener.html#ad2dae5401b12d1ae6839b7475d5d8cb4">Widener::determineIterationReset()</a>, <a class="el" href="classPartition.html#a8f1b58895209c9705d03290fc5f23478">Partition::isDirty</a>, <a class="el" href="classValueSet.html#a72f774ca4732701ced824502ab462ead">ValueSet::iterate()</a>, <a class="el" href="classValueSet.html#a0ee10854e8e6b08a2b7c565d1f035ced">ValueSet::next</a>, <a class="el" href="classValueSet.html#a20a15827de3f50e15eb8a70198bae5c8">ValueSet::partHead</a>, and <a class="el" href="classValueSet.html#ada7acbfb478e75b3a7718bde8774224c">ValueSet::printRaw()</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#a7d518d053e1834e600be703ba0ac91b1">Heritage::analyzeNewLoadGuards()</a>.</p>

</div>
</div>
<a class="anchor" id="add4d625b2cec5d8712551e63737f42b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 ValueSetSolver::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueSet.html">ValueSet</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPartition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively walk the data-flow graph finding partitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>is the current <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> being walked </td></tr>
    <tr><td class="paramname">part</td><td>is the current <a class="el" href="classPartition.html" title="A range of nodes (within the weak topological ordering) that are iterated together. ">Partition</a> being constructed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of calculated head <a class="el" href="classValueSet.html" title="A range of values attached to a Varnode within a data-flow subsystem. ">ValueSet</a> for the current Parition </dd></dl>

<p>References <a class="el" href="classValueSet.html#aae21d8d6a782bbce080a7633a3b8272e">ValueSet::count</a>, and <a class="el" href="classValueSetSolver_1_1ValueSetEdge.html#a9d332bbfd70ec494811c0d98d7dad5a4">ValueSetSolver::ValueSetEdge::getNext()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="rangeutil_8hh.html">rangeutil.hh</a></li>
<li>rangeutil.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
