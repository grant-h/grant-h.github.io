<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: Funcdata Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFuncdata-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Funcdata Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container for data structures associated with a single function.  
 <a href="classFuncdata.html#details">More...</a></p>

<p><code>#include &lt;funcdata.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a979faf589906b1a1937623f7a2a186f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a979faf589906b1a1937623f7a2a186f2">Funcdata</a> (const string &amp;nm, <a class="el" href="classScope.html">Scope</a> *conf, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *sym, int4 sz=0)</td></tr>
<tr class="memdesc:a979faf589906b1a1937623f7a2a186f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a979faf589906b1a1937623f7a2a186f2">More...</a><br /></td></tr>
<tr class="separator:a979faf589906b1a1937623f7a2a186f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4fb40eeb52f948ca7a14187a21c7db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4fb40eeb52f948ca7a14187a21c7db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0b4fb40eeb52f948ca7a14187a21c7db">~Funcdata</a> (void)</td></tr>
<tr class="memdesc:a0b4fb40eeb52f948ca7a14187a21c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a0b4fb40eeb52f948ca7a14187a21c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a0e80f90d02397255cf1d3b11f86cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a0e80f90d02397255cf1d3b11f86cd"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a25a0e80f90d02397255cf1d3b11f86cd">getName</a> (void) const </td></tr>
<tr class="memdesc:a25a0e80f90d02397255cf1d3b11f86cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function's local symbol name. <br /></td></tr>
<tr class="separator:a25a0e80f90d02397255cf1d3b11f86cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91233c941630a3194e8287206314bb1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91233c941630a3194e8287206314bb1e"></a>
const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a91233c941630a3194e8287206314bb1e">getAddress</a> (void) const </td></tr>
<tr class="memdesc:a91233c941630a3194e8287206314bb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entry point address. <br /></td></tr>
<tr class="separator:a91233c941630a3194e8287206314bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adf54f83f73eae3a2e2efa124fcb80e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3adf54f83f73eae3a2e2efa124fcb80e"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3adf54f83f73eae3a2e2efa124fcb80e">getSize</a> (void) const </td></tr>
<tr class="memdesc:a3adf54f83f73eae3a2e2efa124fcb80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function body size in bytes. <br /></td></tr>
<tr class="separator:a3adf54f83f73eae3a2e2efa124fcb80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0912e60caaf80197b82ff00ddf6af73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0912e60caaf80197b82ff00ddf6af73"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">getArch</a> (void) const </td></tr>
<tr class="memdesc:ae0912e60caaf80197b82ff00ddf6af73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the program/architecture owning <b>this</b> function. <br /></td></tr>
<tr class="separator:ae0912e60caaf80197b82ff00ddf6af73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2956d007338b4530955c72ab63b659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba2956d007338b4530955c72ab63b659"></a>
<a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aba2956d007338b4530955c72ab63b659">getSymbol</a> (void) const </td></tr>
<tr class="memdesc:aba2956d007338b4530955c72ab63b659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symbol associated with <b>this</b> function. <br /></td></tr>
<tr class="separator:aba2956d007338b4530955c72ab63b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef3b78bc9d85d2f69bf655c7d4d159f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afef3b78bc9d85d2f69bf655c7d4d159f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afef3b78bc9d85d2f69bf655c7d4d159f">isHighOn</a> (void) const </td></tr>
<tr class="memdesc:afef3b78bc9d85d2f69bf655c7d4d159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are high-level variables assigned to Varnodes. <br /></td></tr>
<tr class="separator:afef3b78bc9d85d2f69bf655c7d4d159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4810aa4367461ca77770e9822c918e7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4810aa4367461ca77770e9822c918e7e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4810aa4367461ca77770e9822c918e7e">isProcStarted</a> (void) const </td></tr>
<tr class="memdesc:a4810aa4367461ca77770e9822c918e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has processing of the function started. <br /></td></tr>
<tr class="separator:a4810aa4367461ca77770e9822c918e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa528872e5ae68c50cfa835a508ed53dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa528872e5ae68c50cfa835a508ed53dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa528872e5ae68c50cfa835a508ed53dd">isProcComplete</a> (void) const </td></tr>
<tr class="memdesc:aa528872e5ae68c50cfa835a508ed53dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is processing of the function complete. <br /></td></tr>
<tr class="separator:aa528872e5ae68c50cfa835a508ed53dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bcb625a6d832f71b220987c829fd4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6bcb625a6d832f71b220987c829fd4b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad6bcb625a6d832f71b220987c829fd4b">hasUnreachableBlocks</a> (void) const </td></tr>
<tr class="memdesc:ad6bcb625a6d832f71b220987c829fd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this function exhibit unreachable code. <br /></td></tr>
<tr class="separator:ad6bcb625a6d832f71b220987c829fd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7f9e45be3f510295a0156afde40f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7f9e45be3f510295a0156afde40f63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afa7f9e45be3f510295a0156afde40f63">isTypeRecoveryOn</a> (void) const </td></tr>
<tr class="memdesc:afa7f9e45be3f510295a0156afde40f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has data-type recovery processes started. <br /></td></tr>
<tr class="separator:afa7f9e45be3f510295a0156afde40f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a54cc73ea882bf0e829a6ee090070a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a54cc73ea882bf0e829a6ee090070a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a58a54cc73ea882bf0e829a6ee090070a">hasNoCode</a> (void) const </td></tr>
<tr class="memdesc:a58a54cc73ea882bf0e829a6ee090070a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> function has no code body. <br /></td></tr>
<tr class="separator:a58a54cc73ea882bf0e829a6ee090070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac206ee7731d8f4db960f6daadc8b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ac206ee7731d8f4db960f6daadc8b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa9ac206ee7731d8f4db960f6daadc8b4">setNoCode</a> (bool val)</td></tr>
<tr class="memdesc:aa9ac206ee7731d8f4db960f6daadc8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> has a body. <br /></td></tr>
<tr class="separator:aa9ac206ee7731d8f4db960f6daadc8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a0ab8b2257db49bf4aef9cb259c4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793a0ab8b2257db49bf4aef9cb259c4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a793a0ab8b2257db49bf4aef9cb259c4d">setLanedRegGenerated</a> (void)</td></tr>
<tr class="memdesc:a793a0ab8b2257db49bf4aef9cb259c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that laned registers have been collected. <br /></td></tr>
<tr class="separator:a793a0ab8b2257db49bf4aef9cb259c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33bb4d59a0125d36710fe80453b9526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac33bb4d59a0125d36710fe80453b9526">setJumptableRecovery</a> (bool val)</td></tr>
<tr class="memdesc:ac33bb4d59a0125d36710fe80453b9526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> is being used for jump-table recovery.  <a href="#ac33bb4d59a0125d36710fe80453b9526">More...</a><br /></td></tr>
<tr class="separator:ac33bb4d59a0125d36710fe80453b9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4675699d22d3718396a3a18faf194d16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4675699d22d3718396a3a18faf194d16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4675699d22d3718396a3a18faf194d16">isJumptableRecoveryOn</a> (void) const </td></tr>
<tr class="memdesc:a4675699d22d3718396a3a18faf194d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> used for jump-table recovery. <br /></td></tr>
<tr class="separator:a4675699d22d3718396a3a18faf194d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bcddc7a3b959812f9a1660b39cc6ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a23bcddc7a3b959812f9a1660b39cc6ef">setDoublePrecisRecovery</a> (bool val)</td></tr>
<tr class="memdesc:a23bcddc7a3b959812f9a1660b39cc6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether double precision analysis is used.  <a href="#a23bcddc7a3b959812f9a1660b39cc6ef">More...</a><br /></td></tr>
<tr class="separator:a23bcddc7a3b959812f9a1660b39cc6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae921e42a65283ce74841c5920df4e08f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae921e42a65283ce74841c5920df4e08f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae921e42a65283ce74841c5920df4e08f">isDoublePrecisOn</a> (void) const </td></tr>
<tr class="memdesc:ae921e42a65283ce74841c5920df4e08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is double precision analysis enabled. <br /></td></tr>
<tr class="separator:ae921e42a65283ce74841c5920df4e08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1665c646d412bf857673ecb8378eeae1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1665c646d412bf857673ecb8378eeae1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1665c646d412bf857673ecb8378eeae1">hasNoStructBlocks</a> (void) const </td></tr>
<tr class="memdesc:a1665c646d412bf857673ecb8378eeae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if no block structuring was performed. <br /></td></tr>
<tr class="separator:a1665c646d412bf857673ecb8378eeae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b616d10d9514eda69dd9d974c62eb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b616d10d9514eda69dd9d974c62eb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a25b616d10d9514eda69dd9d974c62eb8">clear</a> (void)</td></tr>
<tr class="memdesc:a25b616d10d9514eda69dd9d974c62eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out old disassembly. <br /></td></tr>
<tr class="separator:a25b616d10d9514eda69dd9d974c62eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c52c01a921d0ec70e263f0acba1344b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1c52c01a921d0ec70e263f0acba1344b">warning</a> (const string &amp;txt, const <a class="el" href="classAddress.html">Address</a> &amp;ad) const </td></tr>
<tr class="memdesc:a1c52c01a921d0ec70e263f0acba1344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a warning comment in the function body.  <a href="#a1c52c01a921d0ec70e263f0acba1344b">More...</a><br /></td></tr>
<tr class="separator:a1c52c01a921d0ec70e263f0acba1344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5084ee379b9bdbcd47ef1b4b73a7b362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader</a> (const string &amp;txt) const </td></tr>
<tr class="memdesc:a5084ee379b9bdbcd47ef1b4b73a7b362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a warning comment as part of the function header.  <a href="#a5084ee379b9bdbcd47ef1b4b73a7b362">More...</a><br /></td></tr>
<tr class="separator:a5084ee379b9bdbcd47ef1b4b73a7b362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0637a2c7f6a1e511284cfeecb4b0d475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">startProcessing</a> (void)</td></tr>
<tr class="memdesc:a0637a2c7f6a1e511284cfeecb4b0d475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start processing for this function.  <a href="#a0637a2c7f6a1e511284cfeecb4b0d475">More...</a><br /></td></tr>
<tr class="separator:a0637a2c7f6a1e511284cfeecb4b0d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b7bf9f9ad6a3c56968f4daa9ca27d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36b7bf9f9ad6a3c56968f4daa9ca27d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a36b7bf9f9ad6a3c56968f4daa9ca27d5">stopProcessing</a> (void)</td></tr>
<tr class="memdesc:a36b7bf9f9ad6a3c56968f4daa9ca27d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that processing has completed for this function. <br /></td></tr>
<tr class="separator:a36b7bf9f9ad6a3c56968f4daa9ca27d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0add0ec99a303d6cdfc5187bb2c768f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0add0ec99a303d6cdfc5187bb2c768f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0add0ec99a303d6cdfc5187bb2c768f7">startTypeRecovery</a> (void)</td></tr>
<tr class="memdesc:a0add0ec99a303d6cdfc5187bb2c768f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that data-type analysis has started. <br /></td></tr>
<tr class="separator:a0add0ec99a303d6cdfc5187bb2c768f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f04b2e649dafbd6384d6a5ad7417290"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f04b2e649dafbd6384d6a5ad7417290"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5f04b2e649dafbd6384d6a5ad7417290">startCastPhase</a> (void)</td></tr>
<tr class="memdesc:a5f04b2e649dafbd6384d6a5ad7417290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the <b>cast</b> insertion phase. <br /></td></tr>
<tr class="separator:a5f04b2e649dafbd6384d6a5ad7417290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6de78fed99ef925f13ec07b784728cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6de78fed99ef925f13ec07b784728cf"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad6de78fed99ef925f13ec07b784728cf">getCastPhaseIndex</a> (void) const </td></tr>
<tr class="memdesc:ad6de78fed99ef925f13ec07b784728cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation index at the start of <b>cast</b> insertion. <br /></td></tr>
<tr class="separator:ad6de78fed99ef925f13ec07b784728cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081dede3bf2aeb95d52c1e776bad4868"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081dede3bf2aeb95d52c1e776bad4868"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a081dede3bf2aeb95d52c1e776bad4868">getHighLevelIndex</a> (void) const </td></tr>
<tr class="memdesc:a081dede3bf2aeb95d52c1e776bad4868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation index at the start of <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> creation. <br /></td></tr>
<tr class="separator:a081dede3bf2aeb95d52c1e776bad4868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e446945c2081176890607173cbb461"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e446945c2081176890607173cbb461"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a29e446945c2081176890607173cbb461">startCleanUp</a> (void)</td></tr>
<tr class="memdesc:a29e446945c2081176890607173cbb461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start <em>clean-up</em> phase. <br /></td></tr>
<tr class="separator:a29e446945c2081176890607173cbb461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f18dcdcc8c4e53c9851678d897537"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f8f18dcdcc8c4e53c9851678d897537"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex</a> (void) const </td></tr>
<tr class="memdesc:a4f8f18dcdcc8c4e53c9851678d897537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation index at the start of <b>clean-up</b> phase. <br /></td></tr>
<tr class="separator:a4f8f18dcdcc8c4e53c9851678d897537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8f8e90f70db000a97d80677cdb133b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5c8f8e90f70db000a97d80677cdb133b">followFlow</a> (const <a class="el" href="classAddress.html">Address</a> &amp;baddr, const <a class="el" href="classAddress.html">Address</a> &amp;eadddr)</td></tr>
<tr class="memdesc:a5c8f8e90f70db000a97d80677cdb133b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate raw p-code for the function.  <a href="#a5c8f8e90f70db000a97d80677cdb133b">More...</a><br /></td></tr>
<tr class="separator:a5c8f8e90f70db000a97d80677cdb133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122718ad87c13b714676c61050461388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">truncatedFlow</a> (const <a class="el" href="classFuncdata.html">Funcdata</a> *fd, const <a class="el" href="classFlowInfo.html">FlowInfo</a> *flow)</td></tr>
<tr class="memdesc:a122718ad87c13b714676c61050461388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a clone with truncated control-flow given a partial function.  <a href="#a122718ad87c13b714676c61050461388">More...</a><br /></td></tr>
<tr class="separator:a122718ad87c13b714676c61050461388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc11dc2a2eefa48bc4b244094a521f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *inlinefd, <a class="el" href="classFlowInfo.html">FlowInfo</a> &amp;flow, <a class="el" href="classPcodeOp.html">PcodeOp</a> *callop)</td></tr>
<tr class="memdesc:a3bcc11dc2a2eefa48bc4b244094a521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-line the p-code from another function into <b>this</b> function.  <a href="#a3bcc11dc2a2eefa48bc4b244094a521f">More...</a><br /></td></tr>
<tr class="separator:a3bcc11dc2a2eefa48bc4b244094a521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb83719ca201b5d57283058e2bcadee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, uint4 type)</td></tr>
<tr class="memdesc:aafb83719ca201b5d57283058e2bcadee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> the control-flow p-code for a particular instruction.  <a href="#aafb83719ca201b5d57283058e2bcadee">More...</a><br /></td></tr>
<tr class="separator:aafb83719ca201b5d57283058e2bcadee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1dd79d78141f89d374e570de21d690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adb1dd79d78141f89d374e570de21d690">doLiveInject</a> (<a class="el" href="classInjectPayload.html">InjectPayload</a> *payload, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::iterator pos)</td></tr>
<tr class="memdesc:adb1dd79d78141f89d374e570de21d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject p-code from a <em>payload</em> into <b>this</b> live function.  <a href="#adb1dd79d78141f89d374e570de21d690">More...</a><br /></td></tr>
<tr class="separator:adb1dd79d78141f89d374e570de21d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12c58fc86373ad2b650342c68333748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae12c58fc86373ad2b650342c68333748">printRaw</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:ae12c58fc86373ad2b650342c68333748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print raw p-code op descriptions to a stream.  <a href="#ae12c58fc86373ad2b650342c68333748">More...</a><br /></td></tr>
<tr class="separator:ae12c58fc86373ad2b650342c68333748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3f7ed3fc9cf513f60cb31dcbfddad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ade3f7ed3fc9cf513f60cb31dcbfddad4">printVarnodeTree</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:ade3f7ed3fc9cf513f60cb31dcbfddad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of all Varnodes to a stream.  <a href="#ade3f7ed3fc9cf513f60cb31dcbfddad4">More...</a><br /></td></tr>
<tr class="separator:ade3f7ed3fc9cf513f60cb31dcbfddad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0940f0bf1bb935c2da97d7a99a6c009c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0940f0bf1bb935c2da97d7a99a6c009c">printBlockTree</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a0940f0bf1bb935c2da97d7a99a6c009c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of control-flow structuring to a stream.  <a href="#a0940f0bf1bb935c2da97d7a99a6c009c">More...</a><br /></td></tr>
<tr class="separator:a0940f0bf1bb935c2da97d7a99a6c009c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d44413d6978a8296daa5a58a19fc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae81d44413d6978a8296daa5a58a19fc6">printLocalRange</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:ae81d44413d6978a8296daa5a58a19fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print description of memory ranges associated with local scopes.  <a href="#ae81d44413d6978a8296daa5a58a19fc6">More...</a><br /></td></tr>
<tr class="separator:ae81d44413d6978a8296daa5a58a19fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23142354572370c67625649f5119c8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad23142354572370c67625649f5119c8a">saveXml</a> (ostream &amp;s, uint8 id, bool savetree) const </td></tr>
<tr class="memdesc:ad23142354572370c67625649f5119c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an XML description of <b>this</b> function to stream.  <a href="#ad23142354572370c67625649f5119c8a">More...</a><br /></td></tr>
<tr class="separator:ad23142354572370c67625649f5119c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7419de8057421b8e9300c4a26c60ecef"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7419de8057421b8e9300c4a26c60ecef">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a7419de8057421b8e9300c4a26c60ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the state of <b>this</b> function from an XML description.  <a href="#a7419de8057421b8e9300c4a26c60ecef">More...</a><br /></td></tr>
<tr class="separator:a7419de8057421b8e9300c4a26c60ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e8c3b03e9562c19a7550ce5d064f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a503e8c3b03e9562c19a7550ce5d064f0">saveXmlJumpTable</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a503e8c3b03e9562c19a7550ce5d064f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an XML description of jump-tables to stream.  <a href="#a503e8c3b03e9562c19a7550ce5d064f0">More...</a><br /></td></tr>
<tr class="separator:a503e8c3b03e9562c19a7550ce5d064f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a41bb91dd51c9a76d8f6d1e2f09328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a07a41bb91dd51c9a76d8f6d1e2f09328">restoreXmlJumpTable</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a07a41bb91dd51c9a76d8f6d1e2f09328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore jump-tables from an XML description.  <a href="#a07a41bb91dd51c9a76d8f6d1e2f09328">More...</a><br /></td></tr>
<tr class="separator:a07a41bb91dd51c9a76d8f6d1e2f09328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715a24e059f8fa8e8367e49828f53b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a715a24e059f8fa8e8367e49828f53b7b">saveXmlTree</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a715a24e059f8fa8e8367e49828f53b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an XML description of the p-code tree to stream.  <a href="#a715a24e059f8fa8e8367e49828f53b7b">More...</a><br /></td></tr>
<tr class="separator:a715a24e059f8fa8e8367e49828f53b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a72207c0e2dccc2dc7b3156cc11ad52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8a72207c0e2dccc2dc7b3156cc11ad52">saveXmlHigh</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a8a72207c0e2dccc2dc7b3156cc11ad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an XML description of all HighVariables to stream.  <a href="#a8a72207c0e2dccc2dc7b3156cc11ad52">More...</a><br /></td></tr>
<tr class="separator:a8a72207c0e2dccc2dc7b3156cc11ad52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48d087ed5fbf901cfa608d8f44b6d5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac48d087ed5fbf901cfa608d8f44b6d5c"></a>
<a class="el" href="classOverride.html">Override</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac48d087ed5fbf901cfa608d8f44b6d5c">getOverride</a> (void)</td></tr>
<tr class="memdesc:ac48d087ed5fbf901cfa608d8f44b6d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> object for <b>this</b> function. <br /></td></tr>
<tr class="separator:ac48d087ed5fbf901cfa608d8f44b6d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21c852eb9f606c5cd19fb2456927ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af21c852eb9f606c5cd19fb2456927ecd">setRestartPending</a> (bool val)</td></tr>
<tr class="memdesc:af21c852eb9f606c5cd19fb2456927ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether analysis needs to be restarted for <b>this</b> function.  <a href="#af21c852eb9f606c5cd19fb2456927ecd">More...</a><br /></td></tr>
<tr class="separator:af21c852eb9f606c5cd19fb2456927ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e69e58827608e30fa99e143f939527"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad6e69e58827608e30fa99e143f939527">hasRestartPending</a> (void) const </td></tr>
<tr class="memdesc:ad6e69e58827608e30fa99e143f939527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> function need to restart its analysis.  <a href="#ad6e69e58827608e30fa99e143f939527">More...</a><br /></td></tr>
<tr class="separator:ad6e69e58827608e30fa99e143f939527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b05652e37659c8fc66ec02b2a058a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a06b05652e37659c8fc66ec02b2a058a4">hasUnimplemented</a> (void) const </td></tr>
<tr class="memdesc:a06b05652e37659c8fc66ec02b2a058a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> function have instructions marked as <em>unimplemented</em>.  <a href="#a06b05652e37659c8fc66ec02b2a058a4">More...</a><br /></td></tr>
<tr class="separator:a06b05652e37659c8fc66ec02b2a058a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287bc196bb5fa26fb1a8197a1e4c6eca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a287bc196bb5fa26fb1a8197a1e4c6eca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a287bc196bb5fa26fb1a8197a1e4c6eca">hasBadData</a> (void) const </td></tr>
<tr class="memdesc:a287bc196bb5fa26fb1a8197a1e4c6eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> function flow into bad data. <br /></td></tr>
<tr class="separator:a287bc196bb5fa26fb1a8197a1e4c6eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96433773ee0126ce9a25b0970a6ef513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">spacebase</a> (void)</td></tr>
<tr class="memdesc:a96433773ee0126ce9a25b0970a6ef513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark registers that map to a virtual address space.  <a href="#a96433773ee0126ce9a25b0970a6ef513">More...</a><br /></td></tr>
<tr class="separator:a96433773ee0126ce9a25b0970a6ef513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083b7d6637a5883ef8cbd38e7756837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac083b7d6637a5883ef8cbd38e7756837">newSpacebasePtr</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id)</td></tr>
<tr class="memdesc:ac083b7d6637a5883ef8cbd38e7756837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <em>spacebase</em> register for a given address space.  <a href="#ac083b7d6637a5883ef8cbd38e7756837">More...</a><br /></td></tr>
<tr class="separator:ac083b7d6637a5883ef8cbd38e7756837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1266d6947e34a797a45fe9af904674db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1266d6947e34a797a45fe9af904674db">findSpacebaseInput</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id) const </td></tr>
<tr class="separator:a1266d6947e34a797a45fe9af904674db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4a89f4e3da37a4107992689f7b89ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, const <a class="el" href="classAddress.html">Address</a> &amp;rampoint, uintb origval, int4 origsize)</td></tr>
<tr class="memdesc:aaf4a89f4e3da37a4107992689f7b89ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a constant pointer into a <em>ram</em> CPUI_PTRSUB.  <a href="#aaf4a89f4e3da37a4107992689f7b89ff">More...</a><br /></td></tr>
<tr class="separator:aaf4a89f4e3da37a4107992689f7b89ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d874948d856056b0be23a71bca81d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d874948d856056b0be23a71bca81d7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a55d874948d856056b0be23a71bca81d7">getHeritagePass</a> (void) const </td></tr>
<tr class="memdesc:a55d874948d856056b0be23a71bca81d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get overall count of heritage passes. <br /></td></tr>
<tr class="separator:a55d874948d856056b0be23a71bca81d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363bd02cb2f20cf1583951d5429a057b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a363bd02cb2f20cf1583951d5429a057b">numHeritagePasses</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a363bd02cb2f20cf1583951d5429a057b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of heritage passes performed for the given address space.  <a href="#a363bd02cb2f20cf1583951d5429a057b">More...</a><br /></td></tr>
<tr class="separator:a363bd02cb2f20cf1583951d5429a057b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0c8b4dab63367913749e68fbd33789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adc0c8b4dab63367913749e68fbd33789">seenDeadcode</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:adc0c8b4dab63367913749e68fbd33789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that dead Varnodes have been seen in a specific address space.  <a href="#adc0c8b4dab63367913749e68fbd33789">More...</a><br /></td></tr>
<tr class="separator:adc0c8b4dab63367913749e68fbd33789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40aef88ca7a101e4697df5e0ec5f605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac40aef88ca7a101e4697df5e0ec5f605">setDeadCodeDelay</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 delay)</td></tr>
<tr class="memdesc:ac40aef88ca7a101e4697df5e0ec5f605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a delay before removing dead code for a specific address space.  <a href="#ac40aef88ca7a101e4697df5e0ec5f605">More...</a><br /></td></tr>
<tr class="separator:ac40aef88ca7a101e4697df5e0ec5f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab8607ddd18885dfa6732df8d4057e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3ab8607ddd18885dfa6732df8d4057e9">deadRemovalAllowed</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:a3ab8607ddd18885dfa6732df8d4057e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if dead code removal is allowed for a specific address space.  <a href="#a3ab8607ddd18885dfa6732df8d4057e9">More...</a><br /></td></tr>
<tr class="separator:a3ab8607ddd18885dfa6732df8d4057e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba7696040378f0eaa679e684b72bf96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adba7696040378f0eaa679e684b72bf96">deadRemovalAllowedSeen</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:adba7696040378f0eaa679e684b72bf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if dead Varnodes have been removed for a specific address space.  <a href="#adba7696040378f0eaa679e684b72bf96">More...</a><br /></td></tr>
<tr class="separator:adba7696040378f0eaa679e684b72bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803cbb38fe59825f59858a16afa54b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a803cbb38fe59825f59858a16afa54b7d">isHeritaged</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a803cbb38fe59825f59858a16afa54b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has been linked in fully to the syntax tree (SSA)  <a href="#a803cbb38fe59825f59858a16afa54b7d">More...</a><br /></td></tr>
<tr class="separator:a803cbb38fe59825f59858a16afa54b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19adaac5bf849376c6d839e146beccda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19adaac5bf849376c6d839e146beccda"></a>
const list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a19adaac5bf849376c6d839e146beccda">getLoadGuards</a> (void) const </td></tr>
<tr class="memdesc:a19adaac5bf849376c6d839e146beccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of guarded LOADs. <br /></td></tr>
<tr class="separator:a19adaac5bf849376c6d839e146beccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3b53c19280137abd74b840ef35ed0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e3b53c19280137abd74b840ef35ed0a"></a>
const list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2e3b53c19280137abd74b840ef35ed0a">getStoreGuards</a> (void) const </td></tr>
<tr class="memdesc:a2e3b53c19280137abd74b840ef35ed0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of guarded STOREs. <br /></td></tr>
<tr class="separator:a2e3b53c19280137abd74b840ef35ed0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ce81074cb2bebd8218243b7156e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215ce81074cb2bebd8218243b7156e71"></a>
const <a class="el" href="classLoadGuard.html">LoadGuard</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a215ce81074cb2bebd8218243b7156e71">getStoreGuard</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const </td></tr>
<tr class="memdesc:a215ce81074cb2bebd8218243b7156e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> associated with STORE op. <br /></td></tr>
<tr class="separator:a215ce81074cb2bebd8218243b7156e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c3df74171c6e0b98ee5fc93ae5cc36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c3df74171c6e0b98ee5fc93ae5cc36"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad0c3df74171c6e0b98ee5fc93ae5cc36">numCalls</a> (void) const </td></tr>
<tr class="memdesc:ad0c3df74171c6e0b98ee5fc93ae5cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of calls made by <b>this</b> function. <br /></td></tr>
<tr class="separator:ad0c3df74171c6e0b98ee5fc93ae5cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124852dcf002f34a811ec7c78f086f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af124852dcf002f34a811ec7c78f086f2"></a>
<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af124852dcf002f34a811ec7c78f086f2">getCallSpecs</a> (int4 i) const </td></tr>
<tr class="memdesc:af124852dcf002f34a811ec7c78f086f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th call specification. <br /></td></tr>
<tr class="separator:af124852dcf002f34a811ec7c78f086f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5bc4594f2f02f8a67b99469606e60d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f5bc4594f2f02f8a67b99469606e60d"></a>
<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2f5bc4594f2f02f8a67b99469606e60d">getCallSpecs</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const </td></tr>
<tr class="memdesc:a2f5bc4594f2f02f8a67b99469606e60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the call specification associated with a CALL op. <br /></td></tr>
<tr class="separator:a2f5bc4594f2f02f8a67b99469606e60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bea7abaa0ea3ade9d04cb78a521aac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4bea7abaa0ea3ade9d04cb78a521aac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateOpFromSpec</b> (<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *fc)</td></tr>
<tr class="separator:ae4bea7abaa0ea3ade9d04cb78a521aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142938fffbfd5add2b6679a6b9b0d7fa"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a142938fffbfd5add2b6679a6b9b0d7fa">fillinExtrapop</a> (void)</td></tr>
<tr class="memdesc:a142938fffbfd5add2b6679a6b9b0d7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover and return the <em>extrapop</em> for this function.  <a href="#a142938fffbfd5add2b6679a6b9b0d7fa">More...</a><br /></td></tr>
<tr class="separator:a142938fffbfd5add2b6679a6b9b0d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e8acf5b27d1e6886fd45eaf472ec4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8e8acf5b27d1e6886fd45eaf472ec4f"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes</a> (void) const </td></tr>
<tr class="memdesc:ab8e8acf5b27d1e6886fd45eaf472ec4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of Varnodes. <br /></td></tr>
<tr class="separator:ab8e8acf5b27d1e6886fd45eaf472ec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e6704e4c245e076170268d31b47ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;m, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a100e6704e4c245e076170268d31b47ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a100e6704e4c245e076170268d31b47ec">More...</a><br /></td></tr>
<tr class="separator:a100e6704e4c245e076170268d31b47ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af189a9a5b390332c6e87c8faa334cd68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut</a> (int4 s, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:af189a9a5b390332c6e87c8faa334cd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>temporary</em> output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#af189a9a5b390332c6e87c8faa334cd68">More...</a><br /></td></tr>
<tr class="separator:af189a9a5b390332c6e87c8faa334cd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22894e1c7b0f30a5391993924cd96d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;m, <a class="el" href="classDatatype.html">Datatype</a> *ct=(<a class="el" href="classDatatype.html">Datatype</a> *) 0)</td></tr>
<tr class="memdesc:a22894e1c7b0f30a5391993924cd96d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unattached <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object.  <a href="#a22894e1c7b0f30a5391993924cd96d3d">More...</a><br /></td></tr>
<tr class="separator:a22894e1c7b0f30a5391993924cd96d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58542dbcc89f4b84ffc8834b023125b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant</a> (int4 s, uintb constant_val)</td></tr>
<tr class="memdesc:af58542dbcc89f4b84ffc8834b023125b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>constant</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#af58542dbcc89f4b84ffc8834b023125b">More...</a><br /></td></tr>
<tr class="separator:af58542dbcc89f4b84ffc8834b023125b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6888d1606fd8ed6372355995bc7887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0d6888d1606fd8ed6372355995bc7887">newVarnode</a> (int4 s, <a class="el" href="classAddrSpace.html">AddrSpace</a> *base, uintb off)</td></tr>
<tr class="memdesc:a0d6888d1606fd8ed6372355995bc7887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> given an address space and offset.  <a href="#a0d6888d1606fd8ed6372355995bc7887">More...</a><br /></td></tr>
<tr class="separator:a0d6888d1606fd8ed6372355995bc7887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee39fe2d1f2f4702864e78dc06e6bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">newVarnodeIop</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a8ee39fe2d1f2f4702864e78dc06e6bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a8ee39fe2d1f2f4702864e78dc06e6bb8">More...</a><br /></td></tr>
<tr class="separator:a8ee39fe2d1f2f4702864e78dc06e6bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f6fb3e8a36e0e1e633660fc05fdbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">newVarnodeSpace</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:acc9f6fb3e8a36e0e1e633660fc05fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> referring to an address space.  <a href="#acc9f6fb3e8a36e0e1e633660fc05fdbf">More...</a><br /></td></tr>
<tr class="separator:acc9f6fb3e8a36e0e1e633660fc05fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13da637294b7cae252ffc6c9e2116da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">newVarnodeCallSpecs</a> (<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *fc)</td></tr>
<tr class="memdesc:a13da637294b7cae252ffc6c9e2116da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a call specification <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a13da637294b7cae252ffc6c9e2116da2">More...</a><br /></td></tr>
<tr class="separator:a13da637294b7cae252ffc6c9e2116da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f6fd415269577b7bb1943315b8a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">newUnique</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *ct=(<a class="el" href="classDatatype.html">Datatype</a> *) 0)</td></tr>
<tr class="memdesc:a731f6fd415269577b7bb1943315b8a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>temporary</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a731f6fd415269577b7bb1943315b8a76">More...</a><br /></td></tr>
<tr class="separator:a731f6fd415269577b7bb1943315b8a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e80f56ef371a0010a9e67ae8510086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">newCodeRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;m)</td></tr>
<tr class="memdesc:a24e80f56ef371a0010a9e67ae8510086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a code address <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a24e80f56ef371a0010a9e67ae8510086">More...</a><br /></td></tr>
<tr class="separator:a24e80f56ef371a0010a9e67ae8510086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a9880613a03f3aea65acf3dd1343d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">setInputVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a84a9880613a03f3aea65acf3dd1343d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as an input to the function.  <a href="#a84a9880613a03f3aea65acf3dd1343d6">More...</a><br /></td></tr>
<tr class="separator:a84a9880613a03f3aea65acf3dd1343d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c51952540dbda3f11962b22c3064a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>)</td></tr>
<tr class="memdesc:a35c51952540dbda3f11962b22c3064a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust input Varnodes contained in the given range.  <a href="#a35c51952540dbda3f11962b22c3064a3">More...</a><br /></td></tr>
<tr class="separator:a35c51952540dbda3f11962b22c3064a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8657c4c04279316593adc6d2f389be5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8657c4c04279316593adc6d2f389be5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa8657c4c04279316593adc6d2f389be5">deleteVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:aa8657c4c04279316593adc6d2f389be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given varnode. <br /></td></tr>
<tr class="separator:aa8657c4c04279316593adc6d2f389be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e49052fa778084431a6b744cc388cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a17e49052fa778084431a6b744cc388cb">findDisjointCover</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 &amp;sz)</td></tr>
<tr class="memdesc:a17e49052fa778084431a6b744cc388cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find range covering given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and any intersecting Varnodes.  <a href="#a17e49052fa778084431a6b744cc388cb">More...</a><br /></td></tr>
<tr class="separator:a17e49052fa778084431a6b744cc388cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa322f9e049a4142ca02ed0ea37445e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9fa322f9e049a4142ca02ed0ea37445e">findCoveredInput</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc) const </td></tr>
<tr class="memdesc:a9fa322f9e049a4142ca02ed0ea37445e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> covered by the given range.  <a href="#a9fa322f9e049a4142ca02ed0ea37445e">More...</a><br /></td></tr>
<tr class="separator:a9fa322f9e049a4142ca02ed0ea37445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9abb8f1e1cadad50f10f47ceb5c77ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae9abb8f1e1cadad50f10f47ceb5c77ce">findCoveringInput</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc) const </td></tr>
<tr class="memdesc:ae9abb8f1e1cadad50f10f47ceb5c77ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that contains the given range.  <a href="#ae9abb8f1e1cadad50f10f47ceb5c77ce">More...</a><br /></td></tr>
<tr class="separator:ae9abb8f1e1cadad50f10f47ceb5c77ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1d883e2784d22d7762067ab89172ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aac1d883e2784d22d7762067ab89172ce">findVarnodeInput</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc) const </td></tr>
<tr class="memdesc:aac1d883e2784d22d7762067ab89172ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with the given size and storage address.  <a href="#aac1d883e2784d22d7762067ab89172ce">More...</a><br /></td></tr>
<tr class="separator:aac1d883e2784d22d7762067ab89172ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd231188e4e98becd06f0c97c66bd6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0bd231188e4e98becd06f0c97c66bd6d">findVarnodeWritten</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc, const <a class="el" href="classAddress.html">Address</a> &amp;pc, uintm uniq=~((uintm) 0)) const </td></tr>
<tr class="memdesc:a0bd231188e4e98becd06f0c97c66bd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a defined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> via its storage address and its definition address.  <a href="#a0bd231188e4e98becd06f0c97c66bd6d">More...</a><br /></td></tr>
<tr class="separator:a0bd231188e4e98becd06f0c97c66bd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6057f2bc7180ba1232bfd80f5c1f8c21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6057f2bc7180ba1232bfd80f5c1f8c21"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6057f2bc7180ba1232bfd80f5c1f8c21">beginLoc</a> (void) const </td></tr>
<tr class="memdesc:a6057f2bc7180ba1232bfd80f5c1f8c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all Varnodes sorted by storage. <br /></td></tr>
<tr class="separator:a6057f2bc7180ba1232bfd80f5c1f8c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26dd8e3e8bad84b79a9a452bd953d8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26dd8e3e8bad84b79a9a452bd953d8f"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac26dd8e3e8bad84b79a9a452bd953d8f">endLoc</a> (void) const </td></tr>
<tr class="memdesc:ac26dd8e3e8bad84b79a9a452bd953d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all Varnodes sorted by storage. <br /></td></tr>
<tr class="separator:ac26dd8e3e8bad84b79a9a452bd953d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a702bc1e5ace232fc8634faf4bf074"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a702bc1e5ace232fc8634faf4bf074"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac7a702bc1e5ace232fc8634faf4bf074">beginLoc</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spaceid) const </td></tr>
<tr class="memdesc:ac7a702bc1e5ace232fc8634faf4bf074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes stored in a given address space. <br /></td></tr>
<tr class="separator:ac7a702bc1e5ace232fc8634faf4bf074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b18f2b7ef1c4c7396d60cff2954111f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b18f2b7ef1c4c7396d60cff2954111f"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9b18f2b7ef1c4c7396d60cff2954111f">endLoc</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spaceid) const </td></tr>
<tr class="memdesc:a9b18f2b7ef1c4c7396d60cff2954111f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes stored in a given address space. <br /></td></tr>
<tr class="separator:a9b18f2b7ef1c4c7396d60cff2954111f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef26e076eaf553be67af2340716b63c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef26e076eaf553be67af2340716b63c3"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aef26e076eaf553be67af2340716b63c3">beginLoc</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:aef26e076eaf553be67af2340716b63c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes at a storage address. <br /></td></tr>
<tr class="separator:aef26e076eaf553be67af2340716b63c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68305727fe00d329f3ce4c61ba405675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68305727fe00d329f3ce4c61ba405675"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a68305727fe00d329f3ce4c61ba405675">endLoc</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a68305727fe00d329f3ce4c61ba405675"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes at a storage address. <br /></td></tr>
<tr class="separator:a68305727fe00d329f3ce4c61ba405675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b24643446ef6af1297dfddaef27fefe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b24643446ef6af1297dfddaef27fefe"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4b24643446ef6af1297dfddaef27fefe">beginLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a4b24643446ef6af1297dfddaef27fefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes with given storage. <br /></td></tr>
<tr class="separator:a4b24643446ef6af1297dfddaef27fefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58e62cf157447fbd4bd567dc7cbbe3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae58e62cf157447fbd4bd567dc7cbbe3f"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae58e62cf157447fbd4bd567dc7cbbe3f">endLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:ae58e62cf157447fbd4bd567dc7cbbe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes with given storage. <br /></td></tr>
<tr class="separator:ae58e62cf157447fbd4bd567dc7cbbe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f77c395ddd9ea386e4f1398de6c8a83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f77c395ddd9ea386e4f1398de6c8a83"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3f77c395ddd9ea386e4f1398de6c8a83">beginLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, uint4 fl) const </td></tr>
<tr class="memdesc:a3f77c395ddd9ea386e4f1398de6c8a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes matching storage and properties. <br /></td></tr>
<tr class="separator:a3f77c395ddd9ea386e4f1398de6c8a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a002aa8afc75501f93a681803b7e483"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a002aa8afc75501f93a681803b7e483"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2a002aa8afc75501f93a681803b7e483">endLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, uint4 fl) const </td></tr>
<tr class="memdesc:a2a002aa8afc75501f93a681803b7e483"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes matching storage and properties. <br /></td></tr>
<tr class="separator:a2a002aa8afc75501f93a681803b7e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a89d26b36ac016c619a22394f6db09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43a89d26b36ac016c619a22394f6db09"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a43a89d26b36ac016c619a22394f6db09">beginLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, uintm uniq=~((uintm) 0)) const </td></tr>
<tr class="memdesc:a43a89d26b36ac016c619a22394f6db09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes matching storage and definition address. <br /></td></tr>
<tr class="separator:a43a89d26b36ac016c619a22394f6db09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace55159cb67bd79ac54d7edf9f5e30d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace55159cb67bd79ac54d7edf9f5e30d6"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ace55159cb67bd79ac54d7edf9f5e30d6">endLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, uintm uniq=~((uintm) 0)) const </td></tr>
<tr class="memdesc:ace55159cb67bd79ac54d7edf9f5e30d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes matching storage and definition address. <br /></td></tr>
<tr class="separator:ace55159cb67bd79ac54d7edf9f5e30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca1dc303bc6db2a50647b08958dd165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ca1dc303bc6db2a50647b08958dd165"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1ca1dc303bc6db2a50647b08958dd165">beginDef</a> (void) const </td></tr>
<tr class="memdesc:a1ca1dc303bc6db2a50647b08958dd165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all Varnodes sorted by definition address. <br /></td></tr>
<tr class="separator:a1ca1dc303bc6db2a50647b08958dd165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc16f8b732e1ba5ff667e8620298ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bc16f8b732e1ba5ff667e8620298ae7"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8bc16f8b732e1ba5ff667e8620298ae7">endDef</a> (void) const </td></tr>
<tr class="memdesc:a8bc16f8b732e1ba5ff667e8620298ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all Varnodes sorted by definition address. <br /></td></tr>
<tr class="separator:a8bc16f8b732e1ba5ff667e8620298ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbf7173d3074957eac7beb97a5499fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadbf7173d3074957eac7beb97a5499fe"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aadbf7173d3074957eac7beb97a5499fe">beginDef</a> (uint4 fl) const </td></tr>
<tr class="memdesc:aadbf7173d3074957eac7beb97a5499fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes with a given definition property. <br /></td></tr>
<tr class="separator:aadbf7173d3074957eac7beb97a5499fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa443a463d3df8ce91b6f1870181e965e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa443a463d3df8ce91b6f1870181e965e"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa443a463d3df8ce91b6f1870181e965e">endDef</a> (uint4 fl) const </td></tr>
<tr class="memdesc:aa443a463d3df8ce91b6f1870181e965e"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes with a given definition property. <br /></td></tr>
<tr class="separator:aa443a463d3df8ce91b6f1870181e965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70999b44dbf23d810453f0f098df8c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70999b44dbf23d810453f0f098df8c4"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae70999b44dbf23d810453f0f098df8c4">beginDef</a> (uint4 fl, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:ae70999b44dbf23d810453f0f098df8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of (input or free) Varnodes at a given storage address. <br /></td></tr>
<tr class="separator:ae70999b44dbf23d810453f0f098df8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b14d28c52d5d43e741459238dce477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93b14d28c52d5d43e741459238dce477"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a93b14d28c52d5d43e741459238dce477">endDef</a> (uint4 fl, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a93b14d28c52d5d43e741459238dce477"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of (input or free) Varnodes at a given storage address. <br /></td></tr>
<tr class="separator:a93b14d28c52d5d43e741459238dce477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483d190eec54662367b015b59e245328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a483d190eec54662367b015b59e245328">checkForLanedRegister</a> (int4 <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a483d190eec54662367b015b59e245328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for a potential laned register.  <a href="#a483d190eec54662367b015b59e245328">More...</a><br /></td></tr>
<tr class="separator:a483d190eec54662367b015b59e245328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9827e79339e967aa9791dc8c21c14cd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9827e79339e967aa9791dc8c21c14cd4"></a>
map&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a>, const <a class="el" href="classLanedRegister.html">LanedRegister</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9827e79339e967aa9791dc8c21c14cd4">beginLaneAccess</a> (void) const </td></tr>
<tr class="memdesc:a9827e79339e967aa9791dc8c21c14cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator over laned accesses. <br /></td></tr>
<tr class="separator:a9827e79339e967aa9791dc8c21c14cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91e7d6e8a09b390550ddc05eecc43cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91e7d6e8a09b390550ddc05eecc43cd"></a>
map&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a>, const <a class="el" href="classLanedRegister.html">LanedRegister</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae91e7d6e8a09b390550ddc05eecc43cd">endLaneAccess</a> (void) const </td></tr>
<tr class="memdesc:ae91e7d6e8a09b390550ddc05eecc43cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator over laned accesses. <br /></td></tr>
<tr class="separator:ae91e7d6e8a09b390550ddc05eecc43cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833bad69ef5a58c8171d8839fa627960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a833bad69ef5a58c8171d8839fa627960"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap</a> (void)</td></tr>
<tr class="memdesc:a833bad69ef5a58c8171d8839fa627960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear records from the laned access list. <br /></td></tr>
<tr class="separator:a833bad69ef5a58c8171d8839fa627960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769d82ef92ae5cf03ebdf053f48b1871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a769d82ef92ae5cf03ebdf053f48b1871">findHigh</a> (const string &amp;<a class="el" href="classFuncdata.html#abb2c1673cccd101653606f7f5e4a8eb8">name</a>) const </td></tr>
<tr class="memdesc:a769d82ef92ae5cf03ebdf053f48b1871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a high-level variable by name.  <a href="#a769d82ef92ae5cf03ebdf053f48b1871">More...</a><br /></td></tr>
<tr class="separator:a769d82ef92ae5cf03ebdf053f48b1871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6aefa7321e887e3b759de94e4d3d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">mapGlobals</a> (void)</td></tr>
<tr class="memdesc:aed6aefa7321e887e3b759de94e4d3d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure there is a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry for all global Varnodes.  <a href="#aed6aefa7321e887e3b759de94e4d3d4f">More...</a><br /></td></tr>
<tr class="separator:aed6aefa7321e887e3b759de94e4d3d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25609ffe02a0baf12354ca7aba00db14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a25609ffe02a0baf12354ca7aba00db14">checkCallDoubleUse</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *opmatch, const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, const <a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;trial) const </td></tr>
<tr class="memdesc:a25609ffe02a0baf12354ca7aba00db14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for legitimate double use of a parameter trial.  <a href="#a25609ffe02a0baf12354ca7aba00db14">More...</a><br /></td></tr>
<tr class="separator:a25609ffe02a0baf12354ca7aba00db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347de2ecdf4bf99194abb7e11e8eb5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1347de2ecdf4bf99194abb7e11e8eb5d">onlyOpUse</a> (const <a class="el" href="classVarnode.html">Varnode</a> *invn, const <a class="el" href="classPcodeOp.html">PcodeOp</a> *opmatch, const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;trial) const </td></tr>
<tr class="memdesc:a1347de2ecdf4bf99194abb7e11e8eb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> seems to only be used by a CALL.  <a href="#a1347de2ecdf4bf99194abb7e11e8eb5d">More...</a><br /></td></tr>
<tr class="separator:a1347de2ecdf4bf99194abb7e11e8eb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226bd2fae467e85879220d2aaf9b1da1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a226bd2fae467e85879220d2aaf9b1da1">ancestorOpUse</a> (int4 maxlevel, const <a class="el" href="classVarnode.html">Varnode</a> *invn, const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;trial) const </td></tr>
<tr class="memdesc:a226bd2fae467e85879220d2aaf9b1da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given trial <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is likely only used for parameter passing.  <a href="#a226bd2fae467e85879220d2aaf9b1da1">More...</a><br /></td></tr>
<tr class="separator:a226bd2fae467e85879220d2aaf9b1da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca583e76acc0a61bc30bd32461d25aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aca583e76acc0a61bc30bd32461d25aee">syncVarnodesWithSymbols</a> (const <a class="el" href="classScopeLocal.html">ScopeLocal</a> *lm, bool typesyes)</td></tr>
<tr class="memdesc:aca583e76acc0a61bc30bd32461d25aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties based on (new) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> information.  <a href="#aca583e76acc0a61bc30bd32461d25aee">More...</a><br /></td></tr>
<tr class="separator:aca583e76acc0a61bc30bd32461d25aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070edf06c2d300a7d6d1bda21189b477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a070edf06c2d300a7d6d1bda21189b477">transferVarnodeProperties</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classVarnode.html">Varnode</a> *newVn, int4 lsbOffset)</td></tr>
<tr class="memdesc:a070edf06c2d300a7d6d1bda21189b477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy properties from an existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a070edf06c2d300a7d6d1bda21189b477">More...</a><br /></td></tr>
<tr class="separator:a070edf06c2d300a7d6d1bda21189b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47b9524aee42c71c7dbe260a4052485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:af47b9524aee42c71c7dbe260a4052485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with its (constant) value in the load image.  <a href="#af47b9524aee42c71c7dbe260a4052485">More...</a><br /></td></tr>
<tr class="separator:af47b9524aee42c71c7dbe260a4052485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754fe8bd5805e6d9fd8041365e7747eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a754fe8bd5805e6d9fd8041365e7747eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace accesses of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with <em>volatile</em> operations.  <a href="#a754fe8bd5805e6d9fd8041365e7747eb">More...</a><br /></td></tr>
<tr class="separator:a754fe8bd5805e6d9fd8041365e7747eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dc1e061256c4cc55e7afcf5995f435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a41dc1e061256c4cc55e7afcf5995f435">markIndirectOnly</a> (void)</td></tr>
<tr class="memdesc:a41dc1e061256c4cc55e7afcf5995f435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <em>illegal</em> <em>input</em> Varnodes used only in INDIRECTs.  <a href="#a41dc1e061256c4cc55e7afcf5995f435">More...</a><br /></td></tr>
<tr class="separator:a41dc1e061256c4cc55e7afcf5995f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f940f85609d395283520eca3a71f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aab7f940f85609d395283520eca3a71f0">totalReplace</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classVarnode.html">Varnode</a> *newvn)</td></tr>
<tr class="memdesc:aab7f940f85609d395283520eca3a71f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all read references to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#aab7f940f85609d395283520eca3a71f0">More...</a><br /></td></tr>
<tr class="separator:aab7f940f85609d395283520eca3a71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934e1e4246d41a5e28f6fcb56acc937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, uintb val)</td></tr>
<tr class="memdesc:a2934e1e4246d41a5e28f6fcb56acc937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every read reference of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a constant value.  <a href="#a2934e1e4246d41a5e28f6fcb56acc937">More...</a><br /></td></tr>
<tr class="separator:a2934e1e4246d41a5e28f6fcb56acc937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa28789a086c52edd04c41e265818bbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa28789a086c52edd04c41e265818bbb"></a>
<a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aaa28789a086c52edd04c41e265818bbb">getScopeLocal</a> (void)</td></tr>
<tr class="memdesc:aaa28789a086c52edd04c41e265818bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local function scope. <br /></td></tr>
<tr class="separator:aaa28789a086c52edd04c41e265818bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300a2126977ad8eea887cc21ca03cb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1300a2126977ad8eea887cc21ca03cb6"></a>
const <a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1300a2126977ad8eea887cc21ca03cb6">getScopeLocal</a> (void) const </td></tr>
<tr class="memdesc:a1300a2126977ad8eea887cc21ca03cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local function scope. <br /></td></tr>
<tr class="separator:a1300a2126977ad8eea887cc21ca03cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1961c6d9c58e9a0a20f74c6e49853f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1961c6d9c58e9a0a20f74c6e49853f"></a>
<a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1b1961c6d9c58e9a0a20f74c6e49853f">getFuncProto</a> (void)</td></tr>
<tr class="memdesc:a1b1961c6d9c58e9a0a20f74c6e49853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function's prototype object. <br /></td></tr>
<tr class="separator:a1b1961c6d9c58e9a0a20f74c6e49853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a7d002d5a170507285c0556f45a95c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a7d002d5a170507285c0556f45a95c"></a>
const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae9a7d002d5a170507285c0556f45a95c">getFuncProto</a> (void) const </td></tr>
<tr class="memdesc:ae9a7d002d5a170507285c0556f45a95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function's prototype object. <br /></td></tr>
<tr class="separator:ae9a7d002d5a170507285c0556f45a95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae454fbd3566fbd43103dcabdf2681fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae454fbd3566fbd43103dcabdf2681fd8">initActiveOutput</a> (void)</td></tr>
<tr class="separator:ae454fbd3566fbd43103dcabdf2681fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f29c20e2a01d0cbf600b613e929e88c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f29c20e2a01d0cbf600b613e929e88c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8f29c20e2a01d0cbf600b613e929e88c">clearActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a8f29c20e2a01d0cbf600b613e929e88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any analysis of the function's <em>return</em> prototype. <br /></td></tr>
<tr class="separator:a8f29c20e2a01d0cbf600b613e929e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fe824e6b57d5d4d861864f60c6aa5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09fe824e6b57d5d4d861864f60c6aa5c"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a09fe824e6b57d5d4d861864f60c6aa5c">getActiveOutput</a> (void) const </td></tr>
<tr class="memdesc:a09fe824e6b57d5d4d861864f60c6aa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>return</em> prototype recovery object. <br /></td></tr>
<tr class="separator:a09fe824e6b57d5d4d861864f60c6aa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadeeb585ee8728c427fd6914b8bb7b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afadeeb585ee8728c427fd6914b8bb7b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afadeeb585ee8728c427fd6914b8bb7b1">setHighLevel</a> (void)</td></tr>
<tr class="memdesc:afadeeb585ee8728c427fd6914b8bb7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> objects for all Varnodes. <br /></td></tr>
<tr class="separator:afadeeb585ee8728c427fd6914b8bb7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4096b0e76e9015f9aa61fa56cb85d79c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4096b0e76e9015f9aa61fa56cb85d79c">clearDeadVarnodes</a> (void)</td></tr>
<tr class="memdesc:a4096b0e76e9015f9aa61fa56cb85d79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any dead Varnodes.  <a href="#a4096b0e76e9015f9aa61fa56cb85d79c">More...</a><br /></td></tr>
<tr class="separator:a4096b0e76e9015f9aa61fa56cb85d79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b338d2b2d1a72db73369e8631125ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5b338d2b2d1a72db73369e8631125ffd">calcNZMask</a> (void)</td></tr>
<tr class="memdesc:a5b338d2b2d1a72db73369e8631125ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <em>non-zero</em> masks for all Varnodes.  <a href="#a5b338d2b2d1a72db73369e8631125ffd">More...</a><br /></td></tr>
<tr class="separator:a5b338d2b2d1a72db73369e8631125ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb872f99bf69e4101034da41cdebd84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbb872f99bf69e4101034da41cdebd84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps</a> (void)</td></tr>
<tr class="memdesc:adbb872f99bf69e4101034da41cdebd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any dead PcodeOps. <br /></td></tr>
<tr class="separator:adbb872f99bf69e4101034da41cdebd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acc07e00146316532a3806cd19815bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5acc07e00146316532a3806cd19815bb">clearSymbolLinks</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:a5acc07e00146316532a3806cd19815bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Symbols attached to Varnodes in the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#a5acc07e00146316532a3806cd19815bb">More...</a><br /></td></tr>
<tr class="separator:a5acc07e00146316532a3806cd19815bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6145d643e13a072975e34255a06f4e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6145d643e13a072975e34255a06f4e84">remapVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a6145d643e13a072975e34255a06f4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a static mapping.  <a href="#a6145d643e13a072975e34255a06f4e84">More...</a><br /></td></tr>
<tr class="separator:a6145d643e13a072975e34255a06f4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cbb6375e48cddaedf5e55e40119c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a73cbb6375e48cddaedf5e55e40119c84">remapDynamicVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, uint8 hash)</td></tr>
<tr class="memdesc:a73cbb6375e48cddaedf5e55e40119c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a new dynamic mapping.  <a href="#a73cbb6375e48cddaedf5e55e40119c84">More...</a><br /></td></tr>
<tr class="separator:a73cbb6375e48cddaedf5e55e40119c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3bc5ac9e2c09eda544db34b8f5879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">linkSymbol</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:afbb3bc5ac9e2c09eda544db34b8f5879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find or create <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#afbb3bc5ac9e2c09eda544db34b8f5879">More...</a><br /></td></tr>
<tr class="separator:afbb3bc5ac9e2c09eda544db34b8f5879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736351e8eb6c044fe00deb0cf7e6b5c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a736351e8eb6c044fe00deb0cf7e6b5c5">linkSymbolReference</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a736351e8eb6c044fe00deb0cf7e6b5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover and attach <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a constant reference.  <a href="#a736351e8eb6c044fe00deb0cf7e6b5c5">More...</a><br /></td></tr>
<tr class="separator:a736351e8eb6c044fe00deb0cf7e6b5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c3a8ce85301740b1bda1cb5e0b4eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae4c3a8ce85301740b1bda1cb5e0b4eb4">findLinkedVarnode</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry) const </td></tr>
<tr class="memdesc:ae4c3a8ce85301740b1bda1cb5e0b4eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> matching the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> mapping.  <a href="#ae4c3a8ce85301740b1bda1cb5e0b4eb4">More...</a><br /></td></tr>
<tr class="separator:ae4c3a8ce85301740b1bda1cb5e0b4eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa3b8e623f20629b247500809b8e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7eaa3b8e623f20629b247500809b8e98">findLinkedVarnodes</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;res) const </td></tr>
<tr class="memdesc:a7eaa3b8e623f20629b247500809b8e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Varnodes that map to the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>.  <a href="#a7eaa3b8e623f20629b247500809b8e98">More...</a><br /></td></tr>
<tr class="separator:a7eaa3b8e623f20629b247500809b8e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15db3d569027578de69c065fc607c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa15db3d569027578de69c065fc607c63">buildDynamicSymbol</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:aa15db3d569027578de69c065fc607c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <em>dynamic</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#aa15db3d569027578de69c065fc607c63">More...</a><br /></td></tr>
<tr class="separator:aa15db3d569027578de69c065fc607c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeee32fc648486d26cd17ebb37bb118f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adeee32fc648486d26cd17ebb37bb118f">attemptDynamicMapping</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, <a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;dhash)</td></tr>
<tr class="memdesc:adeee32fc648486d26cd17ebb37bb118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map properties of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#adeee32fc648486d26cd17ebb37bb118f">More...</a><br /></td></tr>
<tr class="separator:adeee32fc648486d26cd17ebb37bb118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dddb637a6e322632f9a4bb10c5c36e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a69dddb637a6e322632f9a4bb10c5c36e">attemptDynamicMappingLate</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, <a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;dhash)</td></tr>
<tr class="memdesc:a69dddb637a6e322632f9a4bb10c5c36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the name of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a69dddb637a6e322632f9a4bb10c5c36e">More...</a><br /></td></tr>
<tr class="separator:a69dddb637a6e322632f9a4bb10c5c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7716a2ee4e91b0b91ac0487264673ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7716a2ee4e91b0b91ac0487264673ca"></a>
<a class="el" href="classMerge.html">Merge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge</a> (void)</td></tr>
<tr class="memdesc:ad7716a2ee4e91b0b91ac0487264673ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> object for <b>this</b> function. <br /></td></tr>
<tr class="separator:ad7716a2ee4e91b0b91ac0487264673ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1e9831bb4b1c65df6950ae1f15e0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp</a> (int4 inputs, const <a class="el" href="classAddress.html">Address</a> &amp;pc)</td></tr>
<tr class="separator:a1b1e9831bb4b1c65df6950ae1f15e0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d122aa09d739e59a5107338f8ecd8ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0d122aa09d739e59a5107338f8ecd8ab">newOp</a> (int4 inputs, const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;sq)</td></tr>
<tr class="memdesc:a0d122aa09d739e59a5107338f8ecd8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>.  <a href="#a0d122aa09d739e59a5107338f8ecd8ab">More...</a><br /></td></tr>
<tr class="separator:a0d122aa09d739e59a5107338f8ecd8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1126d213d88120c9e55b5779d746859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *follow, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, <a class="el" href="classVarnode.html">Varnode</a> *in1, <a class="el" href="classVarnode.html">Varnode</a> *in2, <a class="el" href="classVarnode.html">Varnode</a> *in3=(<a class="el" href="classVarnode.html">Varnode</a> *) 0)</td></tr>
<tr class="memdesc:ae1126d213d88120c9e55b5779d746859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with sequence number.  <a href="#ae1126d213d88120c9e55b5779d746859">More...</a><br /></td></tr>
<tr class="separator:ae1126d213d88120c9e55b5779d746859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8e9506c5b37fce86d165974a4cafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;seq)</td></tr>
<tr class="separator:a1da8e9506c5b37fce86d165974a4cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77670b6440a935ce96b43b4f60c3730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac77670b6440a935ce96b43b4f60c3730">getFirstReturnOp</a> (void) const </td></tr>
<tr class="memdesc:ac77670b6440a935ce96b43b4f60c3730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> into <b>this</b> function.  <a href="#ac77670b6440a935ce96b43b4f60c3730">More...</a><br /></td></tr>
<tr class="separator:ac77670b6440a935ce96b43b4f60c3730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008246c0350878f3d312b174a227b676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indeffect, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, uint4 extraFlags)</td></tr>
<tr class="memdesc:a008246c0350878f3d312b174a227b676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a representative CPUI_RETURN op for <b>this</b> function.  <a href="#a008246c0350878f3d312b174a227b676">More...</a><br /></td></tr>
<tr class="separator:a008246c0350878f3d312b174a227b676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1098b768d9a176cf59e4f4c9e27cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indeffect, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, bool possibleout)</td></tr>
<tr class="memdesc:add1098b768d9a176cf59e4f4c9e27cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a CPUI_INDIRECT op that <em>indirectly</em> <em>creates</em> a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#add1098b768d9a176cf59e4f4c9e27cb5">More...</a><br /></td></tr>
<tr class="separator:add1098b768d9a176cf59e4f4c9e27cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af6702bb2cf33ecc7dee059b6e3eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a90af6702bb2cf33ecc7dee059b6e3eb9">markIndirectCreation</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indop, bool possibleOutput)</td></tr>
<tr class="memdesc:a90af6702bb2cf33ecc7dee059b6e3eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert CPUI_INDIRECT into an <em>indirect</em> <em>creation</em>.  <a href="#a90af6702bb2cf33ecc7dee059b6e3eb9">More...</a><br /></td></tr>
<tr class="separator:a90af6702bb2cf33ecc7dee059b6e3eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910ebb4d08eba9ee2f68965b6ef0898c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a910ebb4d08eba9ee2f68965b6ef0898c"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp</a> (const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;sq)</td></tr>
<tr class="memdesc:a910ebb4d08eba9ee2f68965b6ef0898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with given sequence number. <br /></td></tr>
<tr class="separator:a910ebb4d08eba9ee2f68965b6ef0898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd86e17a47020d06ac8dfd3bb732fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *follow)</td></tr>
<tr class="memdesc:a9dd86e17a47020d06ac8dfd3bb732fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> before a specific op.  <a href="#a9dd86e17a47020d06ac8dfd3bb732fe5">More...</a><br /></td></tr>
<tr class="separator:a9dd86e17a47020d06ac8dfd3bb732fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3320ad92e11a48a06e21b8a55395a56b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *prev)</td></tr>
<tr class="memdesc:a3320ad92e11a48a06e21b8a55395a56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> after a specific op.  <a href="#a3320ad92e11a48a06e21b8a55395a56b">More...</a><br /></td></tr>
<tr class="separator:a3320ad92e11a48a06e21b8a55395a56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6341eb8ca8a8004f1c77a8e8147a286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae6341eb8ca8a8004f1c77a8e8147a286">opInsertBegin</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl)</td></tr>
<tr class="memdesc:ae6341eb8ca8a8004f1c77a8e8147a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the beginning of a basic block.  <a href="#ae6341eb8ca8a8004f1c77a8e8147a286">More...</a><br /></td></tr>
<tr class="separator:ae6341eb8ca8a8004f1c77a8e8147a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad544a6136ff019bbd18c45043e9b6900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad544a6136ff019bbd18c45043e9b6900">opInsertEnd</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl)</td></tr>
<tr class="memdesc:ad544a6136ff019bbd18c45043e9b6900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the end of a basic block.  <a href="#ad544a6136ff019bbd18c45043e9b6900">More...</a><br /></td></tr>
<tr class="separator:ad544a6136ff019bbd18c45043e9b6900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cda5e2de1725ebf3fb885e375ea1a9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cda5e2de1725ebf3fb885e375ea1a9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9cda5e2de1725ebf3fb885e375ea1a9d">opDeadInsertAfter</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *prev)</td></tr>
<tr class="memdesc:a9cda5e2de1725ebf3fb885e375ea1a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moved given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to specified point in the <em>dead</em> list. <br /></td></tr>
<tr class="separator:a9cda5e2de1725ebf3fb885e375ea1a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d243f1e771d6e220330feb534a3fee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99d243f1e771d6e220330feb534a3fee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage</a> (void)</td></tr>
<tr class="memdesc:a99d243f1e771d6e220330feb534a3fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an entire heritage pass linking <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> reads to writes. <br /></td></tr>
<tr class="separator:a99d243f1e771d6e220330feb534a3fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dbf52668db4a1923537e2128719181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc)</td></tr>
<tr class="memdesc:ad9dbf52668db4a1923537e2128719181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the op-code for a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ad9dbf52668db4a1923537e2128719181">More...</a><br /></td></tr>
<tr class="separator:ad9dbf52668db4a1923537e2128719181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbfab2362e4d4945c3feb7d3f2c42f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#acdbfab2362e4d4945c3feb7d3f2c42f2">opMarkHalt</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, uint4 flag)</td></tr>
<tr class="memdesc:acdbfab2362e4d4945c3feb7d3f2c42f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark given CPUI_RETURN op as a <em>special</em> halt.  <a href="#acdbfab2362e4d4945c3feb7d3f2c42f2">More...</a><br /></td></tr>
<tr class="separator:acdbfab2362e4d4945c3feb7d3f2c42f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bd3523c574c5b303728ef4d880ec3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:ab2bd3523c574c5b303728ef4d880ec3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ab2bd3523c574c5b303728ef4d880ec3a">More...</a><br /></td></tr>
<tr class="separator:ab2bd3523c574c5b303728ef4d880ec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91b54da6501e12d4ad1e81ab5d0e5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab91b54da6501e12d4ad1e81ab5d0e5c4">opUnsetOutput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:ab91b54da6501e12d4ad1e81ab5d0e5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ab91b54da6501e12d4ad1e81ab5d0e5c4">More...</a><br /></td></tr>
<tr class="separator:ab91b54da6501e12d4ad1e81ab5d0e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa079e2bd26e92671be79601535236a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *vn, int4 slot)</td></tr>
<tr class="memdesc:aa079e2bd26e92671be79601535236a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific input operand for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#aa079e2bd26e92671be79601535236a63">More...</a><br /></td></tr>
<tr class="separator:aa079e2bd26e92671be79601535236a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae30fdfbe33ecfa6668b5579ae3e82a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1ae30fdfbe33ecfa6668b5579ae3e82a">opSwapInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot1, int4 slot2)</td></tr>
<tr class="memdesc:a1ae30fdfbe33ecfa6668b5579ae3e82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two input operands in the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a1ae30fdfbe33ecfa6668b5579ae3e82a">More...</a><br /></td></tr>
<tr class="separator:a1ae30fdfbe33ecfa6668b5579ae3e82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f821f09d862b3c908d2bce7530b90a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot)</td></tr>
<tr class="memdesc:a16f821f09d862b3c908d2bce7530b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an input operand slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a16f821f09d862b3c908d2bce7530b90a">More...</a><br /></td></tr>
<tr class="separator:a16f821f09d862b3c908d2bce7530b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b77ee6442d79ae754d5dcf0b5318fca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6b77ee6442d79ae754d5dcf0b5318fca">opInsert</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::iterator iter)</td></tr>
<tr class="memdesc:a6b77ee6442d79ae754d5dcf0b5318fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at specific point in a basic block.  <a href="#a6b77ee6442d79ae754d5dcf0b5318fca">More...</a><br /></td></tr>
<tr class="separator:a6b77ee6442d79ae754d5dcf0b5318fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0cf87976170d62df42411ffe1e10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aacf0cf87976170d62df42411ffe1e10a">opUninsert</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:aacf0cf87976170d62df42411ffe1e10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> from its basic block.  <a href="#aacf0cf87976170d62df42411ffe1e10a">More...</a><br /></td></tr>
<tr class="separator:aacf0cf87976170d62df42411ffe1e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495ebac694bc98d041e29ce05eece6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">opUnlink</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a495ebac694bc98d041e29ce05eece6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset inputs/output and remove given PcodeOP from its basic block.  <a href="#a495ebac694bc98d041e29ce05eece6f9">More...</a><br /></td></tr>
<tr class="separator:a495ebac694bc98d041e29ce05eece6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6976625d7b40efca0bc9941cb199ee44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a6976625d7b40efca0bc9941cb199ee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and destroy its <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> operands.  <a href="#a6976625d7b40efca0bc9941cb199ee44">More...</a><br /></td></tr>
<tr class="separator:a6976625d7b40efca0bc9941cb199ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef2a6be0e9c641f72bf4e87020ddf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aeef2a6be0e9c641f72bf4e87020ddf37">opDestroyRaw</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:aeef2a6be0e9c641f72bf4e87020ddf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <em>raw</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#aeef2a6be0e9c641f72bf4e87020ddf37">More...</a><br /></td></tr>
<tr class="separator:aeef2a6be0e9c641f72bf4e87020ddf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa062c200c86923b0f1032d4ab563e716"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa062c200c86923b0f1032d4ab563e716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa062c200c86923b0f1032d4ab563e716">opDeadAndGone</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:aa062c200c86923b0f1032d4ab563e716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources for the given <em>dead</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. <br /></td></tr>
<tr class="separator:aa062c200c86923b0f1032d4ab563e716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcad3bfd56955103a031fa6d0e78acec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">opSetAllInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;vvec)</td></tr>
<tr class="memdesc:adcad3bfd56955103a031fa6d0e78acec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all input Varnodes for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> simultaneously.  <a href="#adcad3bfd56955103a031fa6d0e78acec">More...</a><br /></td></tr>
<tr class="separator:adcad3bfd56955103a031fa6d0e78acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84937c2241ea5679280223cc0ec8b202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot)</td></tr>
<tr class="memdesc:a84937c2241ea5679280223cc0ec8b202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specific input slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a84937c2241ea5679280223cc0ec8b202">More...</a><br /></td></tr>
<tr class="separator:a84937c2241ea5679280223cc0ec8b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e641f5ee6f2ebf4aa708e21f2b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab34e641f5ee6f2ebf4aa708e21f2b24c">opInsertInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *vn, int4 slot)</td></tr>
<tr class="memdesc:ab34e641f5ee6f2ebf4aa708e21f2b24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into the operand list for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ab34e641f5ee6f2ebf4aa708e21f2b24c">More...</a><br /></td></tr>
<tr class="separator:ab34e641f5ee6f2ebf4aa708e21f2b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748e9e70a815362925e711abad0347d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748e9e70a815362925e711abad0347d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a748e9e70a815362925e711abad0347d7">opMarkStartBasic</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a748e9e70a815362925e711abad0347d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as starting a basic block. <br /></td></tr>
<tr class="separator:a748e9e70a815362925e711abad0347d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ad72e4b98e066287d881a6c08840a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71ad72e4b98e066287d881a6c08840a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a71ad72e4b98e066287d881a6c08840a4">opMarkStartInstruction</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a71ad72e4b98e066287d881a6c08840a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as starting its instruction. <br /></td></tr>
<tr class="separator:a71ad72e4b98e066287d881a6c08840a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4bb58638be599fe4f356ab934b66a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f4bb58638be599fe4f356ab934b66a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4f4bb58638be599fe4f356ab934b66a6">opMarkNonPrinting</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a4f4bb58638be599fe4f356ab934b66a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as not being printed. <br /></td></tr>
<tr class="separator:a4f4bb58638be599fe4f356ab934b66a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c5af4460fc722cc49f9f499fc91c1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8c5af4460fc722cc49f9f499fc91c1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac8c5af4460fc722cc49f9f499fc91c1b">opMarkSpecialPrint</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:ac8c5af4460fc722cc49f9f499fc91c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as needing special printing. <br /></td></tr>
<tr class="separator:ac8c5af4460fc722cc49f9f499fc91c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcf40584363a47d2fd79720a02f8917"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affcf40584363a47d2fd79720a02f8917"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#affcf40584363a47d2fd79720a02f8917">opMarkNoCollapse</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:affcf40584363a47d2fd79720a02f8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as not collapsible. <br /></td></tr>
<tr class="separator:affcf40584363a47d2fd79720a02f8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df9afc093cf0c227bd79e1c39a7ba02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1df9afc093cf0c227bd79e1c39a7ba02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1df9afc093cf0c227bd79e1c39a7ba02">opMarkCpoolTransformed</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a1df9afc093cf0c227bd79e1c39a7ba02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark cpool record was visited. <br /></td></tr>
<tr class="separator:a1df9afc093cf0c227bd79e1c39a7ba02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0bb4b937364f649d5d1e4e84d9a601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0bb4b937364f649d5d1e4e84d9a601"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0c0bb4b937364f649d5d1e4e84d9a601">opMarkCalculatedBool</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a0c0bb4b937364f649d5d1e4e84d9a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as having boolean output. <br /></td></tr>
<tr class="separator:a0c0bb4b937364f649d5d1e4e84d9a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a94741d3a9e68d25cc09299d0b90656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a94741d3a9e68d25cc09299d0b90656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7a94741d3a9e68d25cc09299d0b90656">opMarkSpacebasePtr</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a7a94741d3a9e68d25cc09299d0b90656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as LOAD/STORE from spacebase ptr. <br /></td></tr>
<tr class="separator:a7a94741d3a9e68d25cc09299d0b90656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5cf4952800d9b8072266b67d320dcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a5cf4952800d9b8072266b67d320dcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6a5cf4952800d9b8072266b67d320dcc">opClearSpacebasePtr</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a6a5cf4952800d9b8072266b67d320dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as using spacebase ptr. <br /></td></tr>
<tr class="separator:a6a5cf4952800d9b8072266b67d320dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635b6d2cf1ce4fdc7aa5aac967072f2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a635b6d2cf1ce4fdc7aa5aac967072f2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a635b6d2cf1ce4fdc7aa5aac967072f2e">opFlipCondition</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a635b6d2cf1ce4fdc7aa5aac967072f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip output condition of given CBRANCH. <br /></td></tr>
<tr class="separator:a635b6d2cf1ce4fdc7aa5aac967072f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cb6cda676ceb9a33f8e6eef9e1e962"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65cb6cda676ceb9a33f8e6eef9e1e962"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a65cb6cda676ceb9a33f8e6eef9e1e962">target</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a65cb6cda676ceb9a33f8e6eef9e1e962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> by an instruction <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. <br /></td></tr>
<tr class="separator:a65cb6cda676ceb9a33f8e6eef9e1e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e8837c811e309578d2828486bcafb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb off, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *stackptr, bool insertafter)</td></tr>
<tr class="memdesc:a65e8837c811e309578d2828486bcafb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an INT_ADD <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> calculating an offset to the <em>spacebase</em> register.  <a href="#a65e8837c811e309578d2828486bcafb5">More...</a><br /></td></tr>
<tr class="separator:a65e8837c811e309578d2828486bcafb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b36505bab6f7c5676157288e65d5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb off, uint4 sz, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *stackptr, bool insertafter)</td></tr>
<tr class="memdesc:a37b36505bab6f7c5676157288e65d5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LOAD expression at an offset relative to a <em>spacebase</em> register for a given address space.  <a href="#a37b36505bab6f7c5676157288e65d5c6">More...</a><br /></td></tr>
<tr class="separator:a37b36505bab6f7c5676157288e65d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4582ad34b4e7c851d92db8544999eaf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb off, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, bool insertafter)</td></tr>
<tr class="memdesc:a4582ad34b4e7c851d92db8544999eaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a STORE expression at an offset relative to a <em>spacebase</em> register for a given address space.  <a href="#a4582ad34b4e7c851d92db8544999eaf3">More...</a><br /></td></tr>
<tr class="separator:a4582ad34b4e7c851d92db8544999eaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d3baa2516f448e7ab5f9a8151b572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, bool finalize)</td></tr>
<tr class="memdesc:ad74d3baa2516f448e7ab5f9a8151b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a CPUI_PTRADD back into a CPUI_INT_ADD.  <a href="#ad74d3baa2516f448e7ab5f9a8151b572">More...</a><br /></td></tr>
<tr class="separator:ad74d3baa2516f448e7ab5f9a8151b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7638ebccbc3caf1d196675ca882881da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7638ebccbc3caf1d196675ca882881da"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7638ebccbc3caf1d196675ca882881da">beginOp</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc) const </td></tr>
<tr class="memdesc:a7638ebccbc3caf1d196675ca882881da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects with the given op-code. <br /></td></tr>
<tr class="separator:a7638ebccbc3caf1d196675ca882881da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229d522e177d1bb32453d8a060c16cb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229d522e177d1bb32453d8a060c16cb9"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a229d522e177d1bb32453d8a060c16cb9">endOp</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc) const </td></tr>
<tr class="memdesc:a229d522e177d1bb32453d8a060c16cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects with the given op-code. <br /></td></tr>
<tr class="separator:a229d522e177d1bb32453d8a060c16cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bf301c24b9f80d75b6aeab69a544e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35bf301c24b9f80d75b6aeab69a544e6"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a35bf301c24b9f80d75b6aeab69a544e6">beginOpAlive</a> (void) const </td></tr>
<tr class="memdesc:a35bf301c24b9f80d75b6aeab69a544e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>alive</em> list. <br /></td></tr>
<tr class="separator:a35bf301c24b9f80d75b6aeab69a544e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc313c774c6eefd3a5925cc061e0e4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bc313c774c6eefd3a5925cc061e0e4e"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7bc313c774c6eefd3a5925cc061e0e4e">endOpAlive</a> (void) const </td></tr>
<tr class="memdesc:a7bc313c774c6eefd3a5925cc061e0e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>alive</em> list. <br /></td></tr>
<tr class="separator:a7bc313c774c6eefd3a5925cc061e0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f621455bf118a4bf871100d68e5732b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f621455bf118a4bf871100d68e5732b"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3f621455bf118a4bf871100d68e5732b">beginOpDead</a> (void) const </td></tr>
<tr class="memdesc:a3f621455bf118a4bf871100d68e5732b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>dead</em> list. <br /></td></tr>
<tr class="separator:a3f621455bf118a4bf871100d68e5732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855de7857d740ad0e220eb117c403695"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a855de7857d740ad0e220eb117c403695"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a855de7857d740ad0e220eb117c403695">endOpDead</a> (void) const </td></tr>
<tr class="memdesc:a855de7857d740ad0e220eb117c403695"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>dead</em> list. <br /></td></tr>
<tr class="separator:a855de7857d740ad0e220eb117c403695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3847d22ce4a97c922b527a8d2a126aef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3847d22ce4a97c922b527a8d2a126aef"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3847d22ce4a97c922b527a8d2a126aef">beginOpAll</a> (void) const </td></tr>
<tr class="memdesc:a3847d22ce4a97c922b527a8d2a126aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects sorted by sequence number. <br /></td></tr>
<tr class="separator:a3847d22ce4a97c922b527a8d2a126aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d9eac9ff6df86ef0c471a8a94def9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d9eac9ff6df86ef0c471a8a94def9e"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa7d9eac9ff6df86ef0c471a8a94def9e">endOpAll</a> (void) const </td></tr>
<tr class="memdesc:aa7d9eac9ff6df86ef0c471a8a94def9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects sorted by sequence number. <br /></td></tr>
<tr class="separator:aa7d9eac9ff6df86ef0c471a8a94def9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582df48de9fc60ea067548c1c91e90ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a582df48de9fc60ea067548c1c91e90ff"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a582df48de9fc60ea067548c1c91e90ff">beginOp</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a582df48de9fc60ea067548c1c91e90ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects attached to a specific <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. <br /></td></tr>
<tr class="separator:a582df48de9fc60ea067548c1c91e90ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6bcc6efff0daefdcc48ee11e743121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add6bcc6efff0daefdcc48ee11e743121"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#add6bcc6efff0daefdcc48ee11e743121">endOp</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:add6bcc6efff0daefdcc48ee11e743121"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects attached to a specific <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. <br /></td></tr>
<tr class="separator:add6bcc6efff0daefdcc48ee11e743121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512f5823b1a33e9430584067d77a52c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a512f5823b1a33e9430584067d77a52c5">linkJumpTable</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a512f5823b1a33e9430584067d77a52c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link jump-table with a given BRANCHIND.  <a href="#a512f5823b1a33e9430584067d77a52c5">More...</a><br /></td></tr>
<tr class="separator:a512f5823b1a33e9430584067d77a52c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925018ca0152e89fd099aba761bb2b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a925018ca0152e89fd099aba761bb2b9d">findJumpTable</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const </td></tr>
<tr class="memdesc:a925018ca0152e89fd099aba761bb2b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a jump-table associated with a given BRANCHIND.  <a href="#a925018ca0152e89fd099aba761bb2b9d">More...</a><br /></td></tr>
<tr class="separator:a925018ca0152e89fd099aba761bb2b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337a544e372368eb5c41b1bb5e410932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a337a544e372368eb5c41b1bb5e410932">installJumpTable</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a337a544e372368eb5c41b1bb5e410932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a new jump-table for the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>.  <a href="#a337a544e372368eb5c41b1bb5e410932">More...</a><br /></td></tr>
<tr class="separator:a337a544e372368eb5c41b1bb5e410932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d58c33cdc77c663fceb7de1f6aadeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a38d58c33cdc77c663fceb7de1f6aadeb">recoverJumpTable</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classFlowInfo.html">FlowInfo</a> *flow, int4 &amp;failuremode)</td></tr>
<tr class="memdesc:a38d58c33cdc77c663fceb7de1f6aadeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover destinations for a BRANCHIND by analyzing nearby data and control-flow.  <a href="#a38d58c33cdc77c663fceb7de1f6aadeb">More...</a><br /></td></tr>
<tr class="separator:a38d58c33cdc77c663fceb7de1f6aadeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b39c812c2b21015f1fc5f73c7015b31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b39c812c2b21015f1fc5f73c7015b31"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6b39c812c2b21015f1fc5f73c7015b31">numJumpTables</a> (void) const </td></tr>
<tr class="memdesc:a6b39c812c2b21015f1fc5f73c7015b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of jump-tables for <b>this</b> function. <br /></td></tr>
<tr class="separator:a6b39c812c2b21015f1fc5f73c7015b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475047d15d64d653871facd75f7244ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a475047d15d64d653871facd75f7244ed"></a>
<a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a475047d15d64d653871facd75f7244ed">getJumpTable</a> (int4 i)</td></tr>
<tr class="memdesc:a475047d15d64d653871facd75f7244ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th jump-table. <br /></td></tr>
<tr class="separator:a475047d15d64d653871facd75f7244ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e75df713649c7bba52b17b1b84bbcf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2e75df713649c7bba52b17b1b84bbcf6">removeJumpTable</a> (<a class="el" href="classJumpTable.html">JumpTable</a> *jt)</td></tr>
<tr class="memdesc:a2e75df713649c7bba52b17b1b84bbcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove/delete the given jump-table.  <a href="#a2e75df713649c7bba52b17b1b84bbcf6">More...</a><br /></td></tr>
<tr class="separator:a2e75df713649c7bba52b17b1b84bbcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8010b1f0044fd3a03f8f717279ffc0b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8010b1f0044fd3a03f8f717279ffc0b1"></a>
<a class="el" href="classBlockGraph.html">BlockGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8010b1f0044fd3a03f8f717279ffc0b1">getStructure</a> (void)</td></tr>
<tr class="memdesc:a8010b1f0044fd3a03f8f717279ffc0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current control-flow structuring hierarchy. <br /></td></tr>
<tr class="separator:a8010b1f0044fd3a03f8f717279ffc0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7348f2380ed95ba45e5a0b7630a5f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc7348f2380ed95ba45e5a0b7630a5f9"></a>
const <a class="el" href="classBlockGraph.html">BlockGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#abc7348f2380ed95ba45e5a0b7630a5f9">getStructure</a> (void) const </td></tr>
<tr class="memdesc:abc7348f2380ed95ba45e5a0b7630a5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current control-flow structuring hierarchy. <br /></td></tr>
<tr class="separator:abc7348f2380ed95ba45e5a0b7630a5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7cb4ba7c665f0575d7f314ad329364"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb7cb4ba7c665f0575d7f314ad329364"></a>
const <a class="el" href="classBlockGraph.html">BlockGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afb7cb4ba7c665f0575d7f314ad329364">getBasicBlocks</a> (void) const </td></tr>
<tr class="memdesc:afb7cb4ba7c665f0575d7f314ad329364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basic blocks container. <br /></td></tr>
<tr class="separator:afb7cb4ba7c665f0575d7f314ad329364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15885a8369e2c43c8c7883a4fabd533e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, const <a class="el" href="classAddress.html">Address</a> &amp;beg, const <a class="el" href="classAddress.html">Address</a> &amp;end)</td></tr>
<tr class="memdesc:a15885a8369e2c43c8c7883a4fabd533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial ownership range for the given basic block.  <a href="#a15885a8369e2c43c8c7883a4fabd533e">More...</a><br /></td></tr>
<tr class="separator:a15885a8369e2c43c8c7883a4fabd533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa486c5f0556919686a9fdad4ebc2dcc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa486c5f0556919686a9fdad4ebc2dcc1">removeDoNothingBlock</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb)</td></tr>
<tr class="memdesc:aa486c5f0556919686a9fdad4ebc2dcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block from control-flow that performs no operations.  <a href="#aa486c5f0556919686a9fdad4ebc2dcc1">More...</a><br /></td></tr>
<tr class="separator:aa486c5f0556919686a9fdad4ebc2dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fca3088c3d01a584aef0db49dfccc63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks</a> (bool issuewarning, bool checkexistence)</td></tr>
<tr class="memdesc:a0fca3088c3d01a584aef0db49dfccc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any unreachable basic blocks.  <a href="#a0fca3088c3d01a584aef0db49dfccc63">More...</a><br /></td></tr>
<tr class="separator:a0fca3088c3d01a584aef0db49dfccc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d635570305e3ea710ade3cf090ba8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa2d635570305e3ea710ade3cf090ba8c">pushBranch</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, int4 slot, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bbnew)</td></tr>
<tr class="memdesc:aa2d635570305e3ea710ade3cf090ba8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a control-flow edge from one block to another.  <a href="#aa2d635570305e3ea710ade3cf090ba8c">More...</a><br /></td></tr>
<tr class="separator:aa2d635570305e3ea710ade3cf090ba8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a53162bf9a1756c4f2f4d7d1d7bbcec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3a53162bf9a1756c4f2f4d7d1d7bbcec">removeBranch</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, int4 num)</td></tr>
<tr class="memdesc:a3a53162bf9a1756c4f2f4d7d1d7bbcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the indicated branch from a basic block.  <a href="#a3a53162bf9a1756c4f2f4d7d1d7bbcec">More...</a><br /></td></tr>
<tr class="separator:a3a53162bf9a1756c4f2f4d7d1d7bbcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad810c24ce5fb16a95de1f7d27c8856d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad810c24ce5fb16a95de1f7d27c8856d8">nodeJoinCreateBlock</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *block1, <a class="el" href="classBlockBasic.html">BlockBasic</a> *block2, <a class="el" href="classBlockBasic.html">BlockBasic</a> *exita, <a class="el" href="classBlockBasic.html">BlockBasic</a> *exitb, bool fora_block1ishigh, bool forb_block1ishigh, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:ad810c24ce5fb16a95de1f7d27c8856d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new basic block for holding a merged CBRANCH.  <a href="#ad810c24ce5fb16a95de1f7d27c8856d8">More...</a><br /></td></tr>
<tr class="separator:ad810c24ce5fb16a95de1f7d27c8856d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e19baf8aa1db2ecde4fd12075da0694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *b, int4 inedge)</td></tr>
<tr class="memdesc:a3e19baf8aa1db2ecde4fd12075da0694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split control-flow into a basic block, duplicating its p-code into a new block.  <a href="#a3e19baf8aa1db2ecde4fd12075da0694">More...</a><br /></td></tr>
<tr class="separator:a3e19baf8aa1db2ecde4fd12075da0694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b35091642dc7527a537d01db5ad7e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac9b35091642dc7527a537d01db5ad7e1">forceGoto</a> (const <a class="el" href="classAddress.html">Address</a> &amp;pcop, const <a class="el" href="classAddress.html">Address</a> &amp;pcdest)</td></tr>
<tr class="memdesc:ac9b35091642dc7527a537d01db5ad7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a specific control-flow edge to be marked as <em>unstructured</em>.  <a href="#ac9b35091642dc7527a537d01db5ad7e1">More...</a><br /></td></tr>
<tr class="separator:ac9b35091642dc7527a537d01db5ad7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83619924b5d0fed25d0563b0f243262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af83619924b5d0fed25d0563b0f243262">removeFromFlowSplit</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, bool swap)</td></tr>
<tr class="memdesc:af83619924b5d0fed25d0563b0f243262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block splitting its control-flow into two distinct paths.  <a href="#af83619924b5d0fed25d0563b0f243262">More...</a><br /></td></tr>
<tr class="separator:af83619924b5d0fed25d0563b0f243262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba1555023c49006ed39936b9a40aba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5ba1555023c49006ed39936b9a40aba4">switchEdge</a> (<a class="el" href="classFlowBlock.html">FlowBlock</a> *inblock, <a class="el" href="classBlockBasic.html">BlockBasic</a> *outbefore, <a class="el" href="classFlowBlock.html">FlowBlock</a> *outafter)</td></tr>
<tr class="memdesc:a5ba1555023c49006ed39936b9a40aba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch an outgoing edge from the given <em>source</em> block to flow into another block.  <a href="#a5ba1555023c49006ed39936b9a40aba4">More...</a><br /></td></tr>
<tr class="separator:a5ba1555023c49006ed39936b9a40aba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c9d7c7fb4217731ae45f7848e4034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9f0c9d7c7fb4217731ae45f7848e4034">spliceBlockBasic</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bl)</td></tr>
<tr class="memdesc:a9f0c9d7c7fb4217731ae45f7848e4034"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> the given basic block with the block it flows into.  <a href="#a9f0c9d7c7fb4217731ae45f7848e4034">More...</a><br /></td></tr>
<tr class="separator:a9f0c9d7c7fb4217731ae45f7848e4034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9021f01b57f8704db66341bc7f65f39f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9021f01b57f8704db66341bc7f65f39f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9021f01b57f8704db66341bc7f65f39f">installSwitchDefaults</a> (void)</td></tr>
<tr class="memdesc:a9021f01b57f8704db66341bc7f65f39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure default switch cases are properly labeled. <br /></td></tr>
<tr class="separator:a9021f01b57f8704db66341bc7f65f39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223a70ddb5e33f446fca85bc3b369911"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a223a70ddb5e33f446fca85bc3b369911">replaceLessequal</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a223a70ddb5e33f446fca85bc3b369911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace INT_LESSEQUAL and INT_SLESSEQUAL expressions.  <a href="#a223a70ddb5e33f446fca85bc3b369911">More...</a><br /></td></tr>
<tr class="separator:a223a70ddb5e33f446fca85bc3b369911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b94fb7b2f8e72df053f4d09d48cdf7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a1b94fb7b2f8e72df053f4d09d48cdf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute constant coefficient to additive input.  <a href="#a1b94fb7b2f8e72df053f4d09d48cdf7b">More...</a><br /></td></tr>
<tr class="separator:a1b94fb7b2f8e72df053f4d09d48cdf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5027da6d3c7a05a262e332b0c22c7c43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5027da6d3c7a05a262e332b0c22c7c43">collapseIntMultMult</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a5027da6d3c7a05a262e332b0c22c7c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constant coefficients for two chained CPUI_INT_MULT.  <a href="#a5027da6d3c7a05a262e332b0c22c7c43">More...</a><br /></td></tr>
<tr class="separator:a5027da6d3c7a05a262e332b0c22c7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4456bfc523a4527c9fd924ecadacec63"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4456bfc523a4527c9fd924ecadacec63">compareCallspecs</a> (const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *a, const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *b)</td></tr>
<tr class="memdesc:a4456bfc523a4527c9fd924ecadacec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare call specification objects by call site address.  <a href="#a4456bfc523a4527c9fd924ecadacec63">More...</a><br /></td></tr>
<tr class="separator:a4456bfc523a4527c9fd924ecadacec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a0e9155d59329f73a01081dbe709d092b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba4262cb6daaa74781a30cd6734f797146">highlevel_on</a> = 1, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092baa5c01d2784c4599efd6b866439a2700c">blocks_generated</a> = 2, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba2141384f04dddfa59948fa3169c74935">blocks_unreachable</a> = 4, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba42380621eb49e673f20d9c68a0d8a0d2">processing_started</a> = 8, 
<br />
&#160;&#160;<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092bab3384e6ae1edfe6f2093b208ea60eca7">processing_complete</a> = 0x10, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba0cd27df565c9f3cfceb928ac2468f4f4">typerecovery_on</a> = 0x20, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba23a953cc66d2fc04b1b48f3b72a17e5d">no_code</a> = 0x40, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba867c97a7dfff6488a06fbd51badb48b3">jumptablerecovery_on</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba73782af4d513cc7b8c73b9183067585e">jumptablerecovery_dont</a> = 0x100, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba45ce5472ffe09854b56f87436062982c">restart_pending</a> = 0x200, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba6f29561045e40ba06b194b78eaeae9df">unimplemented_present</a> = 0x400, 
<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092baf70cf08c91a86b24670af34fb10b9743">baddata_present</a> = 0x800, 
<br />
&#160;&#160;<a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba6c39685abdf85f90ed252f9ebc4e62ce">double_precis_on</a> = 0x1000
<br />
 }</td></tr>
<tr class="separator:a0e9155d59329f73a01081dbe709d092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af7412778106b02b163e6d685deb826db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af7412778106b02b163e6d685deb826db">setVarnodeProperties</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn) const </td></tr>
<tr class="memdesc:af7412778106b02b163e6d685deb826db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up boolean properties and data-type information.  <a href="#af7412778106b02b163e6d685deb826db">More...</a><br /></td></tr>
<tr class="separator:af7412778106b02b163e6d685deb826db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a38d8d7ccb7d43a063d09077d32639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a78a38d8d7ccb7d43a063d09077d32639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a78a38d8d7ccb7d43a063d09077d32639">More...</a><br /></td></tr>
<tr class="separator:a78a38d8d7ccb7d43a063d09077d32639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1360c1bee4b15ff97e1fbbf9a362e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa1360c1bee4b15ff97e1fbbf9a362e2c">handleSymbolConflict</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, <a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:aa1360c1bee4b15ff97e1fbbf9a362e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle two variables with matching storage.  <a href="#aa1360c1bee4b15ff97e1fbbf9a362e2c">More...</a><br /></td></tr>
<tr class="separator:aa1360c1bee4b15ff97e1fbbf9a362e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d0b153ce9e5ff67bf0724ad945e866"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a97d0b153ce9e5ff67bf0724ad945e866">syncVarnodesWithSymbol</a> (VarnodeLocSet::const_iterator &amp;iter, uint4 <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a97d0b153ce9e5ff67bf0724ad945e866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update properties (and the data-type) for a set of Varnodes associated with one <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.  <a href="#a97d0b153ce9e5ff67bf0724ad945e866">More...</a><br /></td></tr>
<tr class="separator:a97d0b153ce9e5ff67bf0724ad945e866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6d87b91d72d3695a4da052e60ee58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:ac0d6d87b91d72d3695a4da052e60ee58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform all reads of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to a special <b>undefined</b> constant.  <a href="#ac0d6d87b91d72d3695a4da052e60ee58">More...</a><br /></td></tr>
<tr class="separator:ac0d6d87b91d72d3695a4da052e60ee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022a17a53f47adfd09ca88202f953342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a022a17a53f47adfd09ca88202f953342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all reads of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> unique.  <a href="#a022a17a53f47adfd09ca88202f953342">More...</a><br /></td></tr>
<tr class="separator:a022a17a53f47adfd09ca88202f953342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a2077b443015cd83b0a8bb7d27856a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af1a2077b443015cd83b0a8bb7d27856a">cloneVarnode</a> (const <a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:af1a2077b443015cd83b0a8bb7d27856a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (between copies of the function)  <a href="#af1a2077b443015cd83b0a8bb7d27856a">More...</a><br /></td></tr>
<tr class="separator:af1a2077b443015cd83b0a8bb7d27856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaece008a9aff77bc2e7acae325c992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6aaece008a9aff77bc2e7acae325c992">destroyVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a6aaece008a9aff77bc2e7acae325c992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from <b>this</b> function.  <a href="#a6aaece008a9aff77bc2e7acae325c992">More...</a><br /></td></tr>
<tr class="separator:a6aaece008a9aff77bc2e7acae325c992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819b7ff38483292c7020320daa8bfdc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a819b7ff38483292c7020320daa8bfdc0">coverVarnodes</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;list)</td></tr>
<tr class="memdesc:a819b7ff38483292c7020320daa8bfdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure every <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the given list has a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> it will link to.  <a href="#a819b7ff38483292c7020320daa8bfdc0">More...</a><br /></td></tr>
<tr class="separator:a819b7ff38483292c7020320daa8bfdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af855f5d5a715a50d52ac193b983cd7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:af855f5d5a715a50d52ac193b983cd7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform trivial CPUI_MULTIEQUAL to CPUI_COPY.  <a href="#af855f5d5a715a50d52ac193b983cd7a9">More...</a><br /></td></tr>
<tr class="separator:af855f5d5a715a50d52ac193b983cd7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaec6200c5a0eec8dbb24aef0348ab3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, bool unreachable)</td></tr>
<tr class="memdesc:abaec6200c5a0eec8dbb24aef0348ab3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an active basic block from the function.  <a href="#abaec6200c5a0eec8dbb24aef0348ab3a">More...</a><br /></td></tr>
<tr class="separator:abaec6200c5a0eec8dbb24aef0348ab3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96af1ca8355f0c4f8e6582c045f0723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac96af1ca8355f0c4f8e6582c045f0723">branchRemoveInternal</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, int4 num)</td></tr>
<tr class="memdesc:ac96af1ca8355f0c4f8e6582c045f0723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an outgoing branch of the given basic block.  <a href="#ac96af1ca8355f0c4f8e6582c045f0723">More...</a><br /></td></tr>
<tr class="separator:ac96af1ca8355f0c4f8e6582c045f0723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76e681657570c6494c366c16825f130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb)</td></tr>
<tr class="memdesc:ae76e681657570c6494c366c16825f130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push MULTIEQUAL Varnodes of the given block into the output block.  <a href="#ae76e681657570c6494c366c16825f130">More...</a><br /></td></tr>
<tr class="separator:ae76e681657570c6494c366c16825f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01972a459701d874f86e60558b21266"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01972a459701d874f86e60558b21266"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac01972a459701d874f86e60558b21266">clearBlocks</a> (void)</td></tr>
<tr class="memdesc:ac01972a459701d874f86e60558b21266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all basic blocks. <br /></td></tr>
<tr class="separator:ac01972a459701d874f86e60558b21266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fde73229529d726f73be2fe9319c1b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset</a> (void)</td></tr>
<tr class="memdesc:a5fde73229529d726f73be2fe9319c1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate initial basic block structures (after a control-flow change)  <a href="#a5fde73229529d726f73be2fe9319c1b8">More...</a><br /></td></tr>
<tr class="separator:a5fde73229529d726f73be2fe9319c1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b08186fd6b91718d81930f3dda621a"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae8b08186fd6b91718d81930f3dda621a">stageJumpTable</a> (<a class="el" href="classJumpTable.html">JumpTable</a> *jt, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classFlowInfo.html">FlowInfo</a> *flow)</td></tr>
<tr class="memdesc:ae8b08186fd6b91718d81930f3dda621a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover a jump-table for a given BRANCHIND using existing flow information.  <a href="#ae8b08186fd6b91718d81930f3dda621a">More...</a><br /></td></tr>
<tr class="separator:ae8b08186fd6b91718d81930f3dda621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307d12e7da23cd0c737549da4ff6679b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a307d12e7da23cd0c737549da4ff6679b">switchOverJumpTables</a> (const <a class="el" href="classFlowInfo.html">FlowInfo</a> &amp;flow)</td></tr>
<tr class="memdesc:a307d12e7da23cd0c737549da4ff6679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert jump-table addresses to basic block indices.  <a href="#a307d12e7da23cd0c737549da4ff6679b">More...</a><br /></td></tr>
<tr class="separator:a307d12e7da23cd0c737549da4ff6679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfbb67a5176f79f221500a5c8c5d160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adbfbb67a5176f79f221500a5c8c5d160">clearJumpTables</a> (void)</td></tr>
<tr class="memdesc:adbfbb67a5176f79f221500a5c8c5d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any jump-table information.  <a href="#adbfbb67a5176f79f221500a5c8c5d160">More...</a><br /></td></tr>
<tr class="separator:adbfbb67a5176f79f221500a5c8c5d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58664772693fca369a469c1540c65e2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a58664772693fca369a469c1540c65e2a">sortCallSpecs</a> (void)</td></tr>
<tr class="memdesc:a58664772693fca369a469c1540c65e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort calls using a dominance based order.  <a href="#a58664772693fca369a469c1540c65e2a">More...</a><br /></td></tr>
<tr class="separator:a58664772693fca369a469c1540c65e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08706f8fc71e5634d032d1315705b613"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a08706f8fc71e5634d032d1315705b613">deleteCallSpecs</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a08706f8fc71e5634d032d1315705b613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specification for a particular call.  <a href="#a08706f8fc71e5634d032d1315705b613">More...</a><br /></td></tr>
<tr class="separator:a08706f8fc71e5634d032d1315705b613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973da4f1c476970a5d5482b8ebf5c7a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a973da4f1c476970a5d5482b8ebf5c7a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a973da4f1c476970a5d5482b8ebf5c7a3">clearCallSpecs</a> (void)</td></tr>
<tr class="memdesc:a973da4f1c476970a5d5482b8ebf5c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all call specifications. <br /></td></tr>
<tr class="separator:a973da4f1c476970a5d5482b8ebf5c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310ba90147bef99048bbea76d0edd81e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a310ba90147bef99048bbea76d0edd81e">nodeSplitBlockEdge</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *b, int4 inedge)</td></tr>
<tr class="memdesc:a310ba90147bef99048bbea76d0edd81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split given basic block b along an <em>in</em> edge.  <a href="#a310ba90147bef99048bbea76d0edd81e">More...</a><br /></td></tr>
<tr class="separator:a310ba90147bef99048bbea76d0edd81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c5acfe4a404779a418095011ed2815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a51c5acfe4a404779a418095011ed2815">nodeSplitCloneOp</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a51c5acfe4a404779a418095011ed2815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as part of splitting a block.  <a href="#a51c5acfe4a404779a418095011ed2815">More...</a><br /></td></tr>
<tr class="separator:a51c5acfe4a404779a418095011ed2815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a79f4159aed3b616d43a9eadee040e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9a79f4159aed3b616d43a9eadee040e1">nodeSplitCloneVarnode</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *newop)</td></tr>
<tr class="memdesc:a9a79f4159aed3b616d43a9eadee040e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the given p-code op, as part of splitting a block.  <a href="#a9a79f4159aed3b616d43a9eadee040e1">More...</a><br /></td></tr>
<tr class="separator:a9a79f4159aed3b616d43a9eadee040e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393fde88940742db881c80783e0af0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7393fde88940742db881c80783e0af0d">nodeSplitRawDuplicate</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *b, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bprime)</td></tr>
<tr class="memdesc:a7393fde88940742db881c80783e0af0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone all p-code ops from a block into its copy.  <a href="#a7393fde88940742db881c80783e0af0d">More...</a><br /></td></tr>
<tr class="separator:a7393fde88940742db881c80783e0af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaf9bd74b73972d2d453866631dbd1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *b, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bprime, int4 inedge)</td></tr>
<tr class="memdesc:a4aaf9bd74b73972d2d453866631dbd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs to p-code ops in split basic block.  <a href="#a4aaf9bd74b73972d2d453866631dbd1e">More...</a><br /></td></tr>
<tr class="separator:a4aaf9bd74b73972d2d453866631dbd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a18fcb354b9f1dda46f197335431d7ef2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a18fcb354b9f1dda46f197335431d7ef2">descendantsOutside</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a18fcb354b9f1dda46f197335431d7ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has any descendants in a dead block.  <a href="#a18fcb354b9f1dda46f197335431d7ef2">More...</a><br /></td></tr>
<tr class="separator:a18fcb354b9f1dda46f197335431d7ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abade5bd2230b9f8d2cc19d271f5bb411"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#abade5bd2230b9f8d2cc19d271f5bb411">saveVarnodeXml</a> (ostream &amp;s, VarnodeLocSet::const_iterator iter, VarnodeLocSet::const_iterator enditer)</td></tr>
<tr class="memdesc:abade5bd2230b9f8d2cc19d271f5bb411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save XML descriptions for a set of Varnodes to stream.  <a href="#abade5bd2230b9f8d2cc19d271f5bb411">More...</a><br /></td></tr>
<tr class="separator:abade5bd2230b9f8d2cc19d271f5bb411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84c0818a7e3c468def458a16d80e6bf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab84c0818a7e3c468def458a16d80e6bf">checkIndirectUse</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:ab84c0818a7e3c468def458a16d80e6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> only flows into call-based INDIRECT ops.  <a href="#ab84c0818a7e3c468def458a16d80e6bf">More...</a><br /></td></tr>
<tr class="separator:ab84c0818a7e3c468def458a16d80e6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24286ca987a0d110daa493283f7e5ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac24286ca987a0d110daa493283f7e5ad">findPrimaryBranch</a> (PcodeOpTree::const_iterator iter, PcodeOpTree::const_iterator enditer, bool findbranch, bool findcall, bool findreturn)</td></tr>
<tr class="memdesc:ac24286ca987a0d110daa493283f7e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the primary branch operation for an instruction.  <a href="#ac24286ca987a0d110daa493283f7e5ad">More...</a><br /></td></tr>
<tr class="separator:ac24286ca987a0d110daa493283f7e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a652b56184c061181d44733a6d5b19069"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a652b56184c061181d44733a6d5b19069"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a></td></tr>
<tr class="memdesc:a652b56184c061181d44733a6d5b19069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean properties associated with <b>this</b> function. <br /></td></tr>
<tr class="separator:a652b56184c061181d44733a6d5b19069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a2dfa58336e8f05348c1c0a4a4f43d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00a2dfa58336e8f05348c1c0a4a4f43d"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a00a2dfa58336e8f05348c1c0a4a4f43d">clean_up_index</a></td></tr>
<tr class="memdesc:a00a2dfa58336e8f05348c1c0a4a4f43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation index of first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> created after start of cleanup. <br /></td></tr>
<tr class="separator:a00a2dfa58336e8f05348c1c0a4a4f43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5288024c3d00a0570d4cdb14a6c3c376"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5288024c3d00a0570d4cdb14a6c3c376"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5288024c3d00a0570d4cdb14a6c3c376">high_level_index</a></td></tr>
<tr class="memdesc:a5288024c3d00a0570d4cdb14a6c3c376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation index of first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> created after HighVariables are created. <br /></td></tr>
<tr class="separator:a5288024c3d00a0570d4cdb14a6c3c376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8168657ee50cf31b8e314d95ce9cfc88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8168657ee50cf31b8e314d95ce9cfc88"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8168657ee50cf31b8e314d95ce9cfc88">cast_phase_index</a></td></tr>
<tr class="memdesc:a8168657ee50cf31b8e314d95ce9cfc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation index of first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> created after <a class="el" href="classActionSetCasts.html" title="Fill-in CPUI_CAST p-code ops as required by the casting strategy. ">ActionSetCasts</a>. <br /></td></tr>
<tr class="separator:a8168657ee50cf31b8e314d95ce9cfc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f8b3cdc80fb056614087f49c15b9d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f8b3cdc80fb056614087f49c15b9d7"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a50f8b3cdc80fb056614087f49c15b9d7">minLanedSize</a></td></tr>
<tr class="memdesc:a50f8b3cdc80fb056614087f49c15b9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> size to check as <a class="el" href="classLanedRegister.html" title="Describes a (register) storage location and the ways it might be split into lanes. ">LanedRegister</a>. <br /></td></tr>
<tr class="separator:a50f8b3cdc80fb056614087f49c15b9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67995a51bd7f1a6ebf51ec0bb3836358"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67995a51bd7f1a6ebf51ec0bb3836358"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a></td></tr>
<tr class="memdesc:a67995a51bd7f1a6ebf51ec0bb3836358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes of binary data in function body. <br /></td></tr>
<tr class="separator:a67995a51bd7f1a6ebf51ec0bb3836358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4891fce136f49993879f1bf1a9a6000c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4891fce136f49993879f1bf1a9a6000c"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a></td></tr>
<tr class="memdesc:a4891fce136f49993879f1bf1a9a6000c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global configuration data. <br /></td></tr>
<tr class="separator:a4891fce136f49993879f1bf1a9a6000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0fbdfb3b3a612123719586c8dee368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add0fbdfb3b3a612123719586c8dee368"></a>
<a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#add0fbdfb3b3a612123719586c8dee368">functionSymbol</a></td></tr>
<tr class="memdesc:add0fbdfb3b3a612123719586c8dee368"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbol representing <b>this</b> function. <br /></td></tr>
<tr class="separator:add0fbdfb3b3a612123719586c8dee368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2c1673cccd101653606f7f5e4a8eb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb2c1673cccd101653606f7f5e4a8eb8"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#abb2c1673cccd101653606f7f5e4a8eb8">name</a></td></tr>
<tr class="memdesc:abb2c1673cccd101653606f7f5e4a8eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of function. <br /></td></tr>
<tr class="separator:abb2c1673cccd101653606f7f5e4a8eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab458fa1ba652de0e05d7cad3c46a2860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab458fa1ba652de0e05d7cad3c46a2860"></a>
<a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a></td></tr>
<tr class="memdesc:ab458fa1ba652de0e05d7cad3c46a2860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting code address of binary data. <br /></td></tr>
<tr class="separator:ab458fa1ba652de0e05d7cad3c46a2860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c933ff90fe37557164652d70f5b34d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c933ff90fe37557164652d70f5b34d1"></a>
<a class="el" href="classFuncProto.html">FuncProto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a></td></tr>
<tr class="memdesc:a4c933ff90fe37557164652d70f5b34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of this function. <br /></td></tr>
<tr class="separator:a4c933ff90fe37557164652d70f5b34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e403edd5b4b01e8629bff49d936f939"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e403edd5b4b01e8629bff49d936f939"></a>
<a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a></td></tr>
<tr class="memdesc:a9e403edd5b4b01e8629bff49d936f939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local variables (symbols in the function scope) <br /></td></tr>
<tr class="separator:a9e403edd5b4b01e8629bff49d936f939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e08833a58a93938d74fb0775e13c2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e08833a58a93938d74fb0775e13c2e"></a>
vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa8e08833a58a93938d74fb0775e13c2e">qlst</a></td></tr>
<tr class="memdesc:aa8e08833a58a93938d74fb0775e13c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of calls this function makes. <br /></td></tr>
<tr class="separator:aa8e08833a58a93938d74fb0775e13c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d550737246266d62752b5ebc18d881"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6d550737246266d62752b5ebc18d881"></a>
vector&lt; <a class="el" href="classJumpTable.html">JumpTable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a></td></tr>
<tr class="memdesc:ac6d550737246266d62752b5ebc18d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of jump-tables for this function. <br /></td></tr>
<tr class="separator:ac6d550737246266d62752b5ebc18d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ffa1ac8ad55ab4510c4fd5fb592d30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70ffa1ac8ad55ab4510c4fd5fb592d30"></a>
<a class="el" href="classVarnodeBank.html">VarnodeBank</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a></td></tr>
<tr class="memdesc:a70ffa1ac8ad55ab4510c4fd5fb592d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> objects for <b>this</b> function. <br /></td></tr>
<tr class="separator:a70ffa1ac8ad55ab4510c4fd5fb592d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9767dc1053f685ee11d0771d3aca1681"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9767dc1053f685ee11d0771d3aca1681"></a>
<a class="el" href="classPcodeOpBank.html">PcodeOpBank</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a></td></tr>
<tr class="memdesc:a9767dc1053f685ee11d0771d3aca1681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects for <b>this</b> function. <br /></td></tr>
<tr class="separator:a9767dc1053f685ee11d0771d3aca1681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a44b7fe1b50a7b0dfa195d0825bf5eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a44b7fe1b50a7b0dfa195d0825bf5eb"></a>
<a class="el" href="classBlockGraph.html">BlockGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a></td></tr>
<tr class="memdesc:a8a44b7fe1b50a7b0dfa195d0825bf5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unstructured basic blocks. <br /></td></tr>
<tr class="separator:a8a44b7fe1b50a7b0dfa195d0825bf5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37058a8643a9c57cdf5e00e709730ea0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37058a8643a9c57cdf5e00e709730ea0"></a>
<a class="el" href="classBlockGraph.html">BlockGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a37058a8643a9c57cdf5e00e709730ea0">sblocks</a></td></tr>
<tr class="memdesc:a37058a8643a9c57cdf5e00e709730ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structured block hierarchy (on top of basic blocks) <br /></td></tr>
<tr class="separator:a37058a8643a9c57cdf5e00e709730ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74503254ffd9061b07f973580a0d1af6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74503254ffd9061b07f973580a0d1af6"></a>
<a class="el" href="classHeritage.html">Heritage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a74503254ffd9061b07f973580a0d1af6">heritage</a></td></tr>
<tr class="memdesc:a74503254ffd9061b07f973580a0d1af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for maintaining SSA form. <br /></td></tr>
<tr class="separator:a74503254ffd9061b07f973580a0d1af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c507405ef5c06bf3e6ed0b1057e49bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c507405ef5c06bf3e6ed0b1057e49bd"></a>
<a class="el" href="classMerge.html">Merge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1c507405ef5c06bf3e6ed0b1057e49bd">covermerge</a></td></tr>
<tr class="memdesc:a1c507405ef5c06bf3e6ed0b1057e49bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable range intersection algorithms. <br /></td></tr>
<tr class="separator:a1c507405ef5c06bf3e6ed0b1057e49bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3032e37a3ab0db1d35aee82ebe4f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bc3032e37a3ab0db1d35aee82ebe4f4"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1bc3032e37a3ab0db1d35aee82ebe4f4">activeoutput</a></td></tr>
<tr class="memdesc:a1bc3032e37a3ab0db1d35aee82ebe4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for assessing which parameters are passed to <b>this</b> function. <br /></td></tr>
<tr class="separator:a1bc3032e37a3ab0db1d35aee82ebe4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21754a3c362d2208f9ee7f317cf504b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21754a3c362d2208f9ee7f317cf504b9"></a>
<a class="el" href="classOverride.html">Override</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a21754a3c362d2208f9ee7f317cf504b9">localoverride</a></td></tr>
<tr class="memdesc:a21754a3c362d2208f9ee7f317cf504b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides of data-flow, prototypes, etc. that are local to <b>this</b> function. <br /></td></tr>
<tr class="separator:a21754a3c362d2208f9ee7f317cf504b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bab1d6cdec52c3971b08237a8bfe8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08bab1d6cdec52c3971b08237a8bfe8a"></a>
map&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a>, const <a class="el" href="classLanedRegister.html">LanedRegister</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a08bab1d6cdec52c3971b08237a8bfe8a">lanedMap</a></td></tr>
<tr class="memdesc:a08bab1d6cdec52c3971b08237a8bfe8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current storage locations which may be laned registers. <br /></td></tr>
<tr class="separator:a08bab1d6cdec52c3971b08237a8bfe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Container for data structures associated with a single function. </p>
<p>This class holds the primary data structures for decompiling a function. In particular it holds control-flow, data-flow, and prototype information, plus class instances to help with constructing SSA form, structure control-flow, recover jump-tables, recover parameters, and merge Varnodes. In most cases it acts as the main API for querying and accessing these structures.</p>
<p>Some important groups of public methods include:</p><ul>
<li><a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> manipulation (mostly starting with 'op')</li>
<li><a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> search and traversal ('beginOp*' and 'endOp*')</li>
<li><a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> creation ('new*' methods)</li>
<li><a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> search and traversal ('beginLoc' 'endLoc' 'beginDef' and 'endDef')</li>
<li>Basic block access and block structuring</li>
<li>Access to subfunction prototypes</li>
<li>Access to jump-tables (within the body of the function) </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a0e9155d59329f73a01081dbe709d092b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba4262cb6daaa74781a30cd6734f797146"></a>highlevel_on&#160;</td><td class="fielddoc">
<p>Set if Varnodes have HighVariables assigned. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092baa5c01d2784c4599efd6b866439a2700c"></a>blocks_generated&#160;</td><td class="fielddoc">
<p>Set if Basic blocks have been generated. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba2141384f04dddfa59948fa3169c74935"></a>blocks_unreachable&#160;</td><td class="fielddoc">
<p>Set if at least one basic block is currently unreachable. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba42380621eb49e673f20d9c68a0d8a0d2"></a>processing_started&#160;</td><td class="fielddoc">
<p>Set if processing has started. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092bab3384e6ae1edfe6f2093b208ea60eca7"></a>processing_complete&#160;</td><td class="fielddoc">
<p>Set if processing completed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba0cd27df565c9f3cfceb928ac2468f4f4"></a>typerecovery_on&#160;</td><td class="fielddoc">
<p>Set if data-type recovery is started. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba23a953cc66d2fc04b1b48f3b72a17e5d"></a>no_code&#160;</td><td class="fielddoc">
<p>Set if there is no code available for this function. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba867c97a7dfff6488a06fbd51badb48b3"></a>jumptablerecovery_on&#160;</td><td class="fielddoc">
<p>Set if <b>this</b> <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object is dedicated to jump-table recovery. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba73782af4d513cc7b8c73b9183067585e"></a>jumptablerecovery_dont&#160;</td><td class="fielddoc">
<p>Don't try to recover jump-tables, always truncate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba45ce5472ffe09854b56f87436062982c"></a>restart_pending&#160;</td><td class="fielddoc">
<p>Analysis must be restarted (because of new override info) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba6f29561045e40ba06b194b78eaeae9df"></a>unimplemented_present&#160;</td><td class="fielddoc">
<p>Set if function contains unimplemented instructions. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092baf70cf08c91a86b24670af34fb10b9743"></a>baddata_present&#160;</td><td class="fielddoc">
<p>Set if function flowed into bad data. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e9155d59329f73a01081dbe709d092ba6c39685abdf85f90ed252f9ebc4e62ce"></a>double_precis_on&#160;</td><td class="fielddoc">
<p>Set if we are performing double precision recovery. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a979faf589906b1a1937623f7a2a186f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Funcdata::Funcdata </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the (base) name of the function </td></tr>
    <tr><td class="paramname">scope</td><td>is <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> scope associated with the function </td></tr>
    <tr><td class="paramname">addr</td><td>is the entry address for the function </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes (of code) in the function body </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a1bc3032e37a3ab0db1d35aee82ebe4f4">activeoutput</a>, <a class="el" href="classDatabase.html#a1bc096166a8cfde3d77229c9e38bfabf">Database::attachScope()</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classFuncdata.html#a8168657ee50cf31b8e314d95ce9cfc88">cast_phase_index</a>, <a class="el" href="classFuncdata.html#a00a2dfa58336e8f05348c1c0a4a4f43d">clean_up_index</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classFuncdata.html#add0fbdfb3b3a612123719586c8dee368">functionSymbol</a>, <a class="el" href="classScope.html#adb0e2018c6c10aaca1403cc9850e065e">Scope::getArch()</a>, <a class="el" href="classSymbol.html#a159d799a53ed181ef133d0ee22e2db90">Symbol::getId()</a>, <a class="el" href="classArchitecture.html#a913188e1960099ea8f8f45794b730677">Architecture::getMinimumLanedRegisterSize()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddrSpaceManager.html#a4c6a5c3c4ceadaf7f0b4343f52639153">AddrSpaceManager::getStackSpace()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a5288024c3d00a0570d4cdb14a6c3c376">high_level_index</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classFuncdata.html#a50f8b3cdc80fb056614087f49c15b9d7">minLanedSize</a>, <a class="el" href="classFuncdata.html#abb2c1673cccd101653606f7f5e4a8eb8">name</a>, <a class="el" href="classScopeLocal.html#a3bf9941188eb64423d2ed49a08dab8ca">ScopeLocal::resetLocalWindow()</a>, <a class="el" href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">FuncProto::setScope()</a>, <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, and <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a35c51952540dbda3f11962b22c3064a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::adjustInputVarnodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust input Varnodes contained in the given range. </p>
<p>After this call, a single <em>input</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will exist that fills the given range. Any previous input Varnodes contained in this range are redefined using a SUBPIECE op off of the new single input. If an overlapping <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> isn't fully contained an exception is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classVarnodeBank.html#a261374116c4581bd8aa748a3b3fe7d59">VarnodeBank::beginDef()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classFuncdata.html#aa8657c4c04279316593adc6d2f389be5">deleteVarnode()</a>, <a class="el" href="classVarnodeBank.html#aea1d001695802f0376ead8dc744216f9">VarnodeBank::endDef()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classFuncdata.html#a91233c941630a3194e8287206314bb1e">getAddress()</a>, <a class="el" href="classBlockGraph.html#a8a8163564a0e9217cab5f085eab2684e">BlockGraph::getBlock()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca9c9363556459d8828a5ab58c370ccd2e">Varnode::input</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut()</a>, <a class="el" href="classFuncdata.html#ae6341eb8ca8a8004f1c77a8e8147a286">opInsertBegin()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">setInputVarnode()</a>, <a class="el" href="classVarnode.html#ae5fb93c31c77ab156b9a9a88045e83db">Varnode::setWriteMask()</a>, <a class="el" href="classFuncdata.html#aab7f940f85609d395283520eca3a71f0">totalReplace()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionUnjustifiedParams.html#a76dd93b62ac18bb4d18cba2a79c0ac55">ActionUnjustifiedParams::apply()</a>, and <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a226bd2fae467e85879220d2aaf9b1da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::ancestorOpUse </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>maxlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>invn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParamTrial.html">ParamTrial</a> &amp;&#160;</td>
          <td class="paramname"><em>trial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given trial <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is likely only used for parameter passing. </p>
<p>Flow is followed from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> itself and from ancestors the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was copied from to see if it hits anything other than the given CALL or RETURN operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlevel</td><td>is the maximum number of times to recurse through ancestor copies </td></tr>
    <tr><td class="paramname">invn</td><td>is the given trial <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to test </td></tr>
    <tr><td class="paramname">op</td><td>is the given CALL or RETURN </td></tr>
    <tr><td class="paramname">trial</td><td>is the associated parameter trial object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is only used for the CALL/RETURN </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#aaf4ba146f90fc4550f8e5809617afae3">PcodeOp::clearMark()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7abd32745cfc7da476c8ecc9a6c0dbfa03">CPUI_INT_REM</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a931c04bd86e504fddb73a80e9e2a9d88">CPUI_INT_SREM</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a1eef2cfc279c246cc7ea0387d8c0aa66">IPTR_INTERNAL</a>, <a class="el" href="classPcodeOp.html#a84a05884fd0288af176cab3ced4ec2de">PcodeOp::isIncidentalCopy()</a>, <a class="el" href="classVarnode.html#ae6e06e1505ba62767a661ffbcb802541">Varnode::isIncidentalCopy()</a>, <a class="el" href="classPcodeOp.html#a94eede902decfd58b5443fbfe7c1560a">PcodeOp::isIndirectCreation()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classPcodeOp.html#af03aefce85152f7f638a5d87ceccc495">PcodeOp::isMark()</a>, <a class="el" href="classVarnode.html#a4bc8a57cabff365b49a883ebe691609e">Varnode::isTypeLock()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#a1347de2ecdf4bf99194abb7e11e8eb5d">onlyOpUse()</a>, <a class="el" href="classPcodeOp.html#ab2ba9f66448cd77b6f274de6fae433e2">PcodeOp::setMark()</a>, and <a class="el" href="classParamTrial.html#a3fa95bb637e208d366f70cecaa6c331d">ParamTrial::setRemFormed()</a>.</p>

<p>Referenced by <a class="el" href="classActionReturnRecovery.html#aaad5058cd2347ea61be24b63f8b17d60">ActionReturnRecovery::apply()</a>, <a class="el" href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">FuncCallSpecs::checkInputTrialUse()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a78a38d8d7ccb7d43a063d09077d32639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHighVariable.html">HighVariable</a> * Funcdata::assignHigh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>If HighVariables are enabled, make sure the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has one assigned. Allocate a dedicated <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>, that contains only the one <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the assigned <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> or NULL if one is not assigned </dd></dl>

<p>References <a class="el" href="classVarnode.html#addc78d7786b99104f213a654534a3281">Varnode::calcCover()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classVarnode.html#a049582bef1b75183ec9e358aad951484">Varnode::hasCover()</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba4262cb6daaa74781a30cd6734f797146">highlevel_on</a>, and <a class="el" href="classVarnode.html#af7d640b593a55ac3eb63fa7322fb8a2a">Varnode::isAnnotation()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">newCodeRef()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">newUnique()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, <a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">newVarnodeCallSpecs()</a>, <a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">newVarnodeIop()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut()</a>, <a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">newVarnodeSpace()</a>, and <a class="el" href="classFuncdata.html#afadeeb585ee8728c427fd6914b8bb7b1">setHighLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="adeee32fc648486d26cd17ebb37bb118f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::attemptDynamicMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;&#160;</td>
          <td class="paramname"><em>dhash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map properties of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a dynamic mapping, try to find the mapped <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, then adjust (type and flags) to reflect this mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the (dynamic) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry </td></tr>
    <tr><td class="paramname">dhash</td><td>is the dynamic mapping information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was adjusted </dd></dl>

<p>References <a class="el" href="classDynamicHash.html#aa260964020db06dfcee8565544aa3b96">DynamicHash::clear()</a>, <a class="el" href="classDynamicHash.html#ad3428d1e0ef5ea4f535dc4bb6ed1c6d0">DynamicHash::findVarnode()</a>, <a class="el" href="classSymbol.html#acaff3459194561c00da268fcce51d3a6">Symbol::getCategory()</a>, <a class="el" href="classSymbolEntry.html#aa30077363e5701d11b7b4a28cfbd676a">SymbolEntry::getFirstUseAddress()</a>, <a class="el" href="classSymbolEntry.html#a103561fd1adde2a47e3396eb70457373">SymbolEntry::getHash()</a>, <a class="el" href="classSymbol.html#a8604199b94cd6be318e14cf9571ad1ad">Symbol::getScope()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classVarnode.html#a1e44191c7c35c94122e1a2abe49a3292">Varnode::mapentry</a>, <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>, and <a class="el" href="classVarnode.html#a0ae87b8fb23c218185f4cee1d958b606">Varnode::setSymbolProperties()</a>.</p>

<p>Referenced by <a class="el" href="classActionDynamicMapping.html#a4d91f3a0cca0be4f2600f5deff083cd8">ActionDynamicMapping::apply()</a>, and <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>.</p>

</div>
</div>
<a class="anchor" id="a69dddb637a6e322632f9a4bb10c5c36e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::attemptDynamicMappingLate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;&#160;</td>
          <td class="paramname"><em>dhash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the name of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a dynamic mapping, try to find the mapped <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, then attach the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is used, but the data-type and possibly other properties are not put on the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the (dynamic) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry </td></tr>
    <tr><td class="paramname">dhash</td><td>is the dynamic mapping information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was adjusted </dd></dl>

<p>References <a class="el" href="classDynamicHash.html#aa260964020db06dfcee8565544aa3b96">DynamicHash::clear()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab83bb63150022cfa8faab94c521b0a38">CPUI_CAST</a>, <a class="el" href="classDynamicHash.html#ad3428d1e0ef5ea4f535dc4bb6ed1c6d0">DynamicHash::findVarnode()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classSymbolEntry.html#aa30077363e5701d11b7b4a28cfbd676a">SymbolEntry::getFirstUseAddress()</a>, <a class="el" href="classSymbolEntry.html#a103561fd1adde2a47e3396eb70457373">SymbolEntry::getHash()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classSymbol.html#aee9da22d9d9f511694bb1eb95f5033e9">Symbol::getName()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classVarnode.html#a8fe4e23fbb7a0ac661704930a48bdaf2">Varnode::getSymbolEntry()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classSymbol.html#ad3bc7110cbcbeebbd642ba8e3342a59d">Symbol::getType()</a>, <a class="el" href="classVarnode.html#a02d79ce8ef165a47684861166d549964">Varnode::isExplicit()</a>, <a class="el" href="classVarnode.html#a71980f26f2bca5a4901d2781a8917d7c">Varnode::isImplied()</a>, <a class="el" href="classSymbol.html#a7f255c48d4636336631e62085975b7c3">Symbol::isNameUndefined()</a>, <a class="el" href="classSymbol.html#a17fd1dd4580930c34b6deb1f3daf447f">Symbol::isTypeLocked()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>, <a class="el" href="classScopeInternal.html#a9711a8084e1ac5c4417a4452c96a36b7">ScopeInternal::retypeSymbol()</a>, <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classActionDynamicSymbols.html#aa3c25f3a649481cc9c783609295b60b8">ActionDynamicSymbols::apply()</a>, and <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>.</p>

</div>
</div>
<a class="anchor" id="abaec6200c5a0eec8dbb24aef0348ab3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::blockRemoveInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unreachable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an active basic block from the function. </p>
<p>PcodeOps in the block are deleted. Data-flow and control-flow are otherwise patched up. Most of the work is patching up MULTIEQUALs and other remaining references to Varnodes flowing through the block to be removed.</p>
<p>If descendant Varnodes are stranded by removing the block, either an exception is thrown, or optionally, the descendant Varnodes can be replaced with constants and a warning is printed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">unreachable</td><td>is <b>true</b> if the caller wants a warning for stranded Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classFuncdata.html#a08706f8fc71e5634d032d1315705b613">deleteCallSpecs()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a18fcb354b9f1dda46f197335431d7ef2">descendantsOutside()</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classFuncdata.html#a925018ca0152e89fd099aba761bb2b9d">findJumpTable()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFlowBlock.html#ad25db558c78a70ac799b0c97719f9a68">FlowBlock::getInIndex()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOp.html#abc2ed5aba256816975fd9fcee6e90dab">PcodeOp::isAssignment()</a>, <a class="el" href="classPcodeOp.html#a091539b02c09c885351f789b24afba7b">PcodeOp::isCall()</a>, <a class="el" href="classFlowBlock.html#a7d4fed2fcbbcb820ed3c74b55805cd4d">FlowBlock::isDead()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classBlockBasic.html#a94b8b6786b04a8cb00e5d0fc2977a675">BlockBasic::lastOp()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy()</a>, <a class="el" href="classFuncdata.html#ab34e641f5ee6f2ebf4aa708e21f2b24c">opInsertInput()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classBlockGraph.html#a566cbe393f781703c640a691e27a4f90">BlockGraph::removeBlock()</a>, <a class="el" href="classBlockGraph.html#ae61430ab00f3437f85016b0c76907e94">BlockGraph::removeFromFlow()</a>, <a class="el" href="classFuncdata.html#a2e75df713649c7bba52b17b1b84bbcf6">removeJumpTable()</a>, <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aa486c5f0556919686a9fdad4ebc2dcc1">removeDoNothingBlock()</a>, and <a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks()</a>.</p>

</div>
</div>
<a class="anchor" id="ac96af1ca8355f0c4f8e6582c045f0723"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::branchRemoveInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an outgoing branch of the given basic block. </p>
<p>MULTIEQUAL p-code ops (in other blocks) that take inputs from the outgoing branch are patched appropriately. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">num</td><td>is the index of the outgoing edge to remove </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classFlowBlock.html#ad25db558c78a70ac799b0c97719f9a68">FlowBlock::getInIndex()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classBlockBasic.html#a94b8b6786b04a8cb00e5d0fc2977a675">BlockBasic::lastOp()</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti()</a>, <a class="el" href="classBlockGraph.html#a2fe87e9f6a5a250a09869028bf1bb11d">BlockGraph::removeEdge()</a>, and <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a3a53162bf9a1756c4f2f4d7d1d7bbcec">removeBranch()</a>, and <a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks()</a>.</p>

</div>
</div>
<a class="anchor" id="aa15db3d569027578de69c065fc607c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::buildDynamicSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <em>dynamic</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>If a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is already attached, no change is made. Otherwise a special <em>dynamic</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is created that is associated with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> via a hash of its local data-flow (rather than its storage address). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">Scope::addDynamicSymbol()</a>, <a class="el" href="classDynamicHash.html#a0a0ab6f59c5ca5c98b760c20e3ebc7e2">DynamicHash::getAddress()</a>, <a class="el" href="classSymbol.html#a8a0c663667bc6d57b2b3840359937c27">Symbol::getFirstWholeMap()</a>, <a class="el" href="classDynamicHash.html#a4fd85751c6d9c3059a45ebc69c7327aa">DynamicHash::getHash()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classHighVariable.html#a9e561faf1953008ca9278e77ab6d4ca1">HighVariable::getSymbol()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classFuncdata.html#afef3b78bc9d85d2f69bf655c7d4d159f">isHighOn()</a>, <a class="el" href="classVarnode.html#ae881b2128c618bae5dbd8167622792f1">Varnode::isNameLock()</a>, <a class="el" href="classVarnode.html#a4bc8a57cabff365b49a883ebe691609e">Varnode::isTypeLock()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>, and <a class="el" href="classDynamicHash.html#a9255e5fffe4408f9e3f84a3f0847527e">DynamicHash::uniqueHash()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>, and <a class="el" href="classFuncdata.html#aa1360c1bee4b15ff97e1fbbf9a362e2c">handleSymbolConflict()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b338d2b2d1a72db73369e8631125ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::calcNZMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <em>non-zero</em> masks for all Varnodes. </p>
<p>All Varnodes are initialized assuming that all its bits are possibly non-zero. This method looks for situations where a p-code produces a value that is known to have some bits that are guaranteed to be zero. It updates the state of the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> then tries to push the information forward through the data-flow until additional changes are apparent. </p>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classFuncdata.html#a35bf301c24b9f80d75b6aeab69a544e6">beginOpAlive()</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classPcodeOp.html#aaf4ba146f90fc4550f8e5809617afae3">PcodeOp::clearMark()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classFuncdata.html#a7bc313c774c6eefd3a5925cc061e0e4e">endOpAlive()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a2c56d1d8fade0b8add97d61c1eff9b66">PcodeOp::getNZMaskLocal()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classFlowBlock.html#a6bed609b78729afd2db5534cf29f8bb4">FlowBlock::isLoopIn()</a>, <a class="el" href="classPcodeOp.html#af03aefce85152f7f638a5d87ceccc495">PcodeOp::isMark()</a>, <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae">Varnode::isSpacebase()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classVarnode.html#a845f3de9629f34de3a7a9a2ec4897f51">Varnode::nzm</a>, and <a class="el" href="classPcodeOp.html#ab2ba9f66448cd77b6f274de6fae433e2">PcodeOp::setMark()</a>.</p>

<p>Referenced by <a class="el" href="classActionNonzeroMask.html#a585181ff1ba9a3ce19de0c9e939ac381">ActionNonzeroMask::apply()</a>, and <a class="el" href="classFuncdata.html#a09fe824e6b57d5d4d861864f60c6aa5c">getActiveOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="a25609ffe02a0baf12354ca7aba00db14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::checkCallDoubleUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>opmatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;&#160;</td>
          <td class="paramname"><em>trial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for legitimate double use of a parameter trial. </p>
<p>The given trial is a <em>putative</em> input to first CALL, but can also trace its data-flow into a second CALL. Return <b>false</b> if this leads us to conclude that the trial is not a likely parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opmatch</td><td>is the first CALL linked to the trial </td></tr>
    <tr><td class="paramname">op</td><td>is the second CALL </td></tr>
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> parameter for the second CALL </td></tr>
    <tr><td class="paramname">trial</td><td>is the given parameter trial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> for a legitimate double use </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="classFuncCallSpecs.html#a32432a6c7b201dc160ae0b2480a1b8b9">FuncCallSpecs::getActiveInput()</a>, <a class="el" href="classParamTrial.html#acb74446cf877ef85c504c4145ea9ecb8">ParamTrial::getAddress()</a>, <a class="el" href="classFuncdata.html#af124852dcf002f34a811ec7c78f086f2">getCallSpecs()</a>, <a class="el" href="classFuncCallSpecs.html#a48cfa83e02add7d25f8c426e0403b308">FuncCallSpecs::getEntryAddress()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classSeqNum.html#a5ec715bfab5b56bdcf3b21cf57c0da22">SeqNum::getOrder()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classParamActive.html#aa30f49a5999d722eb46721e0f2ed5804">ParamActive::getTrialForInputVarnode()</a>, and <a class="el" href="classFuncCallSpecs.html#a535463c18ea83b3ede30b02c701d0b09">FuncCallSpecs::isInputActive()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>, and <a class="el" href="classFuncdata.html#a1347de2ecdf4bf99194abb7e11e8eb5d">onlyOpUse()</a>.</p>

</div>
</div>
<a class="anchor" id="a483d190eec54662367b015b59e245328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::checkForLanedRegister </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for a potential laned register. </p>
<p>Check if the given storage range is a potential laned register. If so, record the storage with the matching laned register record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the storage range in bytes </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the storage range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classArchitecture.html#a441f32a3cb913df6c460ab4c9375d4a9">Architecture::getLanedRegister()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a08bab1d6cdec52c3971b08237a8bfe8a">lanedMap</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a93b14d28c52d5d43e741459238dce477">endDef()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">newUnique()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, and <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut()</a>.</p>

</div>
</div>
<a class="anchor" id="ab84c0818a7e3c468def458a16d80e6bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::checkIndirectUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> only flows into call-based INDIRECT ops. </p>
<p>Flow is only followed through MULTIEQUAL ops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if all flows hit an INDIRECT op </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a7a604238b180a059aebdfb4e43f871ff">PcodeOp::isIndirectStore()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, and <a class="el" href="classVarnode.html#a98825616d50a27a615057e625a61285e">Varnode::setMark()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a41dc1e061256c4cc55e7afcf5995f435">markIndirectOnly()</a>.</p>

</div>
</div>
<a class="anchor" id="a4096b0e76e9015f9aa61fa56cb85d79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::clearDeadVarnodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete any dead Varnodes. </p>
<p>Free any Varnodes not attached to anything. This is only performed at fixed times so that editing operations can detach (and then reattach) Varnodes without losing them. </p>

<p>References <a class="el" href="classVarnodeBank.html#aadc19c865c51af69f235b0553638a8bd">VarnodeBank::beginLoc()</a>, <a class="el" href="classVarnode.html#aa975f8074f0ff6ff5fbf92437ce9f8ea">Varnode::clearCover()</a>, <a class="el" href="classVarnodeBank.html#abec625ab3cf6d593cf8edc7955e5a414">VarnodeBank::destroy()</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classVarnode.html#a80102e52045bcf6b800b82cdd8fc5c04">Varnode::isLockedInput()</a>, <a class="el" href="classVarnodeBank.html#a8020195947e2b6faea7f18f591572c47">VarnodeBank::makeFree()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a8fc0f3220ac7b0fef4613ba3666d9af9">ActionDeadCode::apply()</a>, <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>, and <a class="el" href="classFuncdata.html#a09fe824e6b57d5d4d861864f60c6aa5c">getActiveOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="adbfbb67a5176f79f221500a5c8c5d160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::clearJumpTables </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear any jump-table information. </p>
<p>Any override information is preserved. </p>

<p>References <a class="el" href="classJumpTable.html#a99d3224b0c24b9ef1140f86fe372879d">JumpTable::clear()</a>, <a class="el" href="classJumpTable.html#a6969a2de9b0fbfbcbc6d168f40866c77">JumpTable::isOverride()</a>, and <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a25b616d10d9514eda69dd9d974c62eb8">clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a5acc07e00146316532a3806cd19815bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::clearSymbolLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Symbols attached to Varnodes in the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<p>For each instance <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, remove any <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> reference and associated properties. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to clear </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a3f713f10162d1318969b44b7d585fdfc">Varnode::clearFlags()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classVarnode.html#a1e44191c7c35c94122e1a2abe49a3292">Varnode::mapentry</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0b1de824f917f0c708db4fa4b8caaeb8">Varnode::namelock</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae49e063a1b1e7de4592afd3f19abbdc7">Varnode::typelock</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>, <a class="el" href="classFuncdata.html#a73cbb6375e48cddaedf5e55e40119c84">remapDynamicVarnode()</a>, and <a class="el" href="classFuncdata.html#a6145d643e13a072975e34255a06f4e84">remapVarnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a1da8e9506c5b37fce86d165974a4cafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::cloneOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a clone of the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>, copying control-flow properties as well. The data-type is <em>not</em> cloned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to clone </td></tr>
    <tr><td class="paramname">seq</td><td>is the (possibly custom) sequence number to associate with the clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#af1a2077b443015cd83b0a8bb7d27856a">cloneVarnode()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classPcodeOp.html#ad51989ace14aa76d155b55be0f1f17a5">PcodeOp::flags</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput()</a>, <a class="el" href="classPcodeOp.html#ad54b6a60862c7a87c2beeb5934ff2359">PcodeOp::setFlag()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba87fc6777cadc38baf72c41c402042974">PcodeOp::startbasic</a>, and <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba64f1f43673312ffd240147a69006cebf">PcodeOp::startmark</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>, <a class="el" href="classFlowInfo.html#acb0b9cbb6144cd2963c63072d6d72882">FlowInfo::inlineClone()</a>, <a class="el" href="classFlowInfo.html#a5819105426192965fb0a73831a785060">FlowInfo::inlineEZClone()</a>, and <a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">truncatedFlow()</a>.</p>

</div>
</div>
<a class="anchor" id="af1a2077b443015cd83b0a8bb7d27856a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::cloneVarnode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (between copies of the function) </p>
<p>Internal factory for copying Varnodes from another <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object into <b>this</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (contained by <b>this</b>) </dd></dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cabecfcc64c4827f783e3e538b3b9dfd6c">Varnode::addrforce</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cada11eee7331d13bd3034be76475cedac">Varnode::annotation</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca01456896881c6bb4ee5840596e85f0d5">Varnode::externref</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a436419e5a1ee0e2b2467e5b543a65596">Varnode::getFlags()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae9fccd0da71d0cbf7ba0b169330dccc9">Varnode::incidental_copy</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca50b14789b3198743399e2f2f8c8116e9">Varnode::indirect_creation</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cafd8f85c37b5ee3374d865cafbaf6f7e5">Varnode::volatil</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a5027da6d3c7a05a262e332b0c22c7c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::collapseIntMultMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse constant coefficients for two chained CPUI_INT_MULT. </p>
<p>If:</p><ul>
<li>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is defined by a CPUI_INT_MULT.</li>
<li>The second input to the INT_MULT is a constant.</li>
<li>The first input is defined by another CPUI_INT_MULT,</li>
<li>This multiply is also by a constant.</li>
</ul>
<p>The constants are combined and <b>true</b> is returned. Otherwise no change is made and <b>false</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made </dd></dl>

<p>References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>.</p>

<p>Referenced by <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">AddTreeState::apply()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a4456bfc523a4527c9fd924ecadacec63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::compareCallspecs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare call specification objects by call site address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first call specification to compare </td></tr>
    <tr><td class="paramname">b</td><td>is the second call specification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first call specification should come before the second </dd></dl>

<p>References <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classFuncCallSpecs.html#a82b3a2d5f5b918348806e20d18cd0529">FuncCallSpecs::getOp()</a>, <a class="el" href="classSeqNum.html#a5ec715bfab5b56bdcf3b21cf57c0da22">SeqNum::getOrder()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, and <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>, and <a class="el" href="classFuncdata.html#a58664772693fca369a469c1540c65e2a">sortCallSpecs()</a>.</p>

</div>
</div>
<a class="anchor" id="a819b7ff38483292c7020320daa8bfdc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::coverVarnodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure every <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the given list has a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> it will link to. </p>
<p>This is used when Varnodes overlap a locked <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> but extend beyond it. An existing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is passed in with a list of possibly overextending Varnodes. The list is in <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> order. We check that each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> that overlaps its first byte (to guarantee a link). If one doesn't exist it is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the existing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry </td></tr>
    <tr><td class="paramname">list</td><td>is the list of Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">Scope::addSymbol()</a>, <a class="el" href="classScope.html#a609fc1ef47d047717da65827e025cfdd">Scope::findContainer()</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classSymbol.html#aee9da22d9d9f511694bb1eb95f5033e9">Symbol::getName()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classSymbol.html#a8604199b94cd6be318e14cf9571ad1ad">Symbol::getScope()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, and <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">mapGlobals()</a>.</p>

</div>
</div>
<a class="anchor" id="a65e8837c811e309578d2828486bcafb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::createStackRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an INT_ADD <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> calculating an offset to the <em>spacebase</em> register. </p>
<p>The <em>spacebase</em> register is looked up for the given address space, or an optional previously existing register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be provided. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">off</td><td>is the offset to calculate relative to the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">op</td><td>is the insertion point <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">stackptr</td><td>is the <em>spacebase</em> register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (if available) </td></tr>
    <tr><td class="paramname">insertafter</td><td>is <b>true</b> if new ops are inserted <em>after</em> the insertion point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>unique</em> space <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the calculated offset </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a3c9149df492bdcaccc208eac261e8365">AddrSpace::byteToAddress()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab67fab74923ce6c8be1c2254b9afb4f9">CPUI_SEGMENTOP</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classAddrSpace.html#ac0cfccb152e2d1f13cbb70e253cf69bf">AddrSpace::getAddrSize()</a>, <a class="el" href="classSegmentOp.html#a072fd33f78da43b4274f238848e81c9b">SegmentOp::getBaseSize()</a>, <a class="el" href="classAddrSpace.html#a5971d35628c019b97c34a4b90001a5f8">AddrSpace::getContain()</a>, <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, <a class="el" href="classUserOpManage.html#aa1dbe04df9b6ce94bb2e82b1d201e0c0">UserOpManage::getSegmentOp()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classAddrSpace.html#a2a3d94aea39c4fc962e493b81452afe8">AddrSpace::getWordSize()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#ac083b7d6637a5883ef8cbd38e7756837">newSpacebasePtr()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">newVarnodeSpace()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">Architecture::userops</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, <a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore()</a>, and <a class="el" href="classFuncdata.html#a65cb6cda676ceb9a33f8e6eef9e1e962">target()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ab8607ddd18885dfa6732df8d4057e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::deadRemovalAllowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if dead code removal is allowed for a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the specific address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if dead code removal is allowed </dd></dl>

<p>References <a class="el" href="classHeritage.html#a323a0931e4aec896e41751c4569f22f4">Heritage::deadRemovalAllowed()</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a8fc0f3220ac7b0fef4613ba3666d9af9">ActionDeadCode::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="adba7696040378f0eaa679e684b72bf96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::deadRemovalAllowedSeen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if dead Varnodes have been removed for a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the specific address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if dead code removal has happened in the space </dd></dl>

<p>References <a class="el" href="classHeritage.html#a2bbf92b2085d45de9f3920824a51786c">Heritage::deadRemovalAllowedSeen()</a>.</p>

<p>Referenced by <a class="el" href="classRuleEarlyRemoval.html#a8409f6b8ffe4ba8b6f59140b6da58d12">RuleEarlyRemoval::applyOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a08706f8fc71e5634d032d1315705b613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::deleteCallSpecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the specification for a particular call. </p>
<p>This is used internally if a CALL is removed (because it is unreachable) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the particular specification to remove </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a82b3a2d5f5b918348806e20d18cd0529">FuncCallSpecs::getOp()</a>, and <a class="el" href="classFuncdata.html#aa8e08833a58a93938d74fb0775e13c2e">qlst</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0d6d87b91d72d3695a4da052e60ee58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::descend2Undef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform all reads of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to a special <b>undefined</b> constant. </p>
<p>All p-code ops that read the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> are transformed so that they read a special constant instead (associate with unreachable block removal). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is modified </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classFlowBlock.html#a7d4fed2fcbbcb820ed3c74b55805cd4d">FlowBlock::isDead()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#ad544a6136ff019bbd18c45043e9b6900">opInsertEnd()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, and <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>.</p>

</div>
</div>
<a class="anchor" id="a18fcb354b9f1dda46f197335431d7ef2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::descendantsOutside </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has any descendants in a dead block. </p>
<p>Assuming a basic block is marked <em>dead</em>, return <b>true</b> if any <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> reading the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is in the dead block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is read in the dead block </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, and <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>.</p>

</div>
</div>
<a class="anchor" id="a6aaece008a9aff77bc2e7acae325c992"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::destroyVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from <b>this</b> function. </p>
<p>References to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> are replaced with NULL pointers and the object is freed, with no possibility of resuse. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to delete </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classPcodeOp.html#af39d326c490655910e2048eb048b0fa6">PcodeOp::clearInput()</a>, <a class="el" href="classVarnode.html#acc09b302ce6aafdb6c7264b55a68d13a">Varnode::def</a>, <a class="el" href="classVarnodeBank.html#abec625ab3cf6d593cf8edc7955e5a414">VarnodeBank::destroy()</a>, <a class="el" href="classVarnode.html#a30b2edc16ce03cc3df3439cbdd0887aa">Varnode::destroyDescend()</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classPcodeOp.html#a965b9f3be5f7c3df2ed4b71aa83dbf04">PcodeOp::setOutput()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy()</a>, and <a class="el" href="classFuncdata.html#aeef2a6be0e9c641f72bf4e87020ddf37">opDestroyRaw()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b94fb7b2f8e72df053f4d09d48cdf7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::distributeIntMultAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distribute constant coefficient to additive input. </p>
<p>If a term has a multiplicative coefficient, but the underlying term is still additive, in some situations we may need to distribute the coefficient before simplifying further. The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is a INT_MULT where the second input is a constant. We also know the first input is formed with INT_ADD. Distribute the coefficient to the INT_ADD inputs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the action was performed </dd></dl>

<p>References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>.</p>

<p>Referenced by <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">AddTreeState::apply()</a>, <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="adb1dd79d78141f89d374e570de21d690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::doLiveInject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classInjectPayload.html">InjectPayload</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject p-code from a <em>payload</em> into <b>this</b> live function. </p>
<p>Raw PcodeOps are generated from the payload within a given basic block at a specific position in <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>is the injection payload </td></tr>
    <tr><td class="paramname">addr</td><td>is the address at the point of injection </td></tr>
    <tr><td class="paramname">bl</td><td>is the given basic block holding the new ops </td></tr>
    <tr><td class="paramname">iter</td><td>indicates the point of insertion </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpBank.html#acc4e2cf26d777465eddce69e9489103f">PcodeOpBank::beginDead()</a>, <a class="el" href="classPcodeOpBank.html#a3440727d10a26a9cbf401b5933620fbb">PcodeOpBank::endDead()</a>, <a class="el" href="classPcodeInjectLibrary.html#a3a1ca9f7ea2cea02de1141cc35c79b18">PcodeInjectLibrary::getCachedContext()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classInjectPayload.html#aca9c322377f54e8e45c9a79e44ce0ff9">InjectPayload::inject()</a>, <a class="el" href="classPcodeOp.html#afcdf7705868673c3288401383fb8c629">PcodeOp::isCallOrBranch()</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, <a class="el" href="classFuncdata.html#a6b77ee6442d79ae754d5dcf0b5318fca">opInsert()</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">Architecture::pcodeinjectlib</a>, and <a class="el" href="classPcodeEmitFd.html#ae05c7896ce87a2b2cddb2e9ec78c06aa">PcodeEmitFd::setFuncdata()</a>.</p>

<p>Referenced by <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncCallSpecs.html#aae6a890aaa82deca59ec7c57c92629aa">FuncCallSpecs::insertPcode()</a>.</p>

</div>
</div>
<a class="anchor" id="a142938fffbfd5add2b6679a6b9b0d7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Funcdata::fillinExtrapop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover and return the <em>extrapop</em> for this function. </p>
<p>If <em>extrapop</em> is unknown, recover it from what we know about this function and set the value permanently for <b>this</b> <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object. If there is no function body it may be impossible to know the value, in which case this returns the reserved value indicating <em>extrapop</em> is unknown.</p>
<dl class="section return"><dt>Returns</dt><dd>the recovered value </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a7638ebccbc3caf1d196675ca882881da">beginOp()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classFuncdata.html#a229d522e177d1bb32453d8a060c16cb9">endOp()</a>, <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncProto.html#a92ce1430cfc4d82aea46aa0fdc4ca7a7">FuncProto::getExtraPop()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a58a54cc73ea882bf0e829a6ee090070a">hasNoCode()</a>, <a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">Architecture::loader</a>, <a class="el" href="classLoadImage.html#af00d3957284bf0b4721be0ada5ef4328">LoadImage::loadFill()</a>, and <a class="el" href="classFuncProto.html#af32fa24642ff5423ec167e6f8bca065a">FuncProto::setExtraPop()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#af124852dcf002f34a811ec7c78f086f2">getCallSpecs()</a>.</p>

</div>
</div>
<a class="anchor" id="af47b9524aee42c71c7dbe260a4052485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::fillinReadOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with its (constant) value in the load image. </p>
<p>Treat the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as read-only, look up its value in <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image. ">LoadImage</a> and replace read references with the value as a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if any change was made </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classVarnode.html#a3f713f10162d1318969b44b7d585fdfc">Varnode::clearFlags()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classAddrSpace.html#a9a1077feee89cf4434154e017a3360f5">AddrSpace::getName()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a254f805a8eceaabd170b3e4c24b08987">Varnode::isAddrForce()</a>, <a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">AddrSpace::isBigEndian()</a>, <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>, <a class="el" href="classVarnode.html#a4bc8a57cabff365b49a883ebe691609e">Varnode::isTypeLock()</a>, <a class="el" href="classPcodeOp.html#aa1da210e35d0ca273fd6f703282b73e2">PcodeOp::isWarning()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classArchitecture.html#a344b1348ed8f0bbe0d050e7038bb290d">Architecture::loader</a>, <a class="el" href="classLoadImage.html#af00d3957284bf0b4721be0ada5ef4328">LoadImage::loadFill()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classAddress.html#a040ac0edbb01bd26c8956130ec4ef20e">Address::printRaw()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classPcodeOp.html#aa5a81e58af666d0381fffdc845b61eaa">PcodeOp::setAdditionalFlag()</a>, <a class="el" href="classVarnode.html#a48932e5bf8aab53ae9b3a6a6d9b25ce8">Varnode::updateType()</a>, <a class="el" href="classPcodeOp.html#a349007611576c9266b5bd0cee4b7a073ad0c2a7bf3fde8d18421ea4e55c61602d">PcodeOp::warning</a>, and <a class="el" href="classFuncdata.html#a1c52c01a921d0ec70e263f0acba1344b">warning()</a>.</p>

<p>Referenced by <a class="el" href="classActionVarnodeProps.html#a531c9985eb2e6a5796009bea79a465fe">ActionVarnodeProps::apply()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fa322f9e049a4142ca02ed0ea37445e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findCoveredInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> covered by the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the range in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the starting address of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#ae0086d7c87123538b43d2e066022204a">VarnodeBank::findCoveredInput()</a>.</p>

<p>Referenced by <a class="el" href="classActionLikelyTrash.html#afbd2ec1783db1f08cedf5b259304f158">ActionLikelyTrash::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9abb8f1e1cadad50f10f47ceb5c77ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findCoveringInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that contains the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the range in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the starting address of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#ab258194df409e09495378455c0d868ff">VarnodeBank::findCoveringInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a17e49052fa778084431a6b744cc388cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> Funcdata::findDisjointCover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find range covering given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and any intersecting Varnodes. </p>
<p>Find the minimal <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> range covering the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that doesn't split other Varnodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">sz</td><td>is used to pass back the size of the resulting range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the starting address of the resulting range </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a6057f2bc7180ba1232bfd80f5c1f8c21">beginLoc()</a>, <a class="el" href="classFuncdata.html#ac26dd8e3e8bad84b79a9a452bd953d8f">endLoc()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, and <a class="el" href="classVarnode.html#a65818df3de48c5068250a72b9f7e9618">Varnode::lociter</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aa8657c4c04279316593adc6d2f389be5">deleteVarnode()</a>, <a class="el" href="classFuncProto.html#a33463f351b0ebc8c8f6065eff896dbc3">FuncProto::updateInputNoTypes()</a>, and <a class="el" href="classFuncProto.html#ae89afc199ba2c4c8261dac381c5e426b">FuncProto::updateInputTypes()</a>.</p>

</div>
</div>
<a class="anchor" id="a769d82ef92ae5cf03ebdf053f48b1871"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHighVariable.html">HighVariable</a> * Funcdata::findHigh </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a high-level variable by name. </p>
<p>Look up the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> visible in <b>this</b> function's <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> and return the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> associated with it. If the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> doesn't exist or there is no <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding at least part of the value of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> or NULL </dd></dl>

<p>References <a class="el" href="classFuncdata.html#ae4c3a8ce85301740b1bda1cb5e0b4eb4">findLinkedVarnode()</a>, <a class="el" href="classSymbol.html#a8a0c663667bc6d57b2b3840359937c27">Symbol::getFirstWholeMap()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, and <a class="el" href="classScope.html#a04a2a9e084183e6ec689e1ac5ca6d119">Scope::queryByName()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a925018ca0152e89fd099aba761bb2b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::findJumpTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a jump-table associated with a given BRANCHIND. </p>
<p>Look up the jump-table object with the matching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching jump-table object or NULL </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classJumpTable.html#a07eb62a61682bc9d3eeefcf85d6c147b">JumpTable::getOpAddress()</a>, and <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a8fc0f3220ac7b0fef4613ba3666d9af9">ActionDeadCode::apply()</a>, <a class="el" href="classRuleSwitchSingle.html#ab884de26def65edb9ade3b981c6983e1">RuleSwitchSingle::applyOp()</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classFlowInfo.html#a6ddd1ab00df8fb55a1d8b9cbe52beb41">FlowInfo::collectEdges()</a>, <a class="el" href="classFuncdata.html#add6bcc6efff0daefdcc48ee11e743121">endOp()</a>, and <a class="el" href="classFlowBlock.html#ae6a6a0066320552bee82be1011878049">FlowBlock::getJumptable()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4c3a8ce85301740b1bda1cb5e0b4eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::findLinkedVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> matching the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> mapping. </p>
<p>Return the (first) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that matches the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or null </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#aadc19c865c51af69f235b0553638a8bd">VarnodeBank::beginLoc()</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classDynamicHash.html#ad3428d1e0ef5ea4f535dc4bb6ed1c6d0">DynamicHash::findVarnode()</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classSymbolEntry.html#aa30077363e5701d11b7b4a28cfbd676a">SymbolEntry::getFirstUseAddress()</a>, <a class="el" href="classSymbolEntry.html#a103561fd1adde2a47e3396eb70457373">SymbolEntry::getHash()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>, <a class="el" href="classSymbolEntry.html#a37c0ef6873abc90568803ba9cc68fc2d">SymbolEntry::inUse()</a>, <a class="el" href="classVarnode.html#a6af4eb0fdeaeb2711401e8d6afc1d92f">Varnode::isAddrTied()</a>, <a class="el" href="classVarnode.html#af7d640b593a55ac3eb63fa7322fb8a2a">Varnode::isAnnotation()</a>, <a class="el" href="classSymbolEntry.html#abbcbc3ceb8fd7e3f9e31070665343772">SymbolEntry::isDynamic()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>, and <a class="el" href="classFuncdata.html#a769d82ef92ae5cf03ebdf053f48b1871">findHigh()</a>.</p>

</div>
</div>
<a class="anchor" id="a7eaa3b8e623f20629b247500809b8e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::findLinkedVarnodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Varnodes that map to the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>. </p>
<p>Look for Varnodes that are (should be) mapped to the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> and add them to the end of the result list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> to match </td></tr>
    <tr><td class="paramname">res</td><td>is the container holding the result list of matching Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a6057f2bc7180ba1232bfd80f5c1f8c21">beginLoc()</a>, <a class="el" href="classFuncdata.html#ac26dd8e3e8bad84b79a9a452bd953d8f">endLoc()</a>, <a class="el" href="classDynamicHash.html#ad3428d1e0ef5ea4f535dc4bb6ed1c6d0">DynamicHash::findVarnode()</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classSymbolEntry.html#aa30077363e5701d11b7b4a28cfbd676a">SymbolEntry::getFirstUseAddress()</a>, <a class="el" href="classSymbolEntry.html#a103561fd1adde2a47e3396eb70457373">SymbolEntry::getHash()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>, <a class="el" href="classSymbolEntry.html#a37c0ef6873abc90568803ba9cc68fc2d">SymbolEntry::inUse()</a>, and <a class="el" href="classSymbolEntry.html#abbcbc3ceb8fd7e3f9e31070665343772">SymbolEntry::isDynamic()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>.</p>

</div>
</div>
<a class="anchor" id="ac24286ca987a0d110daa493283f7e5ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::findPrimaryBranch </td>
          <td>(</td>
          <td class="paramtype">PcodeOpTree::const_iterator&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PcodeOpTree::const_iterator&#160;</td>
          <td class="paramname"><em>enditer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>findbranch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>findcall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>findreturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the primary branch operation for an instruction. </p>
<p>For machine instructions that branch, this finds the <em>primary</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> that performs the branch. The instruction is provided as a list of p-code ops, and the caller can specify whether they expect to see a <em>branch</em>, <em>call</em>, or <em>return</em> operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>is the start of the operations for the instruction </td></tr>
    <tr><td class="paramname">enditer</td><td>is the end of the operations for the instruction </td></tr>
    <tr><td class="paramname">findbranch</td><td>is <b>true</b> if the caller expects to see a BRANCH, CBRANCH, or BRANCHIND </td></tr>
    <tr><td class="paramname">findcall</td><td>is <b>true</b> if the caller expects to see CALL or CALLIND </td></tr>
    <tr><td class="paramname">findreturn</td><td>is <b>true</b> if the caller expects to see RETURN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first branching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> that matches the criteria or NULL </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a8e04ce6913869e8db2eaf101ae59ed9e">CPUI_BRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, and <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow()</a>.</p>

</div>
</div>
<a class="anchor" id="a1266d6947e34a797a45fe9af904674db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::findSpacebaseInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an address space, like <em>stack</em>, that is known to have a base register pointing to it, try to locate the unique <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that holds the input value of this register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the <em>stack</em> like address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (or NULL if it doesn't exist) </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#accecb099ab9ef07277fe50a0431410db">VarnodeBank::findInput()</a>, <a class="el" href="classAddrSpace.html#a3b16390dfa556c9bdd6fe5b31448f7d7">AddrSpace::getSpacebase()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionInferTypes.html#a0f50c538353ecf22ba3651d8e1a661ed">ActionInferTypes::apply()</a>, <a class="el" href="classAliasChecker.html#a1d0d0e17fb05998e0f802ef3c409d240">AliasChecker::gatherInternal()</a>, and <a class="el" href="classFuncdata.html#a287bc196bb5fa26fb1a8197a1e4c6eca">hasBadData()</a>.</p>

</div>
</div>
<a class="anchor" id="aac1d883e2784d22d7762067ab89172ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findVarnodeInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with the given size and storage address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the storage address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#accecb099ab9ef07277fe50a0431410db">VarnodeBank::findInput()</a>.</p>

<p>Referenced by <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>, and <a class="el" href="classActionRestrictLocal.html#acd58fcc24c2a2c8f7dc0d07e3d2c9cfc">ActionRestrictLocal::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bd231188e4e98becd06f0c97c66bd6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findVarnodeWritten </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintm&#160;</td>
          <td class="paramname"><em>uniq</em> = <code>~((uintm)0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a defined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> via its storage address and its definition address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the storage address </td></tr>
    <tr><td class="paramname">pc</td><td>is the address where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is defined </td></tr>
    <tr><td class="paramname">uniq</td><td>is an (optional) sequence number to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#a9c1d3e085b8d0f48d3a2cc93536611fc">VarnodeBank::find()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c8f8e90f70db000a97d80677cdb133b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::followFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>baddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>eaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate raw p-code for the function. </p>
<p>Follow flow from the entry point generating PcodeOps for each instruction encountered. The caller can provide a bounding range that constrains where control can flow to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baddr</td><td>is the beginning of the constraining range </td></tr>
    <tr><td class="paramname">eaddr</td><td>is the end of the constraining range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092baf70cf08c91a86b24670af34fb10b9743">baddata_present</a>, <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092baa5c01d2784c4599efd6b866439a2700c">blocks_generated</a>, <a class="el" href="classPcodeOpBank.html#a2a86c7b123691edbe60ba64aef82e770">PcodeOpBank::empty()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classArchitecture.html#a4ed18744b8dc08d3ca81d6b1b6df682e">Architecture::flowoptions</a>, <a class="el" href="classFlowInfo.html#a5c8f51cb6c88719657801a2f26e87fae">FlowInfo::generateBlocks()</a>, <a class="el" href="classFlowInfo.html#afe680152d016a3ec80e155f3ea85f26c">FlowInfo::generateOps()</a>, <a class="el" href="classFlowInfo.html#ad0e5386204dd24103165ec3a6ab5d01d">FlowInfo::getSize()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFlowInfo.html#a7de109909b637627000e8107fc9e0e12">FlowInfo::hasBadData()</a>, <a class="el" href="classFlowInfo.html#abba75bd60e8d10f6908531ea9d6a8e60">FlowInfo::hasUnimplemented()</a>, <a class="el" href="classArchitecture.html#a62133c1da5720b0624c4535d6e6fdc82">Architecture::max_instructions</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, <a class="el" href="classFuncdata.html#aa8e08833a58a93938d74fb0775e13c2e">qlst</a>, <a class="el" href="classFlowInfo.html#a6cc4d42953d1d3106e1cf1938c97f977">FlowInfo::setFlags()</a>, <a class="el" href="classFlowInfo.html#a2c8d88b187068f322a2bd8717c0e0ead">FlowInfo::setMaximumInstructions()</a>, <a class="el" href="classFlowInfo.html#a4d268b911548180e9b86f4551d306477">FlowInfo::setRange()</a>, <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, <a class="el" href="classFuncdata.html#a307d12e7da23cd0c737549da4ff6679b">switchOverJumpTables()</a>, and <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba6f29561045e40ba06b194b78eaeae9df">unimplemented_present</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">startProcessing()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9b35091642dc7527a537d01db5ad7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::forceGoto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pcop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pcdest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a specific control-flow edge to be marked as <em>unstructured</em>. </p>
<p>The edge is specified by a source and destination <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> (of the branch). The resulting control-flow structure will have a <em>goto</em> statement modeling the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcop</td><td>is the source <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">pcdest</td><td>is the destination <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a control-flow edge was successfully labeled </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classBlockGraph.html#a8a8163564a0e9217cab5f085eab2684e">BlockGraph::getBlock()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classBlockGraph.html#aeb99315362f322e25d56e01ed8ac35e0">BlockGraph::getSize()</a>, <a class="el" href="classFlowBlock.html#a0bacaa3fdcb2a1724bf67bda5e1b9a4e">FlowBlock::lastOp()</a>, <a class="el" href="classFlowBlock.html#a50ac469ba63c50f574bf05f18a307f8c">FlowBlock::setGotoBranch()</a>, and <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>.</p>

<p>Referenced by <a class="el" href="classOverride.html#a2e9b333aec664903635b892dc4bdca04">Override::applyForceGoto()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="ac77670b6440a935ce96b43b4f60c3730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::getFirstReturnOp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> into <b>this</b> function. </p>
<p>Return the first CPUI_RETURN operation that is not dead or an artificial halt </p><dl class="section return"><dt>Returns</dt><dd>a representative CPUI_RETURN op or NULL if there are none </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a7638ebccbc3caf1d196675ca882881da">beginOp()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classFuncdata.html#a229d522e177d1bb32453d8a060c16cb9">endOp()</a>, <a class="el" href="classPcodeOp.html#a4dea8b1b9e9b0d40ecd0cbf9954790f8">PcodeOp::getHaltType()</a>, and <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>.</p>

<p>Referenced by <a class="el" href="classActionOutputPrototype.html#a1ed1275253a29c1d09d2383c00e34a9c">ActionOutputPrototype::apply()</a>, <a class="el" href="classPrintC.html#a037bdd9a25c0bb21308609afde6452d3">PrintC::emitPrototypeOutput()</a>, and <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1360c1bee4b15ff97e1fbbf9a362e2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Funcdata::handleSymbolConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle two variables with matching storage. </p>
<p>A <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> overlaps the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>. Make sure the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is part of the variable underlying the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. If not, remap things so that the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> maps to a distinct <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. In either case, attach the appropriate <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the overlapping <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> attached to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a6057f2bc7180ba1232bfd80f5c1f8c21">beginLoc()</a>, <a class="el" href="classFuncdata.html#aa15db3d569027578de69c065fc607c63">buildDynamicSymbol()</a>, <a class="el" href="classFuncdata.html#ac26dd8e3e8bad84b79a9a452bd953d8f">endLoc()</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classVarnode.html#a8fe4e23fbb7a0ac661704930a48bdaf2">Varnode::getSymbolEntry()</a>, <a class="el" href="classVarnode.html#a6af4eb0fdeaeb2711401e8d6afc1d92f">Varnode::isAddrTied()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classSymbolEntry.html#abbcbc3ceb8fd7e3f9e31070665343772">SymbolEntry::isDynamic()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classVarnode.html#aa3f603299bd7de14e1cef73e32981f84">Varnode::isPersist()</a>, and <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">linkSymbol()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6e69e58827608e30fa99e143f939527"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::hasRestartPending </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does <b>this</b> function need to restart its analysis. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if analysis should be restarted </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba45ce5472ffe09854b56f87436062982c">restart_pending</a>.</p>

<p>Referenced by <a class="el" href="classActionRestartGroup.html#ab597697ab15a9b8f1a25832f43bdeb0d">ActionRestartGroup::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a06b05652e37659c8fc66ec02b2a058a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::hasUnimplemented </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does <b>this</b> function have instructions marked as <em>unimplemented</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the function's body contains at least one unimplemented instruction </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba6f29561045e40ba06b194b78eaeae9df">unimplemented_present</a>.</p>

</div>
</div>
<a class="anchor" id="ae454fbd3566fbd43103dcabdf2681fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::initActiveOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize <em>return</em> prototype recovery analysis </p>

<p>References <a class="el" href="classFuncdata.html#a1bc3032e37a3ab0db1d35aee82ebe4f4">activeoutput</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classFuncProto.html#a293543ad3d0de9d6f13489acb0f4cf5b">FuncProto::getMaxOutputDelay()</a>, and <a class="el" href="classParamActive.html#ad4a9012547b34e47de3645ad5e062f4f">ParamActive::setMaxPass()</a>.</p>

<p>Referenced by <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, and <a class="el" href="classFuncdata.html#ae9a7d002d5a170507285c0556f45a95c">getFuncProto()</a>.</p>

</div>
</div>
<a class="anchor" id="a3bcc11dc2a2eefa48bc4b244094a521f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::inlineFlow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>inlinefd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowInfo.html">FlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>callop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-line the p-code from another function into <b>this</b> function. </p>
<p>Raw PcodeOps for the in-line function are generated and then cloned into <b>this</b> function. Depending on the control-flow complexity of the in-line function, the PcodeOps are injected as if they are all part of the call site address (EZModel), or the PcodeOps preserve their address and extra branch instructions are inserted to integrate control-flow of the in-line into the calling function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inlinefd</td><td>is the function to in-line </td></tr>
    <tr><td class="paramname">flow</td><td>is the flow object being injected </td></tr>
    <tr><td class="paramname">callop</td><td>is the site of the injection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the injection was successful </dd></dl>

<p>References <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classFlowInfo.html#a4ff33227c3522fd6108b1fd4008ac74c">FlowInfo::checkEZModel()</a>, <a class="el" href="classArchitecture.html#a5cb912926505aad414d6054071a9e8d8">Architecture::clearAnalysis()</a>, <a class="el" href="classPcodeOp.html#a69ba7c0598d5d45876b8a2c02754e5db">PcodeOp::clearFlag()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a8e04ce6913869e8db2eaf101ae59ed9e">CPUI_BRANCH</a>, <a class="el" href="classPcodeOpBank.html#a3440727d10a26a9cbf401b5933620fbb">PcodeOpBank::endDead()</a>, <a class="el" href="classFlowInfo.html#a3c397df76e4f7124bac4929736d56efcae0f754081ade3178cf53426e2189cfac">FlowInfo::error_outofbounds</a>, <a class="el" href="classFlowInfo.html#a3c397df76e4f7124bac4929736d56efca05fc1972b52ac192b30dfea8c2f4d2c7">FlowInfo::error_reinterpreted</a>, <a class="el" href="classFlowInfo.html#a3c397df76e4f7124bac4929736d56efca5fd70506bccfcdb97b9c714be668a51a">FlowInfo::error_unimplemented</a>, <a class="el" href="classFlowInfo.html#a3c397df76e4f7124bac4929736d56efca87e8c8e18649576cb22d8285f5a6ebb8">FlowInfo::flow_forinline</a>, <a class="el" href="classFlowInfo.html#a47f656fb99cdb06587c0e86d86a6ff84">FlowInfo::forwardRecursion()</a>, <a class="el" href="classFlowInfo.html#afe680152d016a3ec80e155f3ea85f26c">FlowInfo::generateOps()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncdata.html#a91233c941630a3194e8287206314bb1e">getAddress()</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">getArch()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classPcodeOpBank.html#aa7244342aa0738ce867f31312177b01c">PcodeOpBank::getUniqId()</a>, <a class="el" href="classFlowInfo.html#acb0b9cbb6144cd2963c63072d6d72882">FlowInfo::inlineClone()</a>, <a class="el" href="classFlowInfo.html#a5819105426192965fb0a73831a785060">FlowInfo::inlineEZClone()</a>, <a class="el" href="classPcodeOp.html#af8bd5efe5a567b6145b5b760c672c7a4">PcodeOp::isBlockStart()</a>, <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>, <a class="el" href="classPcodeOpBank.html#a64514bb8cab2719f46a03dfe9c7b7a59">PcodeOpBank::moveSequenceDead()</a>, <a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">newCodeRef()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, <a class="el" href="classFuncdata.html#aeef2a6be0e9c641f72bf4e87020ddf37">opDestroyRaw()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFuncdata.html#aa8e08833a58a93938d74fb0775e13c2e">qlst</a>, <a class="el" href="classPcodeOp.html#ad54b6a60862c7a87c2beeb5934ff2359">PcodeOp::setFlag()</a>, <a class="el" href="classFlowInfo.html#a6cc4d42953d1d3106e1cf1938c97f977">FlowInfo::setFlags()</a>, <a class="el" href="classFlowInfo.html#a4d268b911548180e9b86f4551d306477">FlowInfo::setRange()</a>, <a class="el" href="classPcodeOpBank.html#a598db9267369f9dbe7d044ac3dbb03e9">PcodeOpBank::setUniqId()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba87fc6777cadc38baf72c41c402042974">PcodeOp::startbasic</a>, and <a class="el" href="classFlowInfo.html#a7ce3b6b33fb219117c69700e32b0c1ef">FlowInfo::testHardInlineRestrictions()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFlowInfo.html#acb9af75f86b31b5fca17c148bdb97664">FlowInfo::inlineSubFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a337a544e372368eb5c41b1bb5e410932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::installJumpTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a new jump-table for the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<p>The given address must have a BRANCHIND op attached to it. This is suitable for installing an override and must be called before flow has been traced. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new jump-table object </dd></dl>

<p>References <a class="el" href="classJumpTable.html#a07eb62a61682bc9d3eeefcf85d6c147b">JumpTable::getOpAddress()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a4810aa4367461ca77770e9822c918e7e">isProcStarted()</a>, and <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#add6bcc6efff0daefdcc48ee11e743121">endOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a803cbb38fe59825f59858a16afa54b7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::isHeritaged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has been linked in fully to the syntax tree (SSA) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is fully linked </dd></dl>

<p>References <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, and <a class="el" href="classHeritage.html#a431e524dcdc8abbef3d6755023d5eee9">Heritage::heritagePass()</a>.</p>

<p>Referenced by <a class="el" href="funcdata_8hh.html#ae9a4fb024ff5b75071188b12a9bcdce0">cseEliminateList()</a>.</p>

</div>
</div>
<a class="anchor" id="a512f5823b1a33e9430584067d77a52c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::linkJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link jump-table with a given BRANCHIND. </p>
<p>Look up the jump-table object with the matching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> address, then attach the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching jump-table object or NULL </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classJumpTable.html#a07eb62a61682bc9d3eeefcf85d6c147b">JumpTable::getOpAddress()</a>, <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>, and <a class="el" href="classJumpTable.html#a999b901e638cfc2243b0e7578355c662">JumpTable::setIndirectOp()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#add6bcc6efff0daefdcc48ee11e743121">endOp()</a>, <a class="el" href="classFuncdata.html#a38d58c33cdc77c663fceb7de1f6aadeb">recoverJumpTable()</a>, and <a class="el" href="classFlowInfo.html#a1dfee676f3cdf672f8fa1f40d39e1f88">FlowInfo::xrefInlinedBranch()</a>.</p>

</div>
</div>
<a class="anchor" id="afbb3bc5ac9e2c09eda544db34b8f5879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Funcdata::linkSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find or create <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is really attached to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>'s <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> (which must exist). The only reason a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> doesn't get set is if, the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> is global and there is no pre-existing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. (see <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f" title="Make sure there is a Symbol entry for all global Varnodes. ">mapGlobals()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> or NULL </dd></dl>

<p>References <a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">Scope::addSymbol()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classHighVariable.html#a9e561faf1953008ca9278e77ab6d4ca1">HighVariable::getSymbol()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>, <a class="el" href="classFuncdata.html#aa1360c1bee4b15ff97e1fbbf9a362e2c">handleSymbolConflict()</a>, <a class="el" href="classVarnode.html#aa3f603299bd7de14e1cef73e32981f84">Varnode::isPersist()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classScope.html#a81a607e1ba8c2cc85a14b84a1c86944e">Scope::queryProperties()</a>, and <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>, and <a class="el" href="classActionNameVars.html#a53a91b4664d417c962c55a34515d60a7">ActionNameVars::linkSymbols()</a>.</p>

</div>
</div>
<a class="anchor" id="a736351e8eb6c044fe00deb0cf7e6b5c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Funcdata::linkSymbolReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover and attach <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a constant reference. </p>
<p>A reference to a symbol (i.e. &amp;varname) is typically stored as a PTRSUB operation, where the first input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a <em>spacebase</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> indicating whether the symbol is on the <em>stack</em> or at a <em>global</em> RAM location. The second input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a constant encoding the address of the symbol. This method takes this constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, recovers the symbol it is referring to, and stores on the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> object attached to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (second input) to a PTRSUB operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the symbol being referred to or null </dd></dl>

<p>References <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classTypeSpacebase.html#a5f814322a8d486d8332945eaaf7a7a10">TypeSpacebase::getAddress()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classTypeSpacebase.html#aa8ac06640ee8c75453c37198b69cf39d">TypeSpacebase::getMap()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classSymbolEntry.html#ac4d58016d6b5561cc943b5ff53121c33">SymbolEntry::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classTypePointer.html#a04f379ef83d6214d25c212d57d28dfaf">TypePointer::getPtrTo()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>, <a class="el" href="classScope.html#a658cdbd473ad897981a48f4b41584aaf">Scope::queryContainer()</a>, <a class="el" href="classVarnode.html#a88c2ef4426bde6337bca4940c7943d67">Varnode::setSymbolReference()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fae8e2fb69af09eb8907e86b16ff585324">TYPE_SPACEBASE</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>, and <a class="el" href="classActionNameVars.html#a7fb21e7dafb25989556344b59c53c105">ActionNameVars::linkSpacebaseSymbol()</a>.</p>

</div>
</div>
<a class="anchor" id="aed6aefa7321e887e3b759de94e4d3d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::mapGlobals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure there is a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry for all global Varnodes. </p>
<p>Search for <em>addrtied</em> Varnodes whose storage falls in the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, then build a new global <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> if one didn't exist before. </p>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">Scope::addSymbol()</a>, <a class="el" href="classVarnodeBank.html#aadc19c865c51af69f235b0553638a8bd">VarnodeBank::beginLoc()</a>, <a class="el" href="classScope.html#a925baecb33b6f0d9212e42c1b48a64ba">Scope::buildVariableName()</a>, <a class="el" href="classFuncdata.html#a819b7ff38483292c7020320daa8bfdc0">coverVarnodes()</a>, <a class="el" href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">Scope::discoverScope()</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a8fe4e23fbb7a0ac661704930a48bdaf2">Varnode::getSymbolEntry()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classVarnode.html#aa3f603299bd7de14e1cef73e32981f84">Varnode::isPersist()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classScope.html#a81a607e1ba8c2cc85a14b84a1c86944e">Scope::queryProperties()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classActionMapGlobals.html#a8d9376bd7f1d026c922f20f4b069e739">ActionMapGlobals::apply()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a90af6702bb2cf33ecc7dee059b6e3eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::markIndirectCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>possibleOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert CPUI_INDIRECT into an <em>indirect</em> <em>creation</em>. </p>
<p>Data-flow through the given CPUI_INDIRECT op is marked so that the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is considered <em>indirectly</em> <em>created</em>. An <em>indirectly</em> <em>created</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> effectively has no data-flow before the INDIRECT op that defines it, and the value contained by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not explicitly calculable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indop</td><td>is the given CPUI_INDIRECT op </td></tr>
    <tr><td class="paramname">possibleOutput</td><td>is <b>true</b> if INDIRECT should be marked as a possible call output </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#ad51989ace14aa76d155b55be0f1f17a5">PcodeOp::flags</a>, <a class="el" href="classVarnode.html#aafb83bc78aa8285d2146b3eba501c515">Varnode::flags</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bbaebf947b1f15fc32e702ed9f9ae07406d">PcodeOp::indirect_creation</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca50b14789b3198743399e2f2f8c8116e9">Varnode::indirect_creation</a>, and <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>.</p>

<p>Referenced by <a class="el" href="classActionLikelyTrash.html#afbd2ec1783db1f08cedf5b259304f158">ActionLikelyTrash::apply()</a>, <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>, and <a class="el" href="classTransformManager.html#a210cfbbeb55d7f1194e5251849a79d0e">TransformManager::specialHandling()</a>.</p>

</div>
</div>
<a class="anchor" id="a41dc1e061256c4cc55e7afcf5995f435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::markIndirectOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark <em>illegal</em> <em>input</em> Varnodes used only in INDIRECTs. </p>
<p>The illegal inputs are additionally marked as <b>indirectonly</b> and isIndirectOnly() returns <b>true</b>. </p>

<p>References <a class="el" href="classFuncdata.html#a1ca1dc303bc6db2a50647b08958dd165">beginDef()</a>, <a class="el" href="classFuncdata.html#ab84c0818a7e3c468def458a16d80e6bf">checkIndirectUse()</a>, <a class="el" href="classFuncdata.html#a8bc16f8b732e1ba5ff667e8620298ae7">endDef()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6cf5a81c518255d279def65267974e8a">Varnode::indirectonly</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca9c9363556459d8828a5ab58c370ccd2e">Varnode::input</a>, <a class="el" href="classVarnode.html#a6b910e0f81ed517912e7cf9b1b61d782">Varnode::isIllegalInput()</a>, and <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>.</p>

<p>Referenced by <a class="el" href="classActionMarkIndirectOnly.html#aebf60dbaf803f470c8954cab93acc241">ActionMarkIndirectOnly::apply()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a24e80f56ef371a0010a9e67ae8510086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newCodeRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a code address <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A reference to a specific <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> is encoded in a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is an <em>annotation</em> in the sense that it will hold no value in the data-flow, it will will only hold a reference to an address. This is used specifically by the branch p-code operations to hold destination addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cada11eee7331d13bd3034be76475cedac">Varnode::annotation</a>, <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classTypeFactory.html#a264037dc13d6d5d5c643bc805c373375">TypeFactory::getTypeCode()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classRuleSwitchSingle.html#ab884de26def65edb9ade3b981c6983e1">RuleSwitchSingle::applyOp()</a>, <a class="el" href="classFlowInfo.html#a5ee6e359bad18470fccb70737431794b">FlowInfo::checkContainedCall()</a>, <a class="el" href="classFlowInfo.html#acb0b9cbb6144cd2963c63072d6d72882">FlowInfo::inlineClone()</a>, <a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow()</a>, <a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, and <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>.</p>

</div>
</div>
<a class="anchor" id="af58542dbcc89f4b84ffc8834b023125b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newConstant </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>constant_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>constant</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is allocated which represents the indicated constant value. Its storage address is in the <em>constant</em> address space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">constant_val</td><td>is the indicated constant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classAddrSpaceManager.html#a77aed07a480b7c60b63c30bea2da711a">AddrSpaceManager::getConstant()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionStackPtrFlow.html#add8e15c126e69df09fbcdf49e019aafd">ActionStackPtrFlow::adjustLoad()</a>, <a class="el" href="classActionStackPtrFlow.html#a4f93079a3ade269842842a7fad126a12">ActionStackPtrFlow::analyzeExtraPop()</a>, <a class="el" href="classActionSegmentize.html#a3219ac91c09b6c6061d7e91ad1ed9111">ActionSegmentize::apply()</a>, <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classActionLikelyTrash.html#afbd2ec1783db1f08cedf5b259304f158">ActionLikelyTrash::apply()</a>, <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, <a class="el" href="classRuleAndMask.html#a366c5419fa1fb118d35b7f9794d72e47">RuleAndMask::applyOp()</a>, <a class="el" href="classRuleAndOrLump.html#aff7dd54db4bd5474329200371c8a3146">RuleAndOrLump::applyOp()</a>, <a class="el" href="classRuleNegateIdentity.html#a9de23484c0f96f82044def3765270523">RuleNegateIdentity::applyOp()</a>, <a class="el" href="classRuleShiftBitops.html#acdfd1b4d0a22a3e8f15d632e810d5737">RuleShiftBitops::applyOp()</a>, <a class="el" href="classRuleEquality.html#a1eec6d7734884df00533e207ead6de4b">RuleEquality::applyOp()</a>, <a class="el" href="classRuleHighOrderAnd.html#acadd25bbb252e1619bf2acc6d3b89e2e">RuleHighOrderAnd::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classRuleLessOne.html#ac787cb9aa39e6d205659bdf236920619">RuleLessOne::applyOp()</a>, <a class="el" href="classRuleRangeMeld.html#af99e831a0fd88d12ef57c0cd9fe01c1d">RuleRangeMeld::applyOp()</a>, <a class="el" href="classRuleFloatRange.html#a39c5067872e30f4d32dc229c53504cef">RuleFloatRange::applyOp()</a>, <a class="el" href="classRuleAndPiece.html#a21d9a8514b5713b5899f9f84f93b0156">RuleAndPiece::applyOp()</a>, <a class="el" href="classRuleAndCompare.html#a5bbd46f5a5c6969289ce7084c3bac4f7">RuleAndCompare::applyOp()</a>, <a class="el" href="classRuleDoubleSub.html#a5dac7faa4ee8464a136b3bec0e2057ab">RuleDoubleSub::applyOp()</a>, <a class="el" href="classRuleDoubleShift.html#a02b2443037178261d417afd9689de91b">RuleDoubleShift::applyOp()</a>, <a class="el" href="classRuleDoubleArithShift.html#a7aed6e52951397fdcd20aac7d44887e7">RuleDoubleArithShift::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classRuleShiftCompare.html#a8104a2a2506b0a63aeba91f4a9d505ba">RuleShiftCompare::applyOp()</a>, <a class="el" href="classRuleTrivialArith.html#a692632ff3e5fa2bad3ba12b6ff2005be">RuleTrivialArith::applyOp()</a>, <a class="el" href="classRuleTrivialBool.html#a0254986d799ca6fd09ecb6e96288eae1">RuleTrivialBool::applyOp()</a>, <a class="el" href="classRuleZextEliminate.html#a06205a6c85cac93cf2ef1de9e8fc93ff">RuleZextEliminate::applyOp()</a>, <a class="el" href="classRuleZextSless.html#ab27ad1b45b037db695c660850954f04e">RuleZextSless::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleSborrow.html#a624c5e919a23a5fd208c810aef997c48">RuleSborrow::applyOp()</a>, <a class="el" href="classRuleTrivialShift.html#a373f11af57c1291eac63c4b69afde34a">RuleTrivialShift::applyOp()</a>, <a class="el" href="classRuleSignShift.html#a1ab3983eb3e15e13dc388121c1014561">RuleSignShift::applyOp()</a>, <a class="el" href="classRuleTestSign.html#a4ce84c6a3996f9877c053bb41169bf7e">RuleTestSign::applyOp()</a>, <a class="el" href="classRuleShift2Mult.html#a72b5072e94341325dd65f0d48dbb2a04">RuleShift2Mult::applyOp()</a>, <a class="el" href="classRuleTransformCpool.html#af499e077d284de28aa52a807b53152de">RuleTransformCpool::applyOp()</a>, <a class="el" href="classRule2Comp2Mult.html#a1a526d775f62b172a92886444b5889a3">Rule2Comp2Mult::applyOp()</a>, <a class="el" href="classRuleCarryElim.html#ab7a660e29b328d6348a1cacace3d9844">RuleCarryElim::applyOp()</a>, <a class="el" href="classRuleSub2Add.html#adb3ba6d1c2c81fe6bc441ca0e4882e6a">RuleSub2Add::applyOp()</a>, <a class="el" href="classRuleXorCollapse.html#a66798e6a5cdb2306f61f2596db611045">RuleXorCollapse::applyOp()</a>, <a class="el" href="classRuleAddMultCollapse.html#a6f9afdaabcba06d6a739e7ff9a148fc3">RuleAddMultCollapse::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleConcatCommute.html#a75dbdeccddc5baf27b6390449b331bcf">RuleConcatCommute::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleConcatZero.html#a0cfa16444e6d4609972b78e5ce83c7e8">RuleConcatZero::applyOp()</a>, <a class="el" href="classRuleConcatLeftShift.html#aca7e943a778d99122e5d3c18f5d77f8f">RuleConcatLeftShift::applyOp()</a>, <a class="el" href="classRuleSubZext.html#abefcd055ea0199a4cf71e5f310996d9b">RuleSubZext::applyOp()</a>, <a class="el" href="classRuleSubCancel.html#afa2cbf94629eeff1cdd4ae0b02ef7821">RuleSubCancel::applyOp()</a>, <a class="el" href="classRuleShiftSub.html#aea3b654c2ff4472bdb597f16d660df9c">RuleShiftSub::applyOp()</a>, <a class="el" href="classRuleHumptyDumpty.html#a49a97daa382a5e01626144d914438301">RuleHumptyDumpty::applyOp()</a>, <a class="el" href="classRuleDumptyHump.html#a700703eddec46851943420aa51eefcb5">RuleDumptyHump::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleEmbed.html#abd0eb20956c404ec4abcb2776c593086">RuleEmbed::applyOp()</a>, <a class="el" href="classRuleLess2Zero.html#ac9d89e7b8899c76a40f88b3b0a5a0d74">RuleLess2Zero::applyOp()</a>, <a class="el" href="classRuleLessEqual2Zero.html#a1d41372d5ac60e36cca1ffcb04e33528">RuleLessEqual2Zero::applyOp()</a>, <a class="el" href="classRuleSLess2Zero.html#aee3dc812afcd3baeef9d3995971c098a">RuleSLess2Zero::applyOp()</a>, <a class="el" href="classRuleEqual2Constant.html#a99da234ae056794a853e6eb2466096e7">RuleEqual2Constant::applyOp()</a>, <a class="el" href="classRulePtrArith.html#a8b6d5d16ceb0884f97bebd712b9f6852">RulePtrArith::applyOp()</a>, <a class="el" href="classRuleStructOffset0.html#a925e149a62faa06ea1e64a9b9b52a47f">RuleStructOffset0::applyOp()</a>, <a class="el" href="classRuleAddUnsigned.html#a07c326702413b71711277439c247b932">RuleAddUnsigned::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>, <a class="el" href="classRuleSubNormal.html#a257e214dcabe37990f299a02912c75c2">RuleSubNormal::applyOp()</a>, <a class="el" href="classRuleDivTermAdd.html#ad39ae5dc8516af986340cd55e063afcc">RuleDivTermAdd::applyOp()</a>, <a class="el" href="classRuleDivTermAdd2.html#abc720625170593b9f1bd43748c2be78c">RuleDivTermAdd2::applyOp()</a>, <a class="el" href="classRuleDivOpt.html#a8443133b32d917f3b751ba1fa7dee8f1">RuleDivOpt::applyOp()</a>, <a class="el" href="classRuleSignDiv2.html#a2c19f27ad4e779fd9fc6a4bce1e16be5">RuleSignDiv2::applyOp()</a>, <a class="el" href="classRuleSignForm.html#a4d0250a44bacb1048487280de4ffcd3d">RuleSignForm::applyOp()</a>, <a class="el" href="classRuleSignNearMult.html#a37aa70b7da5c91e0d7f8ea81a98869f6">RuleSignNearMult::applyOp()</a>, <a class="el" href="classRuleModOpt.html#ab868b1ba7b5ba982da1c316637d72c1e">RuleModOpt::applyOp()</a>, <a class="el" href="classRuleSegment.html#ae9c0b0fb9076088f2adf5342f8e100f6">RuleSegment::applyOp()</a>, <a class="el" href="classRuleConditionalMove.html#a6f63597a783571c793f91a046166845b">RuleConditionalMove::applyOp()</a>, <a class="el" href="classRuleIgnoreNan.html#afd2b8e067067db3127664cd2cedfd092">RuleIgnoreNan::applyOp()</a>, <a class="el" href="classRuleThreeWayCompare.html#af661958d83d132fd75bf054671649a27">RuleThreeWayCompare::applyOp()</a>, <a class="el" href="classRulePopcountBoolXor.html#a943d7f4ea0aecf0544daa2240f82f409">RulePopcountBoolXor::applyOp()</a>, <a class="el" href="classFlowInfo.html#a3d8d1490b85d7291305fc13bd1b63a14">FlowInfo::artificialHalt()</a>, <a class="el" href="classAddTreeState.html#a406b886ea345f99dd568813650c73f0f">AddTreeState::buildExtra()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classAddTreeState.html#a8e8a6c35f777edd060cfd319382bfeec">AddTreeState::buildMultiples()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">AddTreeState::buildTree()</a>, <a class="el" href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">FuncCallSpecs::checkInputTrialUse()</a>, <a class="el" href="classFuncdata.html#a5027da6d3c7a05a262e332b0c22c7c43">collapseIntMultMult()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classRuleConditionalMove_1_1BoolExpress.html#a230d38eace38ddebb91e1dcefc2cead4">RuleConditionalMove::BoolExpress::constructBool()</a>, <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly()</a>, <a class="el" href="classJumpBasic.html#a27ac3c21abdfc602f857802a7479c6d4">JumpBasic::foldInOneGuard()</a>, <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">SubvariableFlow::getReplaceVarnode()</a>, <a class="el" href="classActionDeadCode.html#a8d2d35c0f22f6fcb3ddb07681c0a474a">ActionDeadCode::neverConsumed()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow()</a>, <a class="el" href="classActionConditionalConst.html#ab477e0173dc6a85b8a7aeee5c0c41bfc">ActionConditionalConst::propagateConstant()</a>, <a class="el" href="classRulePtrsubCharConstant.html#a1e7496cf33cc149a3f77828b6e92e950">RulePtrsubCharConstant::pushConstFurther()</a>, <a class="el" href="classRulePullsubMulti.html#a913ef535547efd0f181a08dfff49beab">RulePullsubMulti::replaceDescendants()</a>, <a class="el" href="classFuncdata.html#a223a70ddb5e33f446fca85bc3b369911">replaceLessequal()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant()</a>, <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>, <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>, and <a class="el" href="classSegmentOp.html#aa7742d6bad87ed5f7c6b32c5db407567">SegmentOp::unify()</a>.</p>

</div>
</div>
<a class="anchor" id="add1098b768d9a176cf59e4f4c9e27cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newIndirectCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indeffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>possibleout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a CPUI_INDIRECT op that <em>indirectly</em> <em>creates</em> a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>An <em>indirectly</em> <em>created</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> effectively has no data-flow before the INDIRECT op that defines it, and the value contained by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not explicitly calculable. The new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is allocated with a given storage range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeffect</td><td>is the p-code causing the indirect effect </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage range </td></tr>
    <tr><td class="paramname">possibleout</td><td>is <b>true</b> if the output should be treated as a <em>directwrite</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new CPUI_INDIRECT op </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classPcodeOp.html#ad51989ace14aa76d155b55be0f1f17a5">PcodeOp::flags</a>, <a class="el" href="classVarnode.html#aafb83bc78aa8285d2146b3eba501c515">Varnode::flags</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bbaebf947b1f15fc32e702ed9f9ae07406d">PcodeOp::indirect_creation</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca50b14789b3198743399e2f2f8c8116e9">Varnode::indirect_creation</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">newVarnodeIop()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>.</p>

<p>Referenced by <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, and <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>.</p>

</div>
</div>
<a class="anchor" id="a008246c0350878f3d312b174a227b676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newIndirectOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indeffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>extraFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a representative CPUI_RETURN op for <b>this</b> function. </p>
<p>Create a new CPUI_INDIRECT around a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with an indirect effect.</p>
<p>Typically this is used to annotate data-flow, for the given storage range, passing through a CALL or STORE. An output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is automatically created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeffect</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with the indirect effect </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the storage range to protect </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage range </td></tr>
    <tr><td class="paramname">extraFlags</td><td>are extra boolean properties to put on the INDIRECT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new CPUI_INDIRECT op </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classPcodeOp.html#ad51989ace14aa76d155b55be0f1f17a5">PcodeOp::flags</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, <a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">newVarnodeIop()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b1e9831bb4b1c65df6950ae1f15e0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newOp </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>is the number of operands the new op will have </td></tr>
    <tr><td class="paramname">pc</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> associated with the new op </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

<p>References <a class="el" href="classPcodeOpBank.html#a99a5d552174bddb89036c1755708b9aa">PcodeOpBank::create()</a>, and <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, <a class="el" href="classRuleOrPredicate.html#ae9bd9f602cf43e10c02623d2ee5e6fc7">RuleOrPredicate::applyOp()</a>, <a class="el" href="classRulePullsubMulti.html#ae66401a1bda28e0332a3058b276fdca5">RulePullsubMulti::applyOp()</a>, <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleNotDistribute.html#af010b4c83cf55e7c1c858941f72e048b">RuleNotDistribute::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classRuleAndDistribute.html#aa40f49c92c7f7088f01ffedff4b5700e">RuleAndDistribute::applyOp()</a>, <a class="el" href="classRuleAndCommute.html#a4dd1bf0f7f55f84c7136a9fb4f44120f">RuleAndCommute::applyOp()</a>, <a class="el" href="classRuleAndPiece.html#a21d9a8514b5713b5899f9f84f93b0156">RuleAndPiece::applyOp()</a>, <a class="el" href="classRuleAndCompare.html#a5bbd46f5a5c6969289ce7084c3bac4f7">RuleAndCompare::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleShiftCompare.html#a8104a2a2506b0a63aeba91f4a9d505ba">RuleShiftCompare::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleSignShift.html#a1ab3983eb3e15e13dc388121c1014561">RuleSignShift::applyOp()</a>, <a class="el" href="classRuleShiftPiece.html#a6ba7f2b28202933238d037dd1706992c">RuleShiftPiece::applyOp()</a>, <a class="el" href="classRuleSub2Add.html#adb3ba6d1c2c81fe6bc441ca0e4882e6a">RuleSub2Add::applyOp()</a>, <a class="el" href="classRuleAddMultCollapse.html#a6f9afdaabcba06d6a739e7ff9a148fc3">RuleAddMultCollapse::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleConcatCommute.html#a75dbdeccddc5baf27b6390449b331bcf">RuleConcatCommute::applyOp()</a>, <a class="el" href="classRuleConcatZext.html#aa7e8b70ac971efc988253c8b42e080b7">RuleConcatZext::applyOp()</a>, <a class="el" href="classRuleZextCommute.html#a04f5c4f8e6cc15d700d777d55c788e81">RuleZextCommute::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleConcatZero.html#a0cfa16444e6d4609972b78e5ce83c7e8">RuleConcatZero::applyOp()</a>, <a class="el" href="classRuleConcatLeftShift.html#aca7e943a778d99122e5d3c18f5d77f8f">RuleConcatLeftShift::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleEmbed.html#abd0eb20956c404ec4abcb2776c593086">RuleEmbed::applyOp()</a>, <a class="el" href="classRuleCondNegate.html#a085f7cbc001d8d211be810d8578f4b7a">RuleCondNegate::applyOp()</a>, <a class="el" href="classRulePushPtr.html#a6785d1d9de50ecb56918711aa413d7dc">RulePushPtr::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classRuleSubNormal.html#a257e214dcabe37990f299a02912c75c2">RuleSubNormal::applyOp()</a>, <a class="el" href="classRuleDivTermAdd.html#ad39ae5dc8516af986340cd55e063afcc">RuleDivTermAdd::applyOp()</a>, <a class="el" href="classRuleDivTermAdd2.html#abc720625170593b9f1bd43748c2be78c">RuleDivTermAdd2::applyOp()</a>, <a class="el" href="classRuleDivOpt.html#a8443133b32d917f3b751ba1fa7dee8f1">RuleDivOpt::applyOp()</a>, <a class="el" href="classRuleSignNearMult.html#a37aa70b7da5c91e0d7f8ea81a98869f6">RuleSignNearMult::applyOp()</a>, <a class="el" href="classFlowInfo.html#a3d8d1490b85d7291305fc13bd1b63a14">FlowInfo::artificialHalt()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classActionReturnRecovery.html#adf0e1a63b8760a7cc73b42c8224d0393">ActionReturnRecovery::buildReturnOutput()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classActionSetCasts.html#a0543f2c3f7b96033e3a03352700d8c3a">ActionSetCasts::castInput()</a>, <a class="el" href="classActionSetCasts.html#a1b6651e4de16fe0bbfe50cd6d105fa61">ActionSetCasts::castOutput()</a>, <a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classRuleConditionalMove_1_1BoolExpress.html#a230d38eace38ddebb91e1dcefc2cead4">RuleConditionalMove::BoolExpress::constructBool()</a>, <a class="el" href="classRuleConditionalMove.html#a5ba9e278f630efc2493621cbcdaea062">RuleConditionalMove::constructNegate()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>, <a class="el" href="classFlowInfo.html#acb0b9cbb6144cd2963c63072d6d72882">FlowInfo::inlineClone()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore()</a>, <a class="el" href="classFuncdata.html#a51c5acfe4a404779a418095011ed2815">nodeSplitCloneOp()</a>, <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, <a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant()</a>, <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>, <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>, and <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d122aa09d739e59a5107338f8ecd8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newOp </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<p>This method is typically used for cloning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>is the number of operands the new op will have </td></tr>
    <tr><td class="paramname">sq</td><td>is the sequence number (<a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> and sub-index) of the new op </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

<p>References <a class="el" href="classPcodeOpBank.html#a99a5d552174bddb89036c1755708b9aa">PcodeOpBank::create()</a>, and <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>.</p>

</div>
</div>
<a class="anchor" id="ae1126d213d88120c9e55b5779d746859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newOpBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>follow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>in3</em> = <code>(<a class="el" href="classVarnode.html">Varnode</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with sequence number. </p>
<p>Create new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with 2 or 3 given operands.</p>
<p>The new op will have a <em>unique</em> space output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and will be inserted before the given <em>follow</em> op. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">follow</td><td>is the <em>follow</em> up to insert the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> before </td></tr>
    <tr><td class="paramname">opc</td><td>is the op-code of the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">in1</td><td>is the first operand </td></tr>
    <tr><td class="paramname">in2</td><td>is the second operand </td></tr>
    <tr><td class="paramname">in3</td><td>is the optional third param </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>.</p>

<p>Referenced by <a class="el" href="classRuleStructOffset0.html#a925e149a62faa06ea1e64a9b9b52a47f">RuleStructOffset0::applyOp()</a>, <a class="el" href="classAddTreeState.html#a406b886ea345f99dd568813650c73f0f">AddTreeState::buildExtra()</a>, <a class="el" href="classAddTreeState.html#a8e8a6c35f777edd060cfd319382bfeec">AddTreeState::buildMultiples()</a>, <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">AddTreeState::buildTree()</a>, and <a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge()</a>.</p>

</div>
</div>
<a class="anchor" id="ac083b7d6637a5883ef8cbd38e7756837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newSpacebasePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <em>spacebase</em> register for a given address space. </p>
<p>Given an address space, like <em>stack</em>, that is known to have a base register pointing to it, construct a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> representing that register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the <em>stack</em> like address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a3b16390dfa556c9bdd6fe5b31448f7d7">AddrSpace::getSpacebase()</a>, and <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, and <a class="el" href="classFuncdata.html#a287bc196bb5fa26fb1a8197a1e4c6eca">hasBadData()</a>.</p>

</div>
</div>
<a class="anchor" id="a731f6fd415269577b7bb1943315b8a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newUnique </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em> = <code>(<a class="el" href="classDatatype.html">Datatype</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>temporary</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A new temporary register storage location is allocated from the <em>unique</em> address space </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">ct</td><td>is an optional data-type to associated with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>temporary</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classFuncdata.html#a483d190eec54662367b015b59e245328">checkForLanedRegister()</a>, <a class="el" href="classVarnodeBank.html#ab73cb940a84d7cb07870f4cb50c66fb1">VarnodeBank::createUnique()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a50f8b3cdc80fb056614087f49c15b9d7">minLanedSize</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classRuleSubZext.html#abefcd055ea0199a4cf71e5f310996d9b">RuleSubZext::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classActionSetCasts.html#a1b6651e4de16fe0bbfe50cd6d105fa61">ActionSetCasts::castOutput()</a>, <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>, <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">SubvariableFlow::getReplaceVarnode()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classSubvariableFlow.html#a8f8c80032b3fa35e825e18b3d8d98197">SubvariableFlow::replaceInput()</a>, and <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>.</p>

</div>
</div>
<a class="anchor" id="af189a9a5b390332c6e87c8faa334cd68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newUniqueOut </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>temporary</em> output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Allocate a new register from the <em>unique</em> address space and create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object representing it as an output to the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> whose output is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new temporary register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classFuncdata.html#a483d190eec54662367b015b59e245328">checkForLanedRegister()</a>, <a class="el" href="classVarnodeBank.html#a9b47054374533bec02c4b467b390b6ca">VarnodeBank::createDefUnique()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a50f8b3cdc80fb056614087f49c15b9d7">minLanedSize</a>, <a class="el" href="classPcodeOp.html#a965b9f3be5f7c3df2ed4b71aa83dbf04">PcodeOp::setOutput()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, <a class="el" href="classRuleOrPredicate.html#ae9bd9f602cf43e10c02623d2ee5e6fc7">RuleOrPredicate::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleNotDistribute.html#af010b4c83cf55e7c1c858941f72e048b">RuleNotDistribute::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classRuleAndDistribute.html#aa40f49c92c7f7088f01ffedff4b5700e">RuleAndDistribute::applyOp()</a>, <a class="el" href="classRuleAndCommute.html#a4dd1bf0f7f55f84c7136a9fb4f44120f">RuleAndCommute::applyOp()</a>, <a class="el" href="classRuleAndPiece.html#a21d9a8514b5713b5899f9f84f93b0156">RuleAndPiece::applyOp()</a>, <a class="el" href="classRuleAndCompare.html#a5bbd46f5a5c6969289ce7084c3bac4f7">RuleAndCompare::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleShiftCompare.html#a8104a2a2506b0a63aeba91f4a9d505ba">RuleShiftCompare::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleSignShift.html#a1ab3983eb3e15e13dc388121c1014561">RuleSignShift::applyOp()</a>, <a class="el" href="classRuleShiftPiece.html#a6ba7f2b28202933238d037dd1706992c">RuleShiftPiece::applyOp()</a>, <a class="el" href="classRuleSub2Add.html#adb3ba6d1c2c81fe6bc441ca0e4882e6a">RuleSub2Add::applyOp()</a>, <a class="el" href="classRuleAddMultCollapse.html#a6f9afdaabcba06d6a739e7ff9a148fc3">RuleAddMultCollapse::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleConcatCommute.html#a75dbdeccddc5baf27b6390449b331bcf">RuleConcatCommute::applyOp()</a>, <a class="el" href="classRuleConcatZext.html#aa7e8b70ac971efc988253c8b42e080b7">RuleConcatZext::applyOp()</a>, <a class="el" href="classRuleZextCommute.html#a04f5c4f8e6cc15d700d777d55c788e81">RuleZextCommute::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleConcatZero.html#a0cfa16444e6d4609972b78e5ce83c7e8">RuleConcatZero::applyOp()</a>, <a class="el" href="classRuleConcatLeftShift.html#aca7e943a778d99122e5d3c18f5d77f8f">RuleConcatLeftShift::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleEmbed.html#abd0eb20956c404ec4abcb2776c593086">RuleEmbed::applyOp()</a>, <a class="el" href="classRuleCondNegate.html#a085f7cbc001d8d211be810d8578f4b7a">RuleCondNegate::applyOp()</a>, <a class="el" href="classRulePushPtr.html#a6785d1d9de50ecb56918711aa413d7dc">RulePushPtr::applyOp()</a>, <a class="el" href="classRuleSubNormal.html#a257e214dcabe37990f299a02912c75c2">RuleSubNormal::applyOp()</a>, <a class="el" href="classRuleDivTermAdd.html#ad39ae5dc8516af986340cd55e063afcc">RuleDivTermAdd::applyOp()</a>, <a class="el" href="classRuleDivTermAdd2.html#abc720625170593b9f1bd43748c2be78c">RuleDivTermAdd2::applyOp()</a>, <a class="el" href="classRuleDivOpt.html#a8443133b32d917f3b751ba1fa7dee8f1">RuleDivOpt::applyOp()</a>, <a class="el" href="classRuleSignNearMult.html#a37aa70b7da5c91e0d7f8ea81a98869f6">RuleSignNearMult::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classRuleSubCommute.html#a98082ac7f5395dbc0fd603a876417250">RuleSubCommute::cancelExtensions()</a>, <a class="el" href="classActionSetCasts.html#a0543f2c3f7b96033e3a03352700d8c3a">ActionSetCasts::castInput()</a>, <a class="el" href="classRuleConditionalMove_1_1BoolExpress.html#a230d38eace38ddebb91e1dcefc2cead4">RuleConditionalMove::BoolExpress::constructBool()</a>, <a class="el" href="classRuleConditionalMove.html#a5ba9e278f630efc2493621cbcdaea062">RuleConditionalMove::constructNegate()</a>, <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant()</a>, <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>, and <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="a22894e1c7b0f30a5391993924cd96d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnode </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em> = <code>(<a class="el" href="classDatatype.html">Datatype</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new unattached <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">m</td><td>is the storage <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type to associate with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classFuncdata.html#a483d190eec54662367b015b59e245328">checkForLanedRegister()</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classFuncdata.html#a50f8b3cdc80fb056614087f49c15b9d7">minLanedSize</a>, <a class="el" href="classScope.html#a81a607e1ba8c2cc85a14b84a1c86944e">Scope::queryProperties()</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classVarnode.html#a0ae87b8fb23c218185f4cee1d958b606">Varnode::setSymbolProperties()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae49e063a1b1e7de4592afd3f19abbdc7">Varnode::typelock</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>, <a class="el" href="classRuleCollapseConstants.html#a9dbb37c234aa8599bed3e916bdc15147">RuleCollapseConstants::applyOp()</a>, <a class="el" href="classRuleLoadVarnode.html#aba1b981179387a727272c5ba7b407777">RuleLoadVarnode::applyOp()</a>, <a class="el" href="classRuleEqual2Zero.html#a4451f6e9c8236e504f80f6c57edda360">RuleEqual2Zero::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>, <a class="el" href="classActionFuncLink.html#a1eb46aa1ae74eaafce6575727b851dae">ActionFuncLink::funcLinkInput()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">SubvariableFlow::getReplaceVarnode()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, <a class="el" href="classFuncdata.html#ac083b7d6637a5883ef8cbd38e7756837">newSpacebasePtr()</a>, <a class="el" href="classFuncdata.html#a0d6888d1606fd8ed6372355995bc7887">newVarnode()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, and <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d6888d1606fd8ed6372355995bc7887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnode </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> given an address space and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">base</td><td>is the address space of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">off</td><td>is the offset into the address space of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a13da637294b7cae252ffc6c9e2116da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeCallSpecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>fc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a call specification <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A call specification (<a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a>) is encoded into an <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is used specifically as an input to CPUI_CALL ops to speed up access to their associated call specification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fc</td><td>is the call specification to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classAddrSpaceManager.html#a2c5ea8b9d837a8b3a16176530a34eaeb">AddrSpaceManager::getFspecSpace()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">FuncCallSpecs::deindirect()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFlowInfo.html#af742b3c41b0806308c4465de7a0d4e4b">FlowInfo::setupCallindSpecs()</a>, <a class="el" href="classFlowInfo.html#aa32bf6a3cc3aa4ad93319d7a4a5385cf">FlowInfo::setupCallSpecs()</a>, and <a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">truncatedFlow()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ee39fe2d1f2f4702864e78dc06e6bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeIop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Create a special <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that holds a pointer reference to a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. This is used specifically to let a CPUI_INDIRECT op refer to the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> it is holding an indirect effect for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to encode in the annotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classAddrSpaceManager.html#aa9be6c441d2c5815c6041d14c83aff56">AddrSpaceManager::getIopSpace()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, and <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>.</p>

</div>
</div>
<a class="anchor" id="a100e6704e4c245e076170268d31b47ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeOut </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> which is already defined as output of a given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. This if more efficient as it avoids the initial insertion of the free form of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into the tree, and queryProperties only needs to be called once. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">m</td><td>is the storage <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> whose output is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classFuncdata.html#a483d190eec54662367b015b59e245328">checkForLanedRegister()</a>, <a class="el" href="classVarnodeBank.html#a8acd91c7c2d886e404e531996f7962eb">VarnodeBank::createDef()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classFuncdata.html#a50f8b3cdc80fb056614087f49c15b9d7">minLanedSize</a>, <a class="el" href="classScope.html#a81a607e1ba8c2cc85a14b84a1c86944e">Scope::queryProperties()</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classPcodeOp.html#a965b9f3be5f7c3df2ed4b71aa83dbf04">PcodeOp::setOutput()</a>, <a class="el" href="classVarnode.html#a0ae87b8fb23c218185f4cee1d958b606">Varnode::setSymbolProperties()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae49e063a1b1e7de4592afd3f19abbdc7">Varnode::typelock</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classRulePullsubMulti.html#ae66401a1bda28e0332a3058b276fdca5">RulePullsubMulti::applyOp()</a>, <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classRuleStoreVarnode.html#af2356cc3335eab5bc75ff0d8f5223165">RuleStoreVarnode::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classActionReturnRecovery.html#adf0e1a63b8760a7cc73b42c8224d0393">ActionReturnRecovery::buildReturnOutput()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, <a class="el" href="classFuncdata.html#a9a79f4159aed3b616d43a9eadee040e1">nodeSplitCloneVarnode()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, and <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="acc9f6fb3e8a36e0e1e633660fc05fdbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> referring to an address space. </p>
<p>A reference to a particular address space is encoded as a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. These are used for LOAD and STORE p-code ops in particular. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a78a38d8d7ccb7d43a063d09077d32639">assignHigh()</a>, <a class="el" href="classVarnodeBank.html#ae2effd128dce9205fba1015b45959f1c">VarnodeBank::create()</a>, <a class="el" href="classAddrSpaceManager.html#a1a5d0fafb73b3f77d672dcefae79cb61">AddrSpaceManager::createConstFromSpace()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionSegmentize.html#a3219ac91c09b6c6061d7e91ad1ed9111">ActionSegmentize::apply()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, and <a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore()</a>.</p>

</div>
</div>
<a class="anchor" id="ad810c24ce5fb16a95de1f7d27c8856d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockBasic.html">BlockBasic</a> * Funcdata::nodeJoinCreateBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>block2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>exita</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>exitb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fora_block1ishigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forb_block1ishigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new basic block for holding a merged CBRANCH. </p>
<p>This is used by <a class="el" href="classConditionalJoin.html" title="Discover and eliminate split conditions. ">ConditionalJoin</a> to do the low-level control-flow manipulation to merge identical conditional branches. Given basic blocks containing the two CBRANCH ops to merge, the new block gets one of the two out edges from each block, and the remaining out edges are changed to point into the new block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block1</td><td>is the basic block containing the first CBRANCH to merge </td></tr>
    <tr><td class="paramname">block2</td><td>is the basic block containing the second CBRANCH </td></tr>
    <tr><td class="paramname">exita</td><td>is the first common exit block for the CBRANCHs </td></tr>
    <tr><td class="paramname">exitb</td><td>is the second common exit block </td></tr>
    <tr><td class="paramname">fora_block1ishigh</td><td>designates which edge is moved for exita </td></tr>
    <tr><td class="paramname">forb_block1ishigh</td><td>designates which edge is moved for exitb </td></tr>
    <tr><td class="paramname">addr</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> associated with (1 of the) CBRANCH ops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new basic block </dd></dl>

<p>References <a class="el" href="classBlockGraph.html#a0bd135694f8274979c03d005d796d81f">BlockGraph::addEdge()</a>, <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classFlowBlock.html#a26c4544d5e03d58799f03a43a46f78d2a2342aaea273caf2fbd3fb633bb9f1013">FlowBlock::f_joined_block</a>, <a class="el" href="classFlowBlock.html#af406449573b23d1adf05f6e59ebe8c1f">FlowBlock::getOutIndex()</a>, <a class="el" href="classBlockGraph.html#a4a1dcf88374cbf4b9886d26dced7c533">BlockGraph::moveOutEdge()</a>, <a class="el" href="classBlockGraph.html#a0d05f223a305365c86c4b6efea82f1c0">BlockGraph::newBlockBasic()</a>, <a class="el" href="classBlockGraph.html#a2fe87e9f6a5a250a09869028bf1bb11d">BlockGraph::removeEdge()</a>, <a class="el" href="classFlowBlock.html#a99e1437634825bce66d6eb86d8b58e34">FlowBlock::setFlag()</a>, <a class="el" href="classBlockBasic.html#ad15bba2ab501e8efff86dc40a832ffff">BlockBasic::setInitialRange()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e19baf8aa1db2ecde4fd12075da0694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::nodeSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split control-flow into a basic block, duplicating its p-code into a new block. </p>
<p>P-code is duplicated into another block, and control-flow is modified so that the new block takes over flow from one input edge to the original block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>is the basic block to be duplicated and split </td></tr>
    <tr><td class="paramname">inedge</td><td>is the index of the input edge to move to the duplicate block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFlowBlock.html#ad8fe7973ef5e53753ea0695ea2d3b7be">FlowBlock::clearMark()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classFlowBlock.html#a2487635c6f46d1ee4b0e14c67af760e6">FlowBlock::isMark()</a>, <a class="el" href="classFuncdata.html#a310ba90147bef99048bbea76d0edd81e">nodeSplitBlockEdge()</a>, <a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch()</a>, <a class="el" href="classFuncdata.html#a7393fde88940742db881c80783e0af0d">nodeSplitRawDuplicate()</a>, <a class="el" href="classFlowBlock.html#a3a64aa8a8182a65f5e1e361d23ecc3c8">FlowBlock::setMark()</a>, <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classActionReturnSplit.html#a19c3922a6dc7e8e0af6eed9becd7c01b">ActionReturnSplit::apply()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a310ba90147bef99048bbea76d0edd81e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockBasic.html">BlockBasic</a> * Funcdata::nodeSplitBlockEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split given basic block b along an <em>in</em> edge. </p>
<p>A copy of the block is made, inheriting the same <em>out</em> edges but only the one indicated <em>in</em> edge, which is removed from the original block. Other data-flow is <b>not</b> affected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">inedge</td><td>is the index of the indicated <em>in</em> edge </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockGraph.html#a0bd135694f8274979c03d005d796d81f">BlockGraph::addEdge()</a>, <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classBlockBasic.html#a9d04ffb771137566780c14097a99940a">BlockBasic::copyRange()</a>, <a class="el" href="classFlowBlock.html#a26c4544d5e03d58799f03a43a46f78d2ac1eba11e8c914e6a242f81da5f897a32">FlowBlock::f_duplicate_block</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classBlockGraph.html#a0d05f223a305365c86c4b6efea82f1c0">BlockGraph::newBlockBasic()</a>, <a class="el" href="classFlowBlock.html#a99e1437634825bce66d6eb86d8b58e34">FlowBlock::setFlag()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, and <a class="el" href="classBlockGraph.html#a238a3ecac594008e2893b2fa1f85d95b">BlockGraph::switchEdge()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit()</a>.</p>

</div>
</div>
<a class="anchor" id="a51c5acfe4a404779a418095011ed2815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::nodeSplitCloneOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as part of splitting a block. </p>
<p>Make a basic clone of the p-code op copying its basic control-flow properties </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned op </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a8e04ce6913869e8db2eaf101ae59ed9e">CPUI_BRANCH</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classPcodeOp.html#ad51989ace14aa76d155b55be0f1f17a5">PcodeOp::flags</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classPcodeOp.html#a6195f7c7b53036df7081a9dcff633f69">PcodeOp::isBranch()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba5057de67535051aec91b674a773da7af">PcodeOp::nocollapse</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classPcodeOp.html#ad54b6a60862c7a87c2beeb5934ff2359">PcodeOp::setFlag()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba87fc6777cadc38baf72c41c402042974">PcodeOp::startbasic</a>, and <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba64f1f43673312ffd240147a69006cebf">PcodeOp::startmark</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a7393fde88940742db881c80783e0af0d">nodeSplitRawDuplicate()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a79f4159aed3b616d43a9eadee040e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::nodeSplitCloneVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>newop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the given p-code op, as part of splitting a block. </p>
<p>Make a basic clone of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and its basic flags. The clone is created as an output of a previously cloned <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given op whose output should be cloned </td></tr>
    <tr><td class="paramname">newop</td><td>is the cloned version </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cabecfcc64c4827f783e3e538b3b9dfd6c">Varnode::addrforce</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca01456896881c6bb4ee5840596e85f0d5">Varnode::externref</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a436419e5a1ee0e2b2467e5b543a65596">Varnode::getFlags()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae9fccd0da71d0cbf7ba0b169330dccc9">Varnode::incidental_copy</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cafd8f85c37b5ee3374d865cafbaf6f7e5">Varnode::volatil</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a7393fde88940742db881c80783e0af0d">nodeSplitRawDuplicate()</a>.</p>

</div>
</div>
<a class="anchor" id="a4aaf9bd74b73972d2d453866631dbd1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::nodeSplitInputPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bprime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Patch <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs to p-code ops in split basic block. </p>
<p>Map Varnodes that are inputs for PcodeOps in the original basic block to the input slots of the cloned ops in the split block. Constants and code ref Varnodes need to be duplicated, other Varnodes are shared between the ops. This routine also pulls an input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> out of riginal MULTIEQUAL ops and adds it back to the cloned MULTIEQUAL ops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>is the original basic block </td></tr>
    <tr><td class="paramname">bprime</td><td>is the split clone of the block </td></tr>
    <tr><td class="paramname">inedge</td><td>is the incoming edge index that was split on </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#af7d640b593a55ac3eb63fa7322fb8a2a">Varnode::isAnnotation()</a>, <a class="el" href="classPcodeOp.html#a091539b02c09c885351f789b24afba7b">PcodeOp::isCall()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">newCodeRef()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classPcodeOp.html#a69ca6b34a4ff983ec0afeddcbae89cf4">PcodeOp::setNumInputs()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit()</a>.</p>

</div>
</div>
<a class="anchor" id="a7393fde88940742db881c80783e0af0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::nodeSplitRawDuplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bprime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone all p-code ops from a block into its copy. </p>
<p>P-code in a basic block is cloned into the split version of the block. Only the output Varnodes are cloned, not the inputs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>is the original basic block </td></tr>
    <tr><td class="paramname">bprime</td><td>is the cloned block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classFuncdata.html#a51c5acfe4a404779a418095011ed2815">nodeSplitCloneOp()</a>, <a class="el" href="classFuncdata.html#a9a79f4159aed3b616d43a9eadee040e1">nodeSplitCloneVarnode()</a>, and <a class="el" href="classFuncdata.html#ad544a6136ff019bbd18c45043e9b6900">opInsertEnd()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit()</a>.</p>

</div>
</div>
<a class="anchor" id="a363bd02cb2f20cf1583951d5429a057b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Funcdata::numHeritagePasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of heritage passes performed for the given address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of passes performed </dd></dl>

<p>References <a class="el" href="classHeritage.html#ac24cd8c63c9efbc8bb17cd17a3530d8a">Heritage::numHeritagePasses()</a>.</p>

</div>
</div>
<a class="anchor" id="a1347de2ecdf4bf99194abb7e11e8eb5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::onlyOpUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>invn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>opmatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;&#160;</td>
          <td class="paramname"><em>trial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> seems to only be used by a CALL. </p>
<p>Part of testing whether a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> makes sense as parameter passing storage is looking for different explicit uses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">opmatch</td><td>is the putative CALL op using the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for parameter passing </td></tr>
    <tr><td class="paramname">trial</td><td>is the parameter trial object associated with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> seems only to be used as parameter to <b>opmatch</b> </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a25609ffe02a0baf12354ca7aba00db14">checkCallDoubleUse()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a8e04ce6913869e8db2eaf101ae59ed9e">CPUI_BRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a14ab8d826af51873faa33b33e2bbc5fb">CPUI_STORE</a>, <a class="el" href="classVarnode.html#a7a6543b02c57f78a06aaecd53f858b14">Varnode::descend</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classParamTrial.html#a14b7cefb6f6b522542985ac3b0c1456b">ParamTrial::getSlot()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#aa3f603299bd7de14e1cef73e32981f84">Varnode::isPersist()</a>, and <a class="el" href="classVarnode.html#a98825616d50a27a615057e625a61285e">Varnode::setMark()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a226bd2fae467e85879220d2aaf9b1da1">ancestorOpUse()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a6976625d7b40efca0bc9941cb199ee44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and destroy its <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> operands. </p>
<p>All input and output Varnodes to the op are destroyed (their object resources freed), and the op is permanently moved to the <em>dead</em> list. To call this routine, make sure that either:</p><ul>
<li>The op has no output</li>
<li>The op's output has no descendants</li>
<li>or all descendants of output are also going to be destroyed</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a6aaece008a9aff77bc2e7acae325c992">destroyVarnode()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOpBank.html#ad4e924e79e478b3f867a4da3ba6d6c56">PcodeOpBank::markDead()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, <a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput()</a>, and <a class="el" href="classBlockBasic.html#aa2549f41a3fdc7a3f6be3b76a862a863">BlockBasic::removeOp()</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a8fc0f3220ac7b0fef4613ba3666d9af9">ActionDeadCode::apply()</a>, <a class="el" href="classRuleEarlyRemoval.html#a8409f6b8ffe4ba8b6f59140b6da58d12">RuleEarlyRemoval::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleIndirectCollapse.html#a0d4041209c44deabc2baa829c022d642">RuleIndirectCollapse::applyOp()</a>, <a class="el" href="classRuleMultiCollapse.html#a65f32f0c3dfaad6ba711cb1c9dc72954">RuleMultiCollapse::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRule2Comp2Sub.html#a016089f19466049e949fd664649c27e4">Rule2Comp2Sub::applyOp()</a>, <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classFuncdata.html#ac96af1ca8355f0c4f8e6582c045f0723">branchRemoveInternal()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">AddTreeState::buildTree()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classJumpAssisted.html#aa36ee3e6e3749c41a43a3801579095eb">JumpAssisted::foldInNormalization()</a>, <a class="el" href="classActionDeadCode.html#a8d2d35c0f22f6fcb3ddb07681c0a474a">ActionDeadCode::neverConsumed()</a>, <a class="el" href="funcdata_8hh.html#a0a7a4ee0c419ed55c99f44d914284828">opFlipInPlaceExecute()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classActionMultiCse.html#aeed5c0ca7367c55687a61bcc2df3b239">ActionMultiCse::processBlock()</a>, <a class="el" href="classTransformManager.html#aab35ae5a17ec1e1fc45cf2f80f6e4d8b">TransformManager::removeOld()</a>, and <a class="el" href="classFuncdata.html#a9f0c9d7c7fb4217731ae45f7848e4034">spliceBlockBasic()</a>.</p>

</div>
</div>
<a class="anchor" id="aeef2a6be0e9c641f72bf4e87020ddf37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opDestroyRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given <em>raw</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>This is a specialized routine for deleting an op during flow generation that has been replaced by something else. The op is expected to be <em>dead</em> with none of its inputs or outputs linked to anything else. Both the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and all the input/output Varnodes are destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpBank.html#a1d447e7dcaeab2fd89e0a3dd8454b77d">PcodeOpBank::destroy()</a>, <a class="el" href="classFuncdata.html#a6aaece008a9aff77bc2e7acae325c992">destroyVarnode()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, and <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>.</p>

<p>Referenced by <a class="el" href="classFlowInfo.html#a37b1db3a5796f5f84fba69c5337acceb">FlowInfo::deleteRemainingOps()</a>, <a class="el" href="classFlowInfo.html#a42f85dd9bb371792bded477fd5f49729">FlowInfo::doInjection()</a>, <a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow()</a>, and <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b77ee6442d79ae754d5dcf0b5318fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at specific point in a basic block. </p>
<p>The <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is removed from the <em>dead</em> list and is inserted <em>immediately</em> before the specified iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">bl</td><td>is the basic block being inserted into </td></tr>
    <tr><td class="paramname">iter</td><td>indicates exactly where the op is inserted </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#ae9ba79f7c305071ff3cf33eb0ecf915c">BlockBasic::insert()</a>, <a class="el" href="classPcodeOpBank.html#ae9b41955863d0ff9deaabb27e02429be">PcodeOpBank::markAlive()</a>, and <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adb1dd79d78141f89d374e570de21d690">doLiveInject()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#ae6341eb8ca8a8004f1c77a8e8147a286">opInsertBegin()</a>, <a class="el" href="classFuncdata.html#ad544a6136ff019bbd18c45043e9b6900">opInsertEnd()</a>, and <a class="el" href="classFlowInfo.html#a95ba46643484d24fde597996b7aba4c3">FlowInfo::splitBasic()</a>.</p>

</div>
</div>
<a class="anchor" id="a3320ad92e11a48a06e21b8a55395a56b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> after a specific op. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted <em>immediately</em> after the <em>prev</em> op except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">prev</td><td>is the op to insert after </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#ae4dbd2e0b83e5fadebf7186e904921ca">PcodeOp::getBasicIter()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ad644dc33b71c7d421fcd0fb2003407c7">IPTR_IOP</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>, and <a class="el" href="classFuncdata.html#a6b77ee6442d79ae754d5dcf0b5318fca">opInsert()</a>.</p>

<p>Referenced by <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classActionSetCasts.html#a1b6651e4de16fe0bbfe50cd6d105fa61">ActionSetCasts::castOutput()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, <a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, and <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dd86e17a47020d06ac8dfd3bb732fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>follow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> before a specific op. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted <em>immediately</em> before the <em>follow</em> op except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">follow</td><td>is the op to insert before </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classPcodeOp.html#ae4dbd2e0b83e5fadebf7186e904921ca">PcodeOp::getBasicIter()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, and <a class="el" href="classFuncdata.html#a6b77ee6442d79ae754d5dcf0b5318fca">opInsert()</a>.</p>

<p>Referenced by <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classRuleNotDistribute.html#af010b4c83cf55e7c1c858941f72e048b">RuleNotDistribute::applyOp()</a>, <a class="el" href="classRuleAndDistribute.html#aa40f49c92c7f7088f01ffedff4b5700e">RuleAndDistribute::applyOp()</a>, <a class="el" href="classRuleAndCommute.html#a4dd1bf0f7f55f84c7136a9fb4f44120f">RuleAndCommute::applyOp()</a>, <a class="el" href="classRuleAndPiece.html#a21d9a8514b5713b5899f9f84f93b0156">RuleAndPiece::applyOp()</a>, <a class="el" href="classRuleAndCompare.html#a5bbd46f5a5c6969289ce7084c3bac4f7">RuleAndCompare::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleShiftCompare.html#a8104a2a2506b0a63aeba91f4a9d505ba">RuleShiftCompare::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleSignShift.html#a1ab3983eb3e15e13dc388121c1014561">RuleSignShift::applyOp()</a>, <a class="el" href="classRuleShiftPiece.html#a6ba7f2b28202933238d037dd1706992c">RuleShiftPiece::applyOp()</a>, <a class="el" href="classRuleSub2Add.html#adb3ba6d1c2c81fe6bc441ca0e4882e6a">RuleSub2Add::applyOp()</a>, <a class="el" href="classRuleAddMultCollapse.html#a6f9afdaabcba06d6a739e7ff9a148fc3">RuleAddMultCollapse::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleConcatCommute.html#a75dbdeccddc5baf27b6390449b331bcf">RuleConcatCommute::applyOp()</a>, <a class="el" href="classRuleConcatZext.html#aa7e8b70ac971efc988253c8b42e080b7">RuleConcatZext::applyOp()</a>, <a class="el" href="classRuleZextCommute.html#a04f5c4f8e6cc15d700d777d55c788e81">RuleZextCommute::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleConcatZero.html#a0cfa16444e6d4609972b78e5ce83c7e8">RuleConcatZero::applyOp()</a>, <a class="el" href="classRuleConcatLeftShift.html#aca7e943a778d99122e5d3c18f5d77f8f">RuleConcatLeftShift::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleEmbed.html#abd0eb20956c404ec4abcb2776c593086">RuleEmbed::applyOp()</a>, <a class="el" href="classRuleCondNegate.html#a085f7cbc001d8d211be810d8578f4b7a">RuleCondNegate::applyOp()</a>, <a class="el" href="classRulePushPtr.html#a6785d1d9de50ecb56918711aa413d7dc">RulePushPtr::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classRuleSubNormal.html#a257e214dcabe37990f299a02912c75c2">RuleSubNormal::applyOp()</a>, <a class="el" href="classRuleDivTermAdd.html#ad39ae5dc8516af986340cd55e063afcc">RuleDivTermAdd::applyOp()</a>, <a class="el" href="classRuleDivTermAdd2.html#abc720625170593b9f1bd43748c2be78c">RuleDivTermAdd2::applyOp()</a>, <a class="el" href="classRuleDivOpt.html#a8443133b32d917f3b751ba1fa7dee8f1">RuleDivOpt::applyOp()</a>, <a class="el" href="classRuleSignNearMult.html#a37aa70b7da5c91e0d7f8ea81a98869f6">RuleSignNearMult::applyOp()</a>, <a class="el" href="classTransformOp.html#aaa256c05a94f6656cc9474b2bfa52e2b">TransformOp::attemptInsertion()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classActionReturnRecovery.html#adf0e1a63b8760a7cc73b42c8224d0393">ActionReturnRecovery::buildReturnOutput()</a>, <a class="el" href="classActionSetCasts.html#a0543f2c3f7b96033e3a03352700d8c3a">ActionSetCasts::castInput()</a>, <a class="el" href="classRuleConditionalMove_1_1BoolExpress.html#a230d38eace38ddebb91e1dcefc2cead4">RuleConditionalMove::BoolExpress::constructBool()</a>, <a class="el" href="classRuleConditionalMove.html#a5ba9e278f630efc2493621cbcdaea062">RuleConditionalMove::constructNegate()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant()</a>, <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>, and <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6341eb8ca8a8004f1c77a8e8147a286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the beginning of a basic block. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted as the <em>first</em> op in the basic block except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">bl</td><td>is the basic block to insert into </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, and <a class="el" href="classFuncdata.html#a6b77ee6442d79ae754d5dcf0b5318fca">opInsert()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classRuleOrPredicate.html#ae9bd9f602cf43e10c02623d2ee5e6fc7">RuleOrPredicate::applyOp()</a>, <a class="el" href="classRulePullsubMulti.html#ae66401a1bda28e0332a3058b276fdca5">RulePullsubMulti::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleMultiCollapse.html#a65f32f0c3dfaad6ba711cb1c9dc72954">RuleMultiCollapse::applyOp()</a>, <a class="el" href="classRuleConditionalMove.html#a6f63597a783571c793f91a046166845b">RuleConditionalMove::applyOp()</a>, <a class="el" href="classTransformOp.html#aaa256c05a94f6656cc9474b2bfa52e2b">TransformOp::attemptInsertion()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>, <a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, and <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="ad544a6136ff019bbd18c45043e9b6900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the end of a basic block. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted as the <em>last</em> op in the basic block except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">bl</td><td>is the basic block to insert into </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, and <a class="el" href="classFuncdata.html#a6b77ee6442d79ae754d5dcf0b5318fca">opInsert()</a>.</p>

<p>Referenced by <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp()</a>, and <a class="el" href="classFuncdata.html#a7393fde88940742db881c80783e0af0d">nodeSplitRawDuplicate()</a>.</p>

</div>
</div>
<a class="anchor" id="ab34e641f5ee6f2ebf4aa708e21f2b24c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into the operand list for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is set into the given operand slot. Any existing input Varnodes with slot indices equal to or greater than the specified slot are pushed into the next slot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to insert </td></tr>
    <tr><td class="paramname">slot</td><td>is the input index to insert at </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a40a813424f6cac1fbbd987b734771e1d">PcodeOp::insertInput()</a>, and <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>.</p>

<p>Referenced by <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>, <a class="el" href="classRuleNotDistribute.html#af010b4c83cf55e7c1c858941f72e048b">RuleNotDistribute::applyOp()</a>, <a class="el" href="classRuleTransformCpool.html#af499e077d284de28aa52a807b53152de">RuleTransformCpool::applyOp()</a>, <a class="el" href="classRule2Comp2Mult.html#a1a526d775f62b172a92886444b5889a3">Rule2Comp2Mult::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleSubZext.html#abefcd055ea0199a4cf71e5f310996d9b">RuleSubZext::applyOp()</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classActionFuncLink.html#a1eb46aa1ae74eaafce6575727b851dae">ActionFuncLink::funcLinkInput()</a>, <a class="el" href="classFuncdata.html#aa062c200c86923b0f1032d4ab563e716">opDeadAndGone()</a>, and <a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti()</a>.</p>

</div>
</div>
<a class="anchor" id="acdbfab2362e4d4945c3feb7d3f2c42f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opMarkHalt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark given CPUI_RETURN op as a <em>special</em> halt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given CPUI_RETURN op </td></tr>
    <tr><td class="paramname">flag</td><td>is one of <em>halt</em>, <em>badinstruction</em>, <em>unimplemented</em>, <em>noreturn</em>, or <em>missing</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bbafe7021be79a58c1f8ccf3e648b9efa0b">PcodeOp::badinstruction</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba813f16d5a57741bd21c75d111f2a958d">PcodeOp::halt</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba6df0f07720903764525707d48ace7907">PcodeOp::missing</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bbab9c226cb4d7da1741fde87002092ae4f">PcodeOp::noreturn</a>, <a class="el" href="classPcodeOp.html#ad54b6a60862c7a87c2beeb5934ff2359">PcodeOp::setFlag()</a>, and <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba8a2372c854b0e815e12973db2d4ef8b5">PcodeOp::unimplemented</a>.</p>

<p>Referenced by <a class="el" href="classFlowInfo.html#a3d8d1490b85d7291305fc13bd1b63a14">FlowInfo::artificialHalt()</a>, and <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="a84937c2241ea5679280223cc0ec8b202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opRemoveInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a specific input slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the specified slot is unlinked from the op and the slot itself is removed. The slot index for any remaining input Varnodes coming after the specified slot is decreased by one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the index of the specified slot to remove </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput()</a>, and <a class="el" href="classPcodeOp.html#a505c4b6ef1000649651376af9ab20239">PcodeOp::removeInput()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#ad3c3231b5c523e491d65f31ddb688cc1">FuncCallSpecs::abortSpacebaseRelative()</a>, <a class="el" href="classActionStackPtrFlow.html#add8e15c126e69df09fbcdf49e019aafd">ActionStackPtrFlow::adjustLoad()</a>, <a class="el" href="classActionSegmentize.html#a3219ac91c09b6c6061d7e91ad1ed9111">ActionSegmentize::apply()</a>, <a class="el" href="classActionSetCasts.html#a9999706f3347f707e39c28b5a208fbd3">ActionSetCasts::apply()</a>, <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>, <a class="el" href="classRulePiece2Zext.html#aa879d79ce26d031791b5ae7a11908701">RulePiece2Zext::applyOp()</a>, <a class="el" href="classRulePiece2Sext.html#a37acf429e9c05f9f03977b136b3bfc22">RulePiece2Sext::applyOp()</a>, <a class="el" href="classRuleOrMask.html#ab0e9a7d945a09be5c298cd08937ab6a7">RuleOrMask::applyOp()</a>, <a class="el" href="classRuleAndMask.html#a366c5419fa1fb118d35b7f9794d72e47">RuleAndMask::applyOp()</a>, <a class="el" href="classRuleOrConsume.html#a39007f06048c9aca85e9ca5bf3fcbd39">RuleOrConsume::applyOp()</a>, <a class="el" href="classRuleOrCollapse.html#a2b43549e7241357eb9b4c22857270ba1">RuleOrCollapse::applyOp()</a>, <a class="el" href="classRuleNegateIdentity.html#a9de23484c0f96f82044def3765270523">RuleNegateIdentity::applyOp()</a>, <a class="el" href="classRuleOrPredicate.html#ae9bd9f602cf43e10c02623d2ee5e6fc7">RuleOrPredicate::applyOp()</a>, <a class="el" href="classRuleEquality.html#a1eec6d7734884df00533e207ead6de4b">RuleEquality::applyOp()</a>, <a class="el" href="classRuleHighOrderAnd.html#acadd25bbb252e1619bf2acc6d3b89e2e">RuleHighOrderAnd::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classRuleRangeMeld.html#af99e831a0fd88d12ef57c0cd9fe01c1d">RuleRangeMeld::applyOp()</a>, <a class="el" href="classRuleDoubleShift.html#a02b2443037178261d417afd9689de91b">RuleDoubleShift::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classRuleLessEqual.html#ab76fe328e8caf6ab480a60e3fb1927bf">RuleLessEqual::applyOp()</a>, <a class="el" href="classRuleTrivialArith.html#a692632ff3e5fa2bad3ba12b6ff2005be">RuleTrivialArith::applyOp()</a>, <a class="el" href="classRuleTrivialBool.html#a0254986d799ca6fd09ecb6e96288eae1">RuleTrivialBool::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBooleanNegate.html#a8c8aa1437392ae57f49b56f314233bab">RuleBooleanNegate::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleIndirectCollapse.html#a0d4041209c44deabc2baa829c022d642">RuleIndirectCollapse::applyOp()</a>, <a class="el" href="classRuleSborrow.html#a624c5e919a23a5fd208c810aef997c48">RuleSborrow::applyOp()</a>, <a class="el" href="classRuleTrivialShift.html#a373f11af57c1291eac63c4b69afde34a">RuleTrivialShift::applyOp()</a>, <a class="el" href="classRuleIdentityEl.html#ac18d09444f528e99a17e0619c426d1ec">RuleIdentityEl::applyOp()</a>, <a class="el" href="classRuleShiftPiece.html#a6ba7f2b28202933238d037dd1706992c">RuleShiftPiece::applyOp()</a>, <a class="el" href="classRuleCollapseConstants.html#a9dbb37c234aa8599bed3e916bdc15147">RuleCollapseConstants::applyOp()</a>, <a class="el" href="classRuleTransformCpool.html#af499e077d284de28aa52a807b53152de">RuleTransformCpool::applyOp()</a>, <a class="el" href="classRuleCarryElim.html#ab7a660e29b328d6348a1cacace3d9844">RuleCarryElim::applyOp()</a>, <a class="el" href="classRuleLoadVarnode.html#aba1b981179387a727272c5ba7b407777">RuleLoadVarnode::applyOp()</a>, <a class="el" href="classRuleStoreVarnode.html#af2356cc3335eab5bc75ff0d8f5223165">RuleStoreVarnode::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleConcatZext.html#aa7e8b70ac971efc988253c8b42e080b7">RuleConcatZext::applyOp()</a>, <a class="el" href="classRuleZextCommute.html#a04f5c4f8e6cc15d700d777d55c788e81">RuleZextCommute::applyOp()</a>, <a class="el" href="classRuleShiftAnd.html#a46abea946abb40fa7bed25e4157d0f13">RuleShiftAnd::applyOp()</a>, <a class="el" href="classRuleSubCancel.html#afa2cbf94629eeff1cdd4ae0b02ef7821">RuleSubCancel::applyOp()</a>, <a class="el" href="classRuleHumptyDumpty.html#a49a97daa382a5e01626144d914438301">RuleHumptyDumpty::applyOp()</a>, <a class="el" href="classRuleDumptyHump.html#a700703eddec46851943420aa51eefcb5">RuleDumptyHump::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleLess2Zero.html#ac9d89e7b8899c76a40f88b3b0a5a0d74">RuleLess2Zero::applyOp()</a>, <a class="el" href="classRuleLessEqual2Zero.html#a1d41372d5ac60e36cca1ffcb04e33528">RuleLessEqual2Zero::applyOp()</a>, <a class="el" href="classRuleMultNegOne.html#a3a1d3552604a9d5464f23ef332376918">RuleMultNegOne::applyOp()</a>, <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>, <a class="el" href="classRuleSegment.html#ae9c0b0fb9076088f2adf5342f8e100f6">RuleSegment::applyOp()</a>, <a class="el" href="classRuleConditionalMove.html#a6f63597a783571c793f91a046166845b">RuleConditionalMove::applyOp()</a>, <a class="el" href="classRuleIgnoreNan.html#afd2b8e067067db3127664cd2cedfd092">RuleIgnoreNan::applyOp()</a>, <a class="el" href="classRuleFuncPtrEncoding.html#ab4cf320ff9f365e41dde30a21dc7a277">RuleFuncPtrEncoding::applyOp()</a>, <a class="el" href="classRulePopcountBoolXor.html#a943d7f4ea0aecf0544daa2240f82f409">RulePopcountBoolXor::applyOp()</a>, <a class="el" href="classRuleXorSwap.html#a2e5eef7595df5e8d50e51f0f2a9d65a9">RuleXorSwap::applyOp()</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classFuncdata.html#ac96af1ca8355f0c4f8e6582c045f0723">branchRemoveInternal()</a>, <a class="el" href="classRuleOrPredicate.html#a66b43c52914a1d33b326d13380257e08">RuleOrPredicate::checkSingle()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly()</a>, <a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow()</a>, <a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch()</a>, <a class="el" href="classFuncdata.html#aa062c200c86923b0f1032d4ab563e716">opDeadAndGone()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncCallSpecs.html#a01e16ebebb71bdc63fb884c8d0e3b7e3">FuncCallSpecs::paramshiftModifyStop()</a>, <a class="el" href="classFuncdata.html#aa2d635570305e3ea710ade3cf090ba8c">pushBranch()</a>, <a class="el" href="classRulePtrsubCharConstant.html#a1e7496cf33cc149a3f77828b6e92e950">RulePtrsubCharConstant::pushConstFurther()</a>, <a class="el" href="classRulePullsubMulti.html#a913ef535547efd0f181a08dfff49beab">RulePullsubMulti::replaceDescendants()</a>, and <a class="el" href="classFuncCallSpecs.html#a5ad2a3f374049dec6fdf0f9d20295305">FuncCallSpecs::resolveSpacebaseRelative()</a>.</p>

</div>
</div>
<a class="anchor" id="adcad3bfd56955103a031fa6d0e78acec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetAllInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all input Varnodes for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> simultaneously. </p>
<p>All previously existing input Varnodes are unset. The input slots for the op are resized and then filled in from the specified array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to set </td></tr>
    <tr><td class="paramname">vvec</td><td>is the specified array of new input Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput()</a>, and <a class="el" href="classPcodeOp.html#a69ca6b34a4ff983ec0afeddcbae89cf4">PcodeOp::setNumInputs()</a>.</p>

<p>Referenced by <a class="el" href="classActionStackPtrFlow.html#a4f93079a3ade269842842a7fad126a12">ActionStackPtrFlow::analyzeExtraPop()</a>, <a class="el" href="classActionShadowVar.html#aac5164f51e21d4e76da14d7c2063c149">ActionShadowVar::apply()</a>, <a class="el" href="classRulePullsubMulti.html#ae66401a1bda28e0332a3058b276fdca5">RulePullsubMulti::applyOp()</a>, <a class="el" href="classRuleMultiCollapse.html#a65f32f0c3dfaad6ba711cb1c9dc72954">RuleMultiCollapse::applyOp()</a>, <a class="el" href="classRulePtrArith.html#a8b6d5d16ceb0884f97bebd712b9f6852">RulePtrArith::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classActionReturnRecovery.html#adf0e1a63b8760a7cc73b42c8224d0393">ActionReturnRecovery::buildReturnOutput()</a>, <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">FuncCallSpecs::commitNewInputs()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#aa062c200c86923b0f1032d4ab563e716">opDeadAndGone()</a>, and <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>.</p>

</div>
</div>
<a class="anchor" id="aa079e2bd26e92671be79601535236a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific input operand for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the operand <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to set </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is placed </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#adfe298abe2cb0b211c7ad11fdc0012ab">Varnode::addDescend()</a>, <a class="el" href="classVarnode.html#a5b21f0980bc223331c25bf4e609b1254">Varnode::copySymbol()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae">Varnode::isSpacebase()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput()</a>, and <a class="el" href="classPcodeOp.html#a783ff9defe71b8759bba85063908b515">PcodeOp::setInput()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionStackPtrFlow.html#add8e15c126e69df09fbcdf49e019aafd">ActionStackPtrFlow::adjustLoad()</a>, <a class="el" href="classActionSegmentize.html#a3219ac91c09b6c6061d7e91ad1ed9111">ActionSegmentize::apply()</a>, <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>, <a class="el" href="classActionLikelyTrash.html#afbd2ec1783db1f08cedf5b259304f158">ActionLikelyTrash::apply()</a>, <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, <a class="el" href="classRuleOrMask.html#ab0e9a7d945a09be5c298cd08937ab6a7">RuleOrMask::applyOp()</a>, <a class="el" href="classRuleAndMask.html#a366c5419fa1fb118d35b7f9794d72e47">RuleAndMask::applyOp()</a>, <a class="el" href="classRuleAndOrLump.html#aff7dd54db4bd5474329200371c8a3146">RuleAndOrLump::applyOp()</a>, <a class="el" href="classRuleNegateIdentity.html#a9de23484c0f96f82044def3765270523">RuleNegateIdentity::applyOp()</a>, <a class="el" href="classRuleShiftBitops.html#acdfd1b4d0a22a3e8f15d632e810d5737">RuleShiftBitops::applyOp()</a>, <a class="el" href="classRuleRightShiftAnd.html#a8f56fa7366032cdd8e93f04d2031f385">RuleRightShiftAnd::applyOp()</a>, <a class="el" href="classRuleOrPredicate.html#ae9bd9f602cf43e10c02623d2ee5e6fc7">RuleOrPredicate::applyOp()</a>, <a class="el" href="classRuleEquality.html#a1eec6d7734884df00533e207ead6de4b">RuleEquality::applyOp()</a>, <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleNotDistribute.html#af010b4c83cf55e7c1c858941f72e048b">RuleNotDistribute::applyOp()</a>, <a class="el" href="classRuleHighOrderAnd.html#acadd25bbb252e1619bf2acc6d3b89e2e">RuleHighOrderAnd::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classRuleAndDistribute.html#aa40f49c92c7f7088f01ffedff4b5700e">RuleAndDistribute::applyOp()</a>, <a class="el" href="classRuleLessOne.html#ac787cb9aa39e6d205659bdf236920619">RuleLessOne::applyOp()</a>, <a class="el" href="classRuleRangeMeld.html#af99e831a0fd88d12ef57c0cd9fe01c1d">RuleRangeMeld::applyOp()</a>, <a class="el" href="classRuleFloatRange.html#a39c5067872e30f4d32dc229c53504cef">RuleFloatRange::applyOp()</a>, <a class="el" href="classRuleAndCommute.html#a4dd1bf0f7f55f84c7136a9fb4f44120f">RuleAndCommute::applyOp()</a>, <a class="el" href="classRuleAndPiece.html#a21d9a8514b5713b5899f9f84f93b0156">RuleAndPiece::applyOp()</a>, <a class="el" href="classRuleAndCompare.html#a5bbd46f5a5c6969289ce7084c3bac4f7">RuleAndCompare::applyOp()</a>, <a class="el" href="classRuleDoubleSub.html#a5dac7faa4ee8464a136b3bec0e2057ab">RuleDoubleSub::applyOp()</a>, <a class="el" href="classRuleDoubleShift.html#a02b2443037178261d417afd9689de91b">RuleDoubleShift::applyOp()</a>, <a class="el" href="classRuleDoubleArithShift.html#a7aed6e52951397fdcd20aac7d44887e7">RuleDoubleArithShift::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classRuleShiftCompare.html#a8104a2a2506b0a63aeba91f4a9d505ba">RuleShiftCompare::applyOp()</a>, <a class="el" href="classRuleLessEqual.html#ab76fe328e8caf6ab480a60e3fb1927bf">RuleLessEqual::applyOp()</a>, <a class="el" href="classRuleLessNotEqual.html#a08fa964bfe43c6783d801d5c33d46d7a">RuleLessNotEqual::applyOp()</a>, <a class="el" href="classRuleTrivialArith.html#a692632ff3e5fa2bad3ba12b6ff2005be">RuleTrivialArith::applyOp()</a>, <a class="el" href="classRuleTrivialBool.html#a0254986d799ca6fd09ecb6e96288eae1">RuleTrivialBool::applyOp()</a>, <a class="el" href="classRuleZextEliminate.html#a06205a6c85cac93cf2ef1de9e8fc93ff">RuleZextEliminate::applyOp()</a>, <a class="el" href="classRuleZextSless.html#ab27ad1b45b037db695c660850954f04e">RuleZextSless::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBooleanNegate.html#a8c8aa1437392ae57f49b56f314233bab">RuleBooleanNegate::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleIndirectCollapse.html#a0d4041209c44deabc2baa829c022d642">RuleIndirectCollapse::applyOp()</a>, <a class="el" href="classRuleSborrow.html#a624c5e919a23a5fd208c810aef997c48">RuleSborrow::applyOp()</a>, <a class="el" href="classRuleTrivialShift.html#a373f11af57c1291eac63c4b69afde34a">RuleTrivialShift::applyOp()</a>, <a class="el" href="classRuleSignShift.html#a1ab3983eb3e15e13dc388121c1014561">RuleSignShift::applyOp()</a>, <a class="el" href="classRuleTestSign.html#a4ce84c6a3996f9877c053bb41169bf7e">RuleTestSign::applyOp()</a>, <a class="el" href="classRuleShift2Mult.html#a72b5072e94341325dd65f0d48dbb2a04">RuleShift2Mult::applyOp()</a>, <a class="el" href="classRuleShiftPiece.html#a6ba7f2b28202933238d037dd1706992c">RuleShiftPiece::applyOp()</a>, <a class="el" href="classRuleCollapseConstants.html#a9dbb37c234aa8599bed3e916bdc15147">RuleCollapseConstants::applyOp()</a>, <a class="el" href="classRuleTransformCpool.html#af499e077d284de28aa52a807b53152de">RuleTransformCpool::applyOp()</a>, <a class="el" href="classRulePropagateCopy.html#a4204e280e01206f9de2f082afffdce81">RulePropagateCopy::applyOp()</a>, <a class="el" href="classRuleCarryElim.html#ab7a660e29b328d6348a1cacace3d9844">RuleCarryElim::applyOp()</a>, <a class="el" href="classRuleSub2Add.html#adb3ba6d1c2c81fe6bc441ca0e4882e6a">RuleSub2Add::applyOp()</a>, <a class="el" href="classRuleXorCollapse.html#a66798e6a5cdb2306f61f2596db611045">RuleXorCollapse::applyOp()</a>, <a class="el" href="classRuleAddMultCollapse.html#a6f9afdaabcba06d6a739e7ff9a148fc3">RuleAddMultCollapse::applyOp()</a>, <a class="el" href="classRuleLoadVarnode.html#aba1b981179387a727272c5ba7b407777">RuleLoadVarnode::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleConcatCommute.html#a75dbdeccddc5baf27b6390449b331bcf">RuleConcatCommute::applyOp()</a>, <a class="el" href="classRuleConcatZext.html#aa7e8b70ac971efc988253c8b42e080b7">RuleConcatZext::applyOp()</a>, <a class="el" href="classRuleZextCommute.html#a04f5c4f8e6cc15d700d777d55c788e81">RuleZextCommute::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleConcatZero.html#a0cfa16444e6d4609972b78e5ce83c7e8">RuleConcatZero::applyOp()</a>, <a class="el" href="classRuleConcatLeftShift.html#aca7e943a778d99122e5d3c18f5d77f8f">RuleConcatLeftShift::applyOp()</a>, <a class="el" href="classRuleSubZext.html#abefcd055ea0199a4cf71e5f310996d9b">RuleSubZext::applyOp()</a>, <a class="el" href="classRuleSubCancel.html#afa2cbf94629eeff1cdd4ae0b02ef7821">RuleSubCancel::applyOp()</a>, <a class="el" href="classRuleShiftSub.html#aea3b654c2ff4472bdb597f16d660df9c">RuleShiftSub::applyOp()</a>, <a class="el" href="classRuleHumptyDumpty.html#a49a97daa382a5e01626144d914438301">RuleHumptyDumpty::applyOp()</a>, <a class="el" href="classRuleDumptyHump.html#a700703eddec46851943420aa51eefcb5">RuleDumptyHump::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleEmbed.html#abd0eb20956c404ec4abcb2776c593086">RuleEmbed::applyOp()</a>, <a class="el" href="classRuleSwitchSingle.html#ab884de26def65edb9ade3b981c6983e1">RuleSwitchSingle::applyOp()</a>, <a class="el" href="classRuleCondNegate.html#a085f7cbc001d8d211be810d8578f4b7a">RuleCondNegate::applyOp()</a>, <a class="el" href="classRuleLess2Zero.html#ac9d89e7b8899c76a40f88b3b0a5a0d74">RuleLess2Zero::applyOp()</a>, <a class="el" href="classRuleLessEqual2Zero.html#a1d41372d5ac60e36cca1ffcb04e33528">RuleLessEqual2Zero::applyOp()</a>, <a class="el" href="classRuleSLess2Zero.html#aee3dc812afcd3baeef9d3995971c098a">RuleSLess2Zero::applyOp()</a>, <a class="el" href="classRuleEqual2Zero.html#a4451f6e9c8236e504f80f6c57edda360">RuleEqual2Zero::applyOp()</a>, <a class="el" href="classRuleEqual2Constant.html#a99da234ae056794a853e6eb2466096e7">RuleEqual2Constant::applyOp()</a>, <a class="el" href="classRuleStructOffset0.html#a925e149a62faa06ea1e64a9b9b52a47f">RuleStructOffset0::applyOp()</a>, <a class="el" href="classRulePushPtr.html#a6785d1d9de50ecb56918711aa413d7dc">RulePushPtr::applyOp()</a>, <a class="el" href="classRuleAddUnsigned.html#a07c326702413b71711277439c247b932">RuleAddUnsigned::applyOp()</a>, <a class="el" href="classRule2Comp2Sub.html#a016089f19466049e949fd664649c27e4">Rule2Comp2Sub::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>, <a class="el" href="classRuleSubNormal.html#a257e214dcabe37990f299a02912c75c2">RuleSubNormal::applyOp()</a>, <a class="el" href="classRuleDivTermAdd.html#ad39ae5dc8516af986340cd55e063afcc">RuleDivTermAdd::applyOp()</a>, <a class="el" href="classRuleDivTermAdd2.html#abc720625170593b9f1bd43748c2be78c">RuleDivTermAdd2::applyOp()</a>, <a class="el" href="classRuleDivOpt.html#a8443133b32d917f3b751ba1fa7dee8f1">RuleDivOpt::applyOp()</a>, <a class="el" href="classRuleSignDiv2.html#a2c19f27ad4e779fd9fc6a4bce1e16be5">RuleSignDiv2::applyOp()</a>, <a class="el" href="classRuleSignForm.html#a4d0250a44bacb1048487280de4ffcd3d">RuleSignForm::applyOp()</a>, <a class="el" href="classRuleSignNearMult.html#a37aa70b7da5c91e0d7f8ea81a98869f6">RuleSignNearMult::applyOp()</a>, <a class="el" href="classRuleModOpt.html#ab868b1ba7b5ba982da1c316637d72c1e">RuleModOpt::applyOp()</a>, <a class="el" href="classRuleSegment.html#ae9c0b0fb9076088f2adf5342f8e100f6">RuleSegment::applyOp()</a>, <a class="el" href="classRuleNegateNegate.html#a02dccbffcee07b90e8a7f6aab7bf1ccf">RuleNegateNegate::applyOp()</a>, <a class="el" href="classRuleConditionalMove.html#a6f63597a783571c793f91a046166845b">RuleConditionalMove::applyOp()</a>, <a class="el" href="classRuleFloatCast.html#aa220e61357bdc27e129e2f2dda089c1f">RuleFloatCast::applyOp()</a>, <a class="el" href="classRuleIgnoreNan.html#afd2b8e067067db3127664cd2cedfd092">RuleIgnoreNan::applyOp()</a>, <a class="el" href="classRuleThreeWayCompare.html#af661958d83d132fd75bf054671649a27">RuleThreeWayCompare::applyOp()</a>, <a class="el" href="classRulePopcountBoolXor.html#a943d7f4ea0aecf0544daa2240f82f409">RulePopcountBoolXor::applyOp()</a>, <a class="el" href="classRuleXorSwap.html#a2e5eef7595df5e8d50e51f0f2a9d65a9">RuleXorSwap::applyOp()</a>, <a class="el" href="classFlowInfo.html#a3d8d1490b85d7291305fc13bd1b63a14">FlowInfo::artificialHalt()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classActionReturnRecovery.html#adf0e1a63b8760a7cc73b42c8224d0393">ActionReturnRecovery::buildReturnOutput()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classRuleSubCommute.html#a98082ac7f5395dbc0fd603a876417250">RuleSubCommute::cancelExtensions()</a>, <a class="el" href="classActionSetCasts.html#a0543f2c3f7b96033e3a03352700d8c3a">ActionSetCasts::castInput()</a>, <a class="el" href="classActionSetCasts.html#a1b6651e4de16fe0bbfe50cd6d105fa61">ActionSetCasts::castOutput()</a>, <a class="el" href="classFlowInfo.html#a5ee6e359bad18470fccb70737431794b">FlowInfo::checkContainedCall()</a>, <a class="el" href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">FuncCallSpecs::checkInputTrialUse()</a>, <a class="el" href="classRuleOrPredicate.html#a66b43c52914a1d33b326d13380257e08">RuleOrPredicate::checkSingle()</a>, <a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp()</a>, <a class="el" href="classFuncdata.html#a5027da6d3c7a05a262e332b0c22c7c43">collapseIntMultMult()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classRuleConditionalMove_1_1BoolExpress.html#a230d38eace38ddebb91e1dcefc2cead4">RuleConditionalMove::BoolExpress::constructBool()</a>, <a class="el" href="classRuleConditionalMove.html#a5ba9e278f630efc2493621cbcdaea062">RuleConditionalMove::constructNegate()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">FuncCallSpecs::deindirect()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>, <a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly()</a>, <a class="el" href="classJumpBasic.html#a8e275e4e4165100780429e12fac9b39b">JumpBasic::foldInNormalization()</a>, <a class="el" href="classJumpAssisted.html#aa36ee3e6e3749c41a43a3801579095eb">JumpAssisted::foldInNormalization()</a>, <a class="el" href="classJumpBasic.html#a27ac3c21abdfc602f857802a7479c6d4">JumpBasic::foldInOneGuard()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, <a class="el" href="classFlowInfo.html#acb0b9cbb6144cd2963c63072d6d72882">FlowInfo::inlineClone()</a>, <a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow()</a>, <a class="el" href="classRuleDivOpt.html#ad169dc0aa631077e01ffa0de7e1ce464">RuleDivOpt::moveSignBitExtraction()</a>, <a class="el" href="classActionDeadCode.html#a8d2d35c0f22f6fcb3ddb07681c0a474a">ActionDeadCode::neverConsumed()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore()</a>, <a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch()</a>, <a class="el" href="funcdata_8hh.html#a0a7a4ee0c419ed55c99f44d914284828">opFlipInPlaceExecute()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classFuncdata.html#ab34e641f5ee6f2ebf4aa708e21f2b24c">opInsertInput()</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">opSetAllInput()</a>, <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, <a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow()</a>, <a class="el" href="classTransformManager.html#a94ac66242d8986c714bcb608f88d87bb">TransformManager::placeInputs()</a>, <a class="el" href="classActionConditionalConst.html#ab477e0173dc6a85b8a7aeee5c0c41bfc">ActionConditionalConst::propagateConstant()</a>, <a class="el" href="classRulePtrsubCharConstant.html#a1e7496cf33cc149a3f77828b6e92e950">RulePtrsubCharConstant::pushConstFurther()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classRulePullsubMulti.html#a913ef535547efd0f181a08dfff49beab">RulePullsubMulti::replaceDescendants()</a>, <a class="el" href="classFuncdata.html#a223a70ddb5e33f446fca85bc3b369911">replaceLessequal()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, <a class="el" href="classFlowInfo.html#af742b3c41b0806308c4465de7a0d4e4b">FlowInfo::setupCallindSpecs()</a>, <a class="el" href="classFlowInfo.html#aa32bf6a3cc3aa4ad93319d7a4a5385cf">FlowInfo::setupCallSpecs()</a>, <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant()</a>, <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>, <a class="el" href="classFuncdata.html#aab7f940f85609d395283520eca3a71f0">totalReplace()</a>, <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>, <a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">truncatedFlow()</a>, and <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9dbf52668db4a1923537e2128719181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the op-code for a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">opc</td><td>is the op-code to set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpBank.html#a66328024453859527245d5143755adc6">PcodeOpBank::changeOpcode()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classArchitecture.html#a3a9badb712693d9abec7e21abc20fde1">Architecture::inst</a>, and <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionStackPtrFlow.html#add8e15c126e69df09fbcdf49e019aafd">ActionStackPtrFlow::adjustLoad()</a>, <a class="el" href="classActionStackPtrFlow.html#a4f93079a3ade269842842a7fad126a12">ActionStackPtrFlow::analyzeExtraPop()</a>, <a class="el" href="classActionSegmentize.html#a3219ac91c09b6c6061d7e91ad1ed9111">ActionSegmentize::apply()</a>, <a class="el" href="classActionShadowVar.html#aac5164f51e21d4e76da14d7c2063c149">ActionShadowVar::apply()</a>, <a class="el" href="classActionConstbase.html#acdc2434caa56bded4425c19e0b68bdfc">ActionConstbase::apply()</a>, <a class="el" href="classActionSetCasts.html#a9999706f3347f707e39c28b5a208fbd3">ActionSetCasts::apply()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionExtraPopSetup.html#a1518c4ca7772ccb59b6cde0857cf657c">ActionExtraPopSetup::apply()</a>, <a class="el" href="classRuleCollectTerms.html#aae26ebf9404cb382f3b373dccbc64c69">RuleCollectTerms::applyOp()</a>, <a class="el" href="classRulePiece2Zext.html#aa879d79ce26d031791b5ae7a11908701">RulePiece2Zext::applyOp()</a>, <a class="el" href="classRulePiece2Sext.html#a37acf429e9c05f9f03977b136b3bfc22">RulePiece2Sext::applyOp()</a>, <a class="el" href="classRuleBxor2NotEqual.html#a82882cbb68487e82f99e41b6753ca21b">RuleBxor2NotEqual::applyOp()</a>, <a class="el" href="classRuleOrMask.html#ab0e9a7d945a09be5c298cd08937ab6a7">RuleOrMask::applyOp()</a>, <a class="el" href="classRuleAndMask.html#a366c5419fa1fb118d35b7f9794d72e47">RuleAndMask::applyOp()</a>, <a class="el" href="classRuleOrConsume.html#a39007f06048c9aca85e9ca5bf3fcbd39">RuleOrConsume::applyOp()</a>, <a class="el" href="classRuleOrCollapse.html#a2b43549e7241357eb9b4c22857270ba1">RuleOrCollapse::applyOp()</a>, <a class="el" href="classRuleNegateIdentity.html#a9de23484c0f96f82044def3765270523">RuleNegateIdentity::applyOp()</a>, <a class="el" href="classRuleOrPredicate.html#ae9bd9f602cf43e10c02623d2ee5e6fc7">RuleOrPredicate::applyOp()</a>, <a class="el" href="classRuleEquality.html#a1eec6d7734884df00533e207ead6de4b">RuleEquality::applyOp()</a>, <a class="el" href="classRulePullsubMulti.html#ae66401a1bda28e0332a3058b276fdca5">RulePullsubMulti::applyOp()</a>, <a class="el" href="classRulePullsubIndirect.html#ae8c0c6b22bd0890c5b9ef806ceb91e58">RulePullsubIndirect::applyOp()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleNotDistribute.html#af010b4c83cf55e7c1c858941f72e048b">RuleNotDistribute::applyOp()</a>, <a class="el" href="classRuleHighOrderAnd.html#acadd25bbb252e1619bf2acc6d3b89e2e">RuleHighOrderAnd::applyOp()</a>, <a class="el" href="classRuleDoubleLoad.html#afbb821bf5ea445001a47351ec57bbeb1">RuleDoubleLoad::applyOp()</a>, <a class="el" href="classRuleAndDistribute.html#aa40f49c92c7f7088f01ffedff4b5700e">RuleAndDistribute::applyOp()</a>, <a class="el" href="classRuleLessOne.html#ac787cb9aa39e6d205659bdf236920619">RuleLessOne::applyOp()</a>, <a class="el" href="classRuleRangeMeld.html#af99e831a0fd88d12ef57c0cd9fe01c1d">RuleRangeMeld::applyOp()</a>, <a class="el" href="classRuleFloatRange.html#a39c5067872e30f4d32dc229c53504cef">RuleFloatRange::applyOp()</a>, <a class="el" href="classRuleAndCommute.html#a4dd1bf0f7f55f84c7136a9fb4f44120f">RuleAndCommute::applyOp()</a>, <a class="el" href="classRuleAndPiece.html#a21d9a8514b5713b5899f9f84f93b0156">RuleAndPiece::applyOp()</a>, <a class="el" href="classRuleAndCompare.html#a5bbd46f5a5c6969289ce7084c3bac4f7">RuleAndCompare::applyOp()</a>, <a class="el" href="classRuleDoubleShift.html#a02b2443037178261d417afd9689de91b">RuleDoubleShift::applyOp()</a>, <a class="el" href="classRuleConcatShift.html#a7954f9333718c1f1da94e117f1f5e9b1">RuleConcatShift::applyOp()</a>, <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classRuleShiftCompare.html#a8104a2a2506b0a63aeba91f4a9d505ba">RuleShiftCompare::applyOp()</a>, <a class="el" href="classRuleLessEqual.html#ab76fe328e8caf6ab480a60e3fb1927bf">RuleLessEqual::applyOp()</a>, <a class="el" href="classRuleLessNotEqual.html#a08fa964bfe43c6783d801d5c33d46d7a">RuleLessNotEqual::applyOp()</a>, <a class="el" href="classRuleTrivialArith.html#a692632ff3e5fa2bad3ba12b6ff2005be">RuleTrivialArith::applyOp()</a>, <a class="el" href="classRuleTrivialBool.html#a0254986d799ca6fd09ecb6e96288eae1">RuleTrivialBool::applyOp()</a>, <a class="el" href="classRuleSlessToLess.html#add6def135ebd895fd30990297c3dd280">RuleSlessToLess::applyOp()</a>, <a class="el" href="classRuleZextSless.html#ab27ad1b45b037db695c660850954f04e">RuleZextSless::applyOp()</a>, <a class="el" href="classRuleBitUndistribute.html#a01122a111d9e7ff6d741128cb8d9999d">RuleBitUndistribute::applyOp()</a>, <a class="el" href="classRuleBooleanNegate.html#a8c8aa1437392ae57f49b56f314233bab">RuleBooleanNegate::applyOp()</a>, <a class="el" href="classRuleBoolZext.html#a167cc1b2d30a03f4efda236b63fa1838">RuleBoolZext::applyOp()</a>, <a class="el" href="classRuleLogic2Bool.html#a1e63e4098d4474ca67d56d4e0118fb82">RuleLogic2Bool::applyOp()</a>, <a class="el" href="classRuleIndirectCollapse.html#a0d4041209c44deabc2baa829c022d642">RuleIndirectCollapse::applyOp()</a>, <a class="el" href="classRuleMultiCollapse.html#a65f32f0c3dfaad6ba711cb1c9dc72954">RuleMultiCollapse::applyOp()</a>, <a class="el" href="classRuleSborrow.html#a624c5e919a23a5fd208c810aef997c48">RuleSborrow::applyOp()</a>, <a class="el" href="classRuleTrivialShift.html#a373f11af57c1291eac63c4b69afde34a">RuleTrivialShift::applyOp()</a>, <a class="el" href="classRuleSignShift.html#a1ab3983eb3e15e13dc388121c1014561">RuleSignShift::applyOp()</a>, <a class="el" href="classRuleTestSign.html#a4ce84c6a3996f9877c053bb41169bf7e">RuleTestSign::applyOp()</a>, <a class="el" href="classRuleIdentityEl.html#ac18d09444f528e99a17e0619c426d1ec">RuleIdentityEl::applyOp()</a>, <a class="el" href="classRuleShift2Mult.html#a72b5072e94341325dd65f0d48dbb2a04">RuleShift2Mult::applyOp()</a>, <a class="el" href="classRuleShiftPiece.html#a6ba7f2b28202933238d037dd1706992c">RuleShiftPiece::applyOp()</a>, <a class="el" href="classRuleCollapseConstants.html#a9dbb37c234aa8599bed3e916bdc15147">RuleCollapseConstants::applyOp()</a>, <a class="el" href="classRuleTransformCpool.html#af499e077d284de28aa52a807b53152de">RuleTransformCpool::applyOp()</a>, <a class="el" href="classRule2Comp2Mult.html#a1a526d775f62b172a92886444b5889a3">Rule2Comp2Mult::applyOp()</a>, <a class="el" href="classRuleCarryElim.html#ab7a660e29b328d6348a1cacace3d9844">RuleCarryElim::applyOp()</a>, <a class="el" href="classRuleSub2Add.html#adb3ba6d1c2c81fe6bc441ca0e4882e6a">RuleSub2Add::applyOp()</a>, <a class="el" href="classRuleAddMultCollapse.html#a6f9afdaabcba06d6a739e7ff9a148fc3">RuleAddMultCollapse::applyOp()</a>, <a class="el" href="classRuleLoadVarnode.html#aba1b981179387a727272c5ba7b407777">RuleLoadVarnode::applyOp()</a>, <a class="el" href="classRuleStoreVarnode.html#af2356cc3335eab5bc75ff0d8f5223165">RuleStoreVarnode::applyOp()</a>, <a class="el" href="classRuleSubExtComm.html#a3a2efa5df8447bd6c5423d5829a36de0">RuleSubExtComm::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleConcatCommute.html#a75dbdeccddc5baf27b6390449b331bcf">RuleConcatCommute::applyOp()</a>, <a class="el" href="classRuleConcatZext.html#aa7e8b70ac971efc988253c8b42e080b7">RuleConcatZext::applyOp()</a>, <a class="el" href="classRuleZextCommute.html#a04f5c4f8e6cc15d700d777d55c788e81">RuleZextCommute::applyOp()</a>, <a class="el" href="classRuleZextShiftZext.html#af3714cc3a4c7d45605a720c076802f98">RuleZextShiftZext::applyOp()</a>, <a class="el" href="classRuleShiftAnd.html#a46abea946abb40fa7bed25e4157d0f13">RuleShiftAnd::applyOp()</a>, <a class="el" href="classRuleConcatZero.html#a0cfa16444e6d4609972b78e5ce83c7e8">RuleConcatZero::applyOp()</a>, <a class="el" href="classRuleConcatLeftShift.html#aca7e943a778d99122e5d3c18f5d77f8f">RuleConcatLeftShift::applyOp()</a>, <a class="el" href="classRuleSubZext.html#abefcd055ea0199a4cf71e5f310996d9b">RuleSubZext::applyOp()</a>, <a class="el" href="classRuleSubCancel.html#afa2cbf94629eeff1cdd4ae0b02ef7821">RuleSubCancel::applyOp()</a>, <a class="el" href="classRuleHumptyDumpty.html#a49a97daa382a5e01626144d914438301">RuleHumptyDumpty::applyOp()</a>, <a class="el" href="classRuleDumptyHump.html#a700703eddec46851943420aa51eefcb5">RuleDumptyHump::applyOp()</a>, <a class="el" href="classRuleHumptyOr.html#a247cf69f4d753d28a0bcaa14d8cf0abe">RuleHumptyOr::applyOp()</a>, <a class="el" href="classRuleEmbed.html#abd0eb20956c404ec4abcb2776c593086">RuleEmbed::applyOp()</a>, <a class="el" href="classRuleSwitchSingle.html#ab884de26def65edb9ade3b981c6983e1">RuleSwitchSingle::applyOp()</a>, <a class="el" href="classRuleCondNegate.html#a085f7cbc001d8d211be810d8578f4b7a">RuleCondNegate::applyOp()</a>, <a class="el" href="classRuleBoolNegate.html#a0cc46713ccb8464cc054c5eef9ad5de1">RuleBoolNegate::applyOp()</a>, <a class="el" href="classRuleLess2Zero.html#ac9d89e7b8899c76a40f88b3b0a5a0d74">RuleLess2Zero::applyOp()</a>, <a class="el" href="classRuleLessEqual2Zero.html#a1d41372d5ac60e36cca1ffcb04e33528">RuleLessEqual2Zero::applyOp()</a>, <a class="el" href="classRuleSLess2Zero.html#aee3dc812afcd3baeef9d3995971c098a">RuleSLess2Zero::applyOp()</a>, <a class="el" href="classRulePtrArith.html#a8b6d5d16ceb0884f97bebd712b9f6852">RulePtrArith::applyOp()</a>, <a class="el" href="classRulePushPtr.html#a6785d1d9de50ecb56918711aa413d7dc">RulePushPtr::applyOp()</a>, <a class="el" href="classRulePtrsubUndo.html#abba2872c347b72aab45c05d4a674d555">RulePtrsubUndo::applyOp()</a>, <a class="el" href="classRuleMultNegOne.html#a3a1d3552604a9d5464f23ef332376918">RuleMultNegOne::applyOp()</a>, <a class="el" href="classRuleAddUnsigned.html#a07c326702413b71711277439c247b932">RuleAddUnsigned::applyOp()</a>, <a class="el" href="classRule2Comp2Sub.html#a016089f19466049e949fd664649c27e4">Rule2Comp2Sub::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>, <a class="el" href="classRuleSubNormal.html#a257e214dcabe37990f299a02912c75c2">RuleSubNormal::applyOp()</a>, <a class="el" href="classRulePositiveDiv.html#a815f9abdcf150aab9ad8921ab9fba461">RulePositiveDiv::applyOp()</a>, <a class="el" href="classRuleDivTermAdd.html#ad39ae5dc8516af986340cd55e063afcc">RuleDivTermAdd::applyOp()</a>, <a class="el" href="classRuleDivTermAdd2.html#abc720625170593b9f1bd43748c2be78c">RuleDivTermAdd2::applyOp()</a>, <a class="el" href="classRuleDivOpt.html#a8443133b32d917f3b751ba1fa7dee8f1">RuleDivOpt::applyOp()</a>, <a class="el" href="classRuleSignDiv2.html#a2c19f27ad4e779fd9fc6a4bce1e16be5">RuleSignDiv2::applyOp()</a>, <a class="el" href="classRuleSignForm.html#a4d0250a44bacb1048487280de4ffcd3d">RuleSignForm::applyOp()</a>, <a class="el" href="classRuleSignNearMult.html#a37aa70b7da5c91e0d7f8ea81a98869f6">RuleSignNearMult::applyOp()</a>, <a class="el" href="classRuleModOpt.html#ab868b1ba7b5ba982da1c316637d72c1e">RuleModOpt::applyOp()</a>, <a class="el" href="classRuleSegment.html#ae9c0b0fb9076088f2adf5342f8e100f6">RuleSegment::applyOp()</a>, <a class="el" href="classRuleNegateNegate.html#a02dccbffcee07b90e8a7f6aab7bf1ccf">RuleNegateNegate::applyOp()</a>, <a class="el" href="classRuleConditionalMove.html#a6f63597a783571c793f91a046166845b">RuleConditionalMove::applyOp()</a>, <a class="el" href="classRuleFloatCast.html#aa220e61357bdc27e129e2f2dda089c1f">RuleFloatCast::applyOp()</a>, <a class="el" href="classRuleIgnoreNan.html#afd2b8e067067db3127664cd2cedfd092">RuleIgnoreNan::applyOp()</a>, <a class="el" href="classRuleFuncPtrEncoding.html#ab4cf320ff9f365e41dde30a21dc7a277">RuleFuncPtrEncoding::applyOp()</a>, <a class="el" href="classRuleThreeWayCompare.html#af661958d83d132fd75bf054671649a27">RuleThreeWayCompare::applyOp()</a>, <a class="el" href="classRulePopcountBoolXor.html#a943d7f4ea0aecf0544daa2240f82f409">RulePopcountBoolXor::applyOp()</a>, <a class="el" href="classRuleXorSwap.html#a2e5eef7595df5e8d50e51f0f2a9d65a9">RuleXorSwap::applyOp()</a>, <a class="el" href="classFlowInfo.html#a3d8d1490b85d7291305fc13bd1b63a14">FlowInfo::artificialHalt()</a>, <a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">FuncCallSpecs::buildInputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classActionReturnRecovery.html#adf0e1a63b8760a7cc73b42c8224d0393">ActionReturnRecovery::buildReturnOutput()</a>, <a class="el" href="classRulePullsubMulti.html#a9195ceded3ce1f8d7d12bb52c8e268db">RulePullsubMulti::buildSubpiece()</a>, <a class="el" href="classActionSetCasts.html#a0543f2c3f7b96033e3a03352700d8c3a">ActionSetCasts::castInput()</a>, <a class="el" href="classActionSetCasts.html#a1b6651e4de16fe0bbfe50cd6d105fa61">ActionSetCasts::castOutput()</a>, <a class="el" href="classFlowInfo.html#a5ee6e359bad18470fccb70737431794b">FlowInfo::checkContainedCall()</a>, <a class="el" href="classRuleOrPredicate.html#a66b43c52914a1d33b326d13380257e08">RuleOrPredicate::checkSingle()</a>, <a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classRuleConditionalMove_1_1BoolExpress.html#a230d38eace38ddebb91e1dcefc2cead4">RuleConditionalMove::BoolExpress::constructBool()</a>, <a class="el" href="classRuleConditionalMove.html#a5ba9e278f630efc2493621cbcdaea062">RuleConditionalMove::constructNegate()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">FuncCallSpecs::deindirect()</a>, <a class="el" href="classFuncdata.html#ac0d6d87b91d72d3695a4da052e60ee58">descend2Undef()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>, <a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, <a class="el" href="classFlowInfo.html#acb0b9cbb6144cd2963c63072d6d72882">FlowInfo::inlineClone()</a>, <a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp()</a>, <a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore()</a>, <a class="el" href="classFuncdata.html#a51c5acfe4a404779a418095011ed2815">nodeSplitCloneOp()</a>, <a class="el" href="classFuncdata.html#a4aaf9bd74b73972d2d453866631dbd1e">nodeSplitInputPatch()</a>, <a class="el" href="funcdata_8hh.html#a0a7a4ee0c419ed55c99f44d914284828">opFlipInPlaceExecute()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad()</a>, <a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore()</a>, <a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd()</a>, <a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti()</a>, <a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow()</a>, <a class="el" href="classFuncdata.html#aa2d635570305e3ea710ade3cf090ba8c">pushBranch()</a>, <a class="el" href="classRulePtrsubCharConstant.html#a1e7496cf33cc149a3f77828b6e92e950">RulePtrsubCharConstant::pushConstFurther()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classRulePullsubMulti.html#a913ef535547efd0f181a08dfff49beab">RulePullsubMulti::replaceDescendants()</a>, <a class="el" href="classFuncdata.html#a223a70ddb5e33f446fca85bc3b369911">replaceLessequal()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, <a class="el" href="classFlowInfo.html#af742b3c41b0806308c4465de7a0d4e4b">FlowInfo::setupCallindSpecs()</a>, <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant()</a>, <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>, <a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant()</a>, <a class="el" href="classFlowInfo.html#ae2f7f6ff7a348b02fae44fe60c284600">FlowInfo::truncateIndirectJump()</a>, and <a class="el" href="classRulePtrFlow.html#a8240ce1ac541cf84cd6f512ebadbec08">RulePtrFlow::truncatePointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2bd3523c574c5b303728ef4d880ec3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFuncdata.html#ab91b54da6501e12d4ad1e81ab5d0e5c4">opUnsetOutput()</a>, <a class="el" href="classVarnodeBank.html#ac151db372e9299db20ad0808140877e1">VarnodeBank::setDef()</a>, <a class="el" href="classPcodeOp.html#a965b9f3be5f7c3df2ed4b71aa83dbf04">PcodeOp::setOutput()</a>, <a class="el" href="classFuncdata.html#af7412778106b02b163e6d685deb826db">setVarnodeProperties()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a346f3bfeee9d7233be7a17387ebc553f">RuleSubCommute::applyOp()</a>, <a class="el" href="classRuleSubZext.html#abefcd055ea0199a4cf71e5f310996d9b">RuleSubZext::applyOp()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">FuncCallSpecs::buildOutputFromTrials()</a>, <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">AddTreeState::buildTree()</a>, <a class="el" href="classActionSetCasts.html#a1b6651e4de16fe0bbfe50cd6d105fa61">ActionSetCasts::castOutput()</a>, <a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classSubvariableFlow.html#a75dd5e28aa46641f1561b1c51f0876c1">SubvariableFlow::doReplacement()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile()</a>, and <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>.</p>

</div>
</div>
<a class="anchor" id="a37b36505bab6f7c5676157288e65d5c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::opStackLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LOAD expression at an offset relative to a <em>spacebase</em> register for a given address space. </p>
<p>The <em>spacebase</em> register is looked up for the given address space, or an optional previously existing register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be provided. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">off</td><td>is the offset to calculate relative to the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">sz</td><td>is the size of the desire LOAD in bytes </td></tr>
    <tr><td class="paramname">op</td><td>is the insertion point <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">stackref</td><td>is the <em>spacebase</em> register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (if available) </td></tr>
    <tr><td class="paramname">insertafter</td><td>is <b>true</b> if new ops are inserted <em>after</em> the insertion point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>unique</em> space <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the result of the LOAD </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classAddrSpace.html#a5971d35628c019b97c34a4b90001a5f8">AddrSpace::getContain()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">newVarnodeSpace()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">FuncCallSpecs::buildParam()</a>, <a class="el" href="classActionFuncLink.html#a1eb46aa1ae74eaafce6575727b851dae">ActionFuncLink::funcLinkInput()</a>, and <a class="el" href="classFuncdata.html#a65cb6cda676ceb9a33f8e6eef9e1e962">target()</a>.</p>

</div>
</div>
<a class="anchor" id="a4582ad34b4e7c851d92db8544999eaf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::opStackStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a STORE expression at an offset relative to a <em>spacebase</em> register for a given address space. </p>
<p>The <em>spacebase</em> register is looked up for the given address space. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> value being stored must still be set on the returned <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">off</td><td>is the offset to calculate relative to the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">op</td><td>is the insertion point <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">insertafter</td><td>is <b>true</b> if new ops are inserted <em>after</em> the insertion point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the STORE <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a14ab8d826af51873faa33b33e2bbc5fb">CPUI_STORE</a>, <a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classAddrSpace.html#a5971d35628c019b97c34a4b90001a5f8">AddrSpace::getContain()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">newVarnodeSpace()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a65cb6cda676ceb9a33f8e6eef9e1e962">target()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ae30fdfbe33ecfa6668b5579ae3e82a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSwapInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two input operands in the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>This is convenience method that is more efficient than call <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63" title="Set a specific input operand for the given PcodeOp. ">opSetInput()</a> twice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot1</td><td>is the first input slot being switched </td></tr>
    <tr><td class="paramname">slot2</td><td>is the second input slot </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, and <a class="el" href="classPcodeOp.html#a783ff9defe71b8759bba85063908b515">PcodeOp::setInput()</a>.</p>

<p>Referenced by <a class="el" href="classActionConstantPtr.html#a3667d599128a545967351ba54f4cce42">ActionConstantPtr::apply()</a>, <a class="el" href="classRuleTermOrder.html#a3f3c26d28f966bd5cbc24c056f0c324b">RuleTermOrder::applyOp()</a>, <a class="el" href="classRuleBoolNegate.html#a0cc46713ccb8464cc054c5eef9ad5de1">RuleBoolNegate::applyOp()</a>, <a class="el" href="funcdata_8hh.html#a0a7a4ee0c419ed55c99f44d914284828">opFlipInPlaceExecute()</a>, and <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="ad74d3baa2516f448e7ab5f9a8151b572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUndoPtradd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a CPUI_PTRADD back into a CPUI_INT_ADD. </p>
<p>Convert the given CPUI_PTRADD into the equivalent CPUI_INT_ADD. This may involve inserting a CPUI_INT_MULT <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. If finalization is requested and a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is needed, the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is marked as <em>implicit</em> and has its data-type set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given PTRADD </td></tr>
    <tr><td class="paramname">finalize</td><td>is <b>true</b> if finalization is needed for any new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af4e88fc0408c2594dae2615b093aa68b">CPUI_INT_MULT</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classVarnode.html#a9a59015e5303190f843f3f30bc63984c">Varnode::setImplied()</a>, and <a class="el" href="classVarnode.html#a48932e5bf8aab53ae9b3a6a6d9b25ce8">Varnode::updateType()</a>.</p>

<p>Referenced by <a class="el" href="classActionSetCasts.html#a9999706f3347f707e39c28b5a208fbd3">ActionSetCasts::apply()</a>, <a class="el" href="classRulePtraddUndo.html#afc408fd7b407b90b30b2d039e6a1ed14">RulePtraddUndo::applyOp()</a>, and <a class="el" href="classFuncdata.html#a65cb6cda676ceb9a33f8e6eef9e1e962">target()</a>.</p>

</div>
</div>
<a class="anchor" id="aacf0cf87976170d62df42411ffe1e10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUninsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> from its basic block. </p>
<p>The op is taken out of its basic block and put into the dead list. If the removal is permanent the input and output Varnodes should be unset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOpBank.html#ad4e924e79e478b3f867a4da3ba6d6c56">PcodeOpBank::markDead()</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, and <a class="el" href="classBlockBasic.html#aa2549f41a3fdc7a3f6be3b76a862a863">BlockBasic::removeOp()</a>.</p>

<p>Referenced by <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleMultiCollapse.html#a65f32f0c3dfaad6ba711cb1c9dc72954">RuleMultiCollapse::applyOp()</a>, <a class="el" href="classRuleConditionalMove.html#a6f63597a783571c793f91a046166845b">RuleConditionalMove::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, and <a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">opUnlink()</a>.</p>

</div>
</div>
<a class="anchor" id="a495ebac694bc98d041e29ce05eece6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUnlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset inputs/output and remove given PcodeOP from its basic block. </p>
<p>The op is extricated from all its <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> connections to the functions data-flow and removed from its basic block. This will <em>not</em> change block connections. The <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects remains in the <em>dead</em> list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#aacf0cf87976170d62df42411ffe1e10a">opUninsert()</a>, <a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput()</a>, and <a class="el" href="classFuncdata.html#ab91b54da6501e12d4ad1e81ab5d0e5c4">opUnsetOutput()</a>.</p>

<p>Referenced by <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, and <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="a16f821f09d862b3c908d2bce7530b90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUnsetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear an input operand slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is unlinked from the op. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot to clear </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#af39d326c490655910e2048eb048b0fa6">PcodeOp::clearInput()</a>, <a class="el" href="classVarnode.html#aa1e6dc2f1bd0943cf87128cf88f1f883">Varnode::eraseDescend()</a>, and <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>.</p>

<p>Referenced by <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classTransformOp.html#ab6902fc4728a704db5697d3902aec695">TransformOp::createReplacement()</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">opSetAllInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">opUnlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ab91b54da6501e12d4ad1e81ab5d0e5c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUnsetOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> becomes <em>free</em> but is not immediately deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#aa975f8074f0ff6ff5fbf92437ce9f8ea">Varnode::clearCover()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnodeBank.html#a8020195947e2b6faea7f18f591572c47">VarnodeBank::makeFree()</a>, <a class="el" href="classPcodeOp.html#a965b9f3be5f7c3df2ed4b71aa83dbf04">PcodeOp::setOutput()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a8fc0f3220ac7b0fef4613ba3666d9af9">ActionDeadCode::apply()</a>, <a class="el" href="classRuleLeftRight.html#af92aaefc1e7def3b544a0d54adf4018f">RuleLeftRight::applyOp()</a>, <a class="el" href="classRuleSubCommute.html#a98082ac7f5395dbc0fd603a876417250">RuleSubCommute::cancelExtensions()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, <a class="el" href="classActionDeadCode.html#a8d2d35c0f22f6fcb3ddb07681c0a474a">ActionDeadCode::neverConsumed()</a>, <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput()</a>, and <a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">opUnlink()</a>.</p>

</div>
</div>
<a class="anchor" id="af855f5d5a715a50d52ac193b983cd7a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opZeroMulti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform trivial CPUI_MULTIEQUAL to CPUI_COPY. </p>
<p>If the MULTIEQUAL has no inputs, presumably the basic block is unreachable, so we treat the p-code op as a COPY from a new input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. If there is 1 input, the MULTIEQUAL is transformed directly into a COPY. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given MULTIEQUAL </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#ab34e641f5ee6f2ebf4aa708e21f2b24c">opInsertInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">setInputVarnode()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, and <a class="el" href="classFuncdata.html#ac96af1ca8355f0c4f8e6582c045f0723">branchRemoveInternal()</a>.</p>

</div>
</div>
<a class="anchor" id="aafb83719ca201b5d57283058e2bcadee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::overrideFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> the control-flow p-code for a particular instruction. </p>
<p>P-code in <b>this</b> function is modified to change the control-flow of the instruction at the given address, based on the <a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address of the instruction to modify </td></tr>
    <tr><td class="paramname">type</td><td>is the <a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> type </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a7638ebccbc3caf1d196675ca882881da">beginOp()</a>, <a class="el" href="classOverride.html#a50b41569d71b0f60862b8249dc383476a671a485ec597132fbd7b17e4a012785f">Override::BRANCH</a>, <a class="el" href="classOverride.html#a50b41569d71b0f60862b8249dc383476a510fe02fbf062cd86c8152d14c5a6ef0">Override::CALL</a>, <a class="el" href="classOverride.html#a50b41569d71b0f60862b8249dc383476a5a94fa28e25fe8babb186322b2918e4c">Override::CALL_RETURN</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a8e04ce6913869e8db2eaf101ae59ed9e">CPUI_BRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classFuncdata.html#a229d522e177d1bb32453d8a060c16cb9">endOp()</a>, <a class="el" href="classFuncdata.html#ac24286ca987a0d110daa493283f7e5ad">findPrimaryBranch()</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a9cda5e2de1725ebf3fb885e375ea1a9d">opDeadInsertAfter()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classOverride.html#a50b41569d71b0f60862b8249dc383476a17d939b7a8f01dbb37e53d903dfe246e">Override::RETURN</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFlowInfo.html#aef170ff26d02065875f05d30fcc5364d">FlowInfo::processInstruction()</a>.</p>

</div>
</div>
<a class="anchor" id="a0940f0bf1bb935c2da97d7a99a6c009c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printBlockTree </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a description of control-flow structuring to a stream. </p>
<p>A description of each block in the current structure hierarchy is printed to stream. This is suitable for a console mode or debug view of the state of control-flow structuring at any point during analysis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockGraph.html#aeb99315362f322e25d56e01ed8ac35e0">BlockGraph::getSize()</a>, <a class="el" href="classBlockGraph.html#a1f50179e537ec60b0caf60e343692a5a">BlockGraph::printTree()</a>, and <a class="el" href="classFuncdata.html#a37058a8643a9c57cdf5e00e709730ea0">sblocks</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="ae81d44413d6978a8296daa5a58a19fc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printLocalRange </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print description of memory ranges associated with local scopes. </p>
<p>Each scope has a set of memory ranges associated with it, encompassing storage locations of variables that are <em>assumed</em> to be in the scope. Each range for each local scope is printed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classScope.html#a5631c4b933fb1acc9ffaea6a71a267a0">Scope::childrenBegin()</a>, <a class="el" href="classScope.html#ae4f82c4f7301b043a4d19694cd0501dc">Scope::childrenEnd()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, and <a class="el" href="classScope.html#a2175d7e4c8b85f5ea8c0d9a583e8ac93">Scope::printBounds()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="ae12c58fc86373ad2b650342c68333748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printRaw </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print raw p-code op descriptions to a stream. </p>
<p>A representation of all PcodeOps in the function body are printed to the stream. Depending on the state of analysis, PcodeOps are grouped into their basic blocks, and within a block, ops are displayed sequentially. Basic labeling of branch destinations is also printed. This is suitable for a console mode or debug view of the state of the function at any given point in its analysis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classPcodeOpBank.html#ac07817d3ed18d13207699f33f7587c7f">PcodeOpBank::beginAll()</a>, <a class="el" href="classPcodeOpBank.html#a2a86c7b123691edbe60ba64aef82e770">PcodeOpBank::empty()</a>, <a class="el" href="classPcodeOpBank.html#a1d8c07b356848ab693ae0f020b7195fc">PcodeOpBank::endAll()</a>, <a class="el" href="classBlockGraph.html#aeb99315362f322e25d56e01ed8ac35e0">BlockGraph::getSize()</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, and <a class="el" href="classBlockGraph.html#a23e760752b125aa25e028dae75f9841b">BlockGraph::printRaw()</a>.</p>

<p>Referenced by <a class="el" href="classVarnode.html#a71bc569e459e904cd199c89340a212e0">Varnode::clearConsumeVacuous()</a>, <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, <a class="el" href="classDecompileAt.html#ae5dfee8a7e5fd8343f7cf59e53d4f78c">DecompileAt::rawAction()</a>, and <a class="el" href="classBlockBasic.html#ab7bec5c0194872464e289947a54303a4">BlockBasic::subBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ade3f7ed3fc9cf513f60cb31dcbfddad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printVarnodeTree </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a description of all Varnodes to a stream. </p>
<p>A description of each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> currently involved in the data-flow of <b>this</b> function is printed to the output stream. This is suitable as part of a console mode or debug view of the function at any point during its analysis </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnodeBank.html#a261374116c4581bd8aa748a3b3fe7d59">VarnodeBank::beginDef()</a>, <a class="el" href="classVarnodeBank.html#aea1d001695802f0376ead8dc744216f9">VarnodeBank::endDef()</a>, <a class="el" href="classVarnode.html#a3832ba1e8a5d7181d9534ef2a614ddb1">Varnode::printInfo()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d635570305e3ea710ade3cf090ba8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::pushBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bbnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a control-flow edge from one block to another. </p>
<p>This is intended for eliminating switch guard artifacts. The edge must be for a conditional jump and must be moved to a block hosting multiple out edges for a BRANCHIND. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the basic block out of which the edge to move flows </td></tr>
    <tr><td class="paramname">slot</td><td>is the index of the (out) edge </td></tr>
    <tr><td class="paramname">bbnew</td><td>is the basic block where the edge should get moved to </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a8e04ce6913869e8db2eaf101ae59ed9e">CPUI_BRANCH</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a16130945560323d4b28ead4387094444">CPUI_CBRANCH</a>, <a class="el" href="classBlockBasic.html#a94b8b6786b04a8cb00e5d0fc2977a675">BlockBasic::lastOp()</a>, <a class="el" href="classBlockGraph.html#a4a1dcf88374cbf4b9886d26dced7c533">BlockGraph::moveOutEdge()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classJumpBasic.html#a27ac3c21abdfc602f857802a7479c6d4">JumpBasic::foldInOneGuard()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="ae76e681657570c6494c366c16825f130"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::pushMultiequals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push MULTIEQUAL Varnodes of the given block into the output block. </p>
<p>Assuming the given basic block is being removed, force any <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> defined by a MULTIEQUAL in the block to be defined in the output block instead. This is used as part of the basic block removal process to patch up data-flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classVarnode.html#a7a6543b02c57f78a06aaecd53f858b14">Varnode::descend</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classFlowBlock.html#a53eb84ad35f0bfd147cebe862bdce1ca">FlowBlock::getOutRevIndex()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a6af4eb0fdeaeb2711401e8d6afc1d92f">Varnode::isAddrTied()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">newUnique()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#ae6341eb8ca8a8004f1c77a8e8147a286">opInsertBegin()</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">opSetAllInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput()</a>, <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>.</p>

</div>
</div>
<a class="anchor" id="a38d58c33cdc77c663fceb7de1f6aadeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::recoverJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowInfo.html">FlowInfo</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>failuremode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover destinations for a BRANCHIND by analyzing nearby data and control-flow. </p>
<p>This is the high-level entry point for jump-table/switch recovery. In short, a copy of the current state of data-flow is made, simplification transformations are applied to the copy, and the resulting data-flow tree is examined to enumerate possible values of the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. This information is stored in a <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">flow</td><td>is current flow information for <b>this</b> function </td></tr>
    <tr><td class="paramname">failuremode</td><td>will hold the final success/failure code (0=success) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the recovered <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> or NULL if there was no success </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classJumpTable.html#a1f864164256b456f2cbad1933e61e140">JumpTable::getStage()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classJumpTable.html#a6969a2de9b0fbfbcbc6d168f40866c77">JumpTable::isOverride()</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba73782af4d513cc7b8c73b9183067585e">jumptablerecovery_dont</a>, <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>, <a class="el" href="classFuncdata.html#a512f5823b1a33e9430584067d77a52c5">linkJumpTable()</a>, <a class="el" href="classJumpTable.html#a999b901e638cfc2243b0e7578355c662">JumpTable::setIndirectOp()</a>, and <a class="el" href="classFuncdata.html#ae8b08186fd6b91718d81930f3dda621a">stageJumpTable()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#add6bcc6efff0daefdcc48ee11e743121">endOp()</a>, and <a class="el" href="classFlowInfo.html#afe680152d016a3ec80e155f3ea85f26c">FlowInfo::generateOps()</a>.</p>

</div>
</div>
<a class="anchor" id="a73cbb6375e48cddaedf5e55e40119c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::remapDynamicVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a new dynamic mapping. </p>
<p>Any previous links between the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, and the associate <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> are removed. Then a new dynamic link is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> maps to </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the code <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is defined </td></tr>
    <tr><td class="paramname">hash</td><td>is the hash for the new dynamic mapping </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a5acc07e00146316532a3806cd19815bb">clearSymbolLinks()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classScopeLocal.html#a26680d26758921aa47298aae50e8c043">ScopeLocal::remapSymbolDynamic()</a>, and <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>.</p>

</div>
</div>
<a class="anchor" id="a6145d643e13a072975e34255a06f4e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::remapVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a static mapping. </p>
<p>Any previous links between the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, and the associate <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> are removed. Then a new link is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> maps to </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the desired usepoint for the mapping </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a5acc07e00146316532a3806cd19815bb">clearSymbolLinks()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classScopeLocal.html#a6b25f3fe8692539d3de175e522b6f3dc">ScopeLocal::remapSymbol()</a>, and <a class="el" href="classVarnode.html#a3fdcd280cd545d231c79fca011a0c33a">Varnode::setSymbolEntry()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a53162bf9a1756c4f2f4d7d1d7bbcec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the indicated branch from a basic block. </p>
<p>The edge is removed from control-flow and affected MULTIEQUAL ops are adjusted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the basic block </td></tr>
    <tr><td class="paramname">num</td><td>is the index of the out edge to remove </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#ac96af1ca8355f0c4f8e6582c045f0723">branchRemoveInternal()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classActionRedundBranch.html#ac7caec1379a7cb37fba45fe2bd75199f">ActionRedundBranch::apply()</a>, <a class="el" href="classActionDeterminedBranch.html#ade1a39edabc809aa136ef4f109d46560">ActionDeterminedBranch::apply()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="aa486c5f0556919686a9fdad4ebc2dcc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeDoNothingBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block from control-flow that performs no operations. </p>
<p>The block must contain only <em>marker</em> operations (MULTIEQUAL) and possibly a single unconditional branch operation. The block and its PcodeOps are completely removed from the current control-flow and data-flow. This forces a reset of the control-flow structuring hierarchy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classFlowBlock.html#a782f5f62072869fd9f093e7c58567a00">FlowBlock::setDead()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classActionDoNothing.html#a731f2fd0ba173c40a794de849bfabe4b">ActionDoNothing::apply()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="af83619924b5d0fed25d0563b0f243262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeFromFlowSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block splitting its control-flow into two distinct paths. </p>
<p>This is used by <a class="el" href="classConditionalExecution.html" title="A class for simplifying a series of conditionally executed statements. ">ConditionalExecution</a> to eliminate unnecessary control-flow joins. The given block must have 2 inputs and 2 outputs, (and no operations). The block is removed, and control-flow is adjusted so that In(0) flows to Out(0) and In(1) flows to Out(1), or vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">swap</td><td>is <b>true</b> to force In(0)-&gt;Out(1) and In(1)-&gt;Out(0) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classBlockBasic.html#a0f387556fc98124346effe2ca47bbebf">BlockBasic::emptyOp()</a>, <a class="el" href="classBlockGraph.html#a566cbe393f781703c640a691e27a4f90">BlockGraph::removeBlock()</a>, <a class="el" href="classBlockGraph.html#a8c6e3329fe131f587a472413dfd60fcd">BlockGraph::removeFromFlowSplit()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e75df713649c7bba52b17b1b84bbcf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td>
          <td class="paramname"><em>jt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove/delete the given jump-table. </p>
<p>The <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object is freed, and the associated BRANCHIND is no longer marked as a <em>switch</em> point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jt</td><td>is the given <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFlowBlock.html#afd95b45dd6c78be77ad477386fe691db">FlowBlock::clearFlag()</a>, <a class="el" href="classFlowBlock.html#a26c4544d5e03d58799f03a43a46f78d2a78728a42dfc897142aa3016755dee1d7">FlowBlock::f_switch_out</a>, <a class="el" href="classJumpTable.html#a40c6181b864e78426ddcc95b9feaed2f">JumpTable::getIndirectOp()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, and <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>.</p>

<p>Referenced by <a class="el" href="classRuleSwitchSingle.html#ab884de26def65edb9ade3b981c6983e1">RuleSwitchSingle::applyOp()</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, and <a class="el" href="classFuncdata.html#a475047d15d64d653871facd75f7244ed">getJumpTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fca3088c3d01a584aef0db49dfccc63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::removeUnreachableBlocks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>issuewarning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkexistence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any unreachable basic blocks. </p>
<p>A quick check for unreachable blocks can optionally be made, otherwise the cached state is checked via <a class="el" href="classFuncdata.html#ad6bcb625a6d832f71b220987c829fd4b" title="Did this function exhibit unreachable code. ">hasUnreachableBlocks()</a>, which is turned on during analysis by calling the <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8" title="Calculate initial basic block structures (after a control-flow change) ">structureReset()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">issuewarning</td><td>is <b>true</b> if warning comments are desired </td></tr>
    <tr><td class="paramname">checkexistence</td><td>is <b>true</b> to force an active search for unreachable blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if unreachable blocks were actually found and removed </dd></dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classFuncdata.html#ac96af1ca8355f0c4f8e6582c045f0723">branchRemoveInternal()</a>, <a class="el" href="classBlockGraph.html#a8effbb36cb9a9e8737532ee36a80c08f">BlockGraph::collectReachable()</a>, <a class="el" href="classBlockGraph.html#a8a8163564a0e9217cab5f085eab2684e">BlockGraph::getBlock()</a>, <a class="el" href="classFlowBlock.html#af89021d9b4861fa2b1c6b8de466a2231">FlowBlock::getImmedDom()</a>, <a class="el" href="classAddrSpace.html#a9a1077feee89cf4434154e017a3360f5">AddrSpace::getName()</a>, <a class="el" href="classBlockGraph.html#aeb99315362f322e25d56e01ed8ac35e0">BlockGraph::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classFuncdata.html#ad6bcb625a6d832f71b220987c829fd4b">hasUnreachableBlocks()</a>, <a class="el" href="classFlowBlock.html#a132ffef8996f1339519c91d54343fc52">FlowBlock::isEntryPoint()</a>, <a class="el" href="classAddress.html#a040ac0edbb01bd26c8956130ec4ef20e">Address::printRaw()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classActionUnreachable.html#a9dd250eba93553aad31aa38168d7c301">ActionUnreachable::apply()</a>, <a class="el" href="classFlowInfo.html#a5c8f51cb6c88719657801a2f26e87fae">FlowInfo::generateBlocks()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a223a70ddb5e33f446fca85bc3b369911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::replaceLessequal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace INT_LESSEQUAL and INT_SLESSEQUAL expressions. </p>
<p>Do in-place replacement of</p><ul>
<li><code>c &lt;= x</code> with <code>c-1 &lt; x</code> OR</li>
<li><code>x &lt;= c</code> with <code>x &lt; c+1</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is comparison <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid replacement was performed </dd></dl>

<p>References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classVarnode.html#a5b21f0980bc223331c25bf4e609b1254">Varnode::copySymbol()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a9fd7576d8174c8e8ad99a71b1bed2518">CPUI_INT_LESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a0a05aafda58e54690ae841c3642e3b82">CPUI_INT_SLESS</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a49d2a9e93a7a397287ea70f8d6c6a132">CPUI_INT_SLESSEQUAL</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="address_8hh.html#a6f16b447a8d8851178b1f0709c14bde6">sign_extend()</a>.</p>

<p>Referenced by <a class="el" href="classRuleIntLessEqual.html#a94fea35e74d0c34edf0da67dd56cb8e6">RuleIntLessEqual::applyOp()</a>, <a class="el" href="funcdata_8hh.html#a0a7a4ee0c419ed55c99f44d914284828">opFlipInPlaceExecute()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a754fe8bd5805e6d9fd8041365e7747eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::replaceVolatile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace accesses of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with <em>volatile</em> operations. </p>
<p>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is assumed not fully linked. The read or write action is modeled by inserting a special <em>user</em> op that represents the action. The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is replaced by a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> within the data-flow, and the original address becomes a parameter to the user op. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to model as volatile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a7a2b625788b1d23eda50975b6baf7efb">CPUI_CALLOTHER</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classUserPcodeOp.html#a54b1fa2f4ed7a4fc6bff64822cb86129">UserPcodeOp::getIndex()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classUserOpManage.html#a105a3a6dc407c2fc43ca3dbe7c8d3291">UserOpManage::getVolatileRead()</a>, <a class="el" href="classUserOpManage.html#af60a98d01cfec16ec74fab31a22398d1">UserOpManage::getVolatileWrite()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a4bc8a57cabff365b49a883ebe691609e">Varnode::isTypeLock()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>, <a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">newCodeRef()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">newUnique()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput()</a>, <a class="el" href="classPcodeOp.html#aa5a81e58af666d0381fffdc845b61eaa">PcodeOp::setAdditionalFlag()</a>, <a class="el" href="classPcodeOp.html#a349007611576c9266b5bd0cee4b7a073abca77d05804c71b79b4192687f34105f">PcodeOp::special_prop</a>, and <a class="el" href="classArchitecture.html#abd9c927fbda44de1ab46122f49248003">Architecture::userops</a>.</p>

<p>Referenced by <a class="el" href="classActionVarnodeProps.html#a531c9985eb2e6a5796009bea79a465fe">ActionVarnodeProps::apply()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a7419de8057421b8e9300c4a26c60ecef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 Funcdata::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the state of <b>this</b> function from an XML description. </p>
<p>From an XML &lt;function&gt; tag, recover the name, address, prototype, symbol, jump-table, and override information for <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root &lt;function&gt; tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the symbol id associated with the function </dd></dl>

<p>References <a class="el" href="classDatabase.html#a1bc096166a8cfde3d77229c9e38bfabf">Database::attachScope()</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classDatabase.html#ac96c1227e6451c7a8f2103f21ed7bff3">Database::getGlobalScope()</a>, <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>, <a class="el" href="classAddrSpaceManager.html#a4c6a5c3c4ceadaf7f0b4343f52639153">AddrSpaceManager::getStackSpace()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classFuncdata.html#a21754a3c362d2208f9ee7f317cf504b9">localoverride</a>, <a class="el" href="classFuncdata.html#abb2c1673cccd101653606f7f5e4a8eb8">name</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba23a953cc66d2fc04b1b48f3b72a17e5d">no_code</a>, <a class="el" href="classScopeLocal.html#a3bf9941188eb64423d2ed49a08dab8ca">ScopeLocal::resetLocalWindow()</a>, <a class="el" href="classOverride.html#a81f34dfc11c427ea0873358bef93ada3">Override::restoreXml()</a>, <a class="el" href="classAddress.html#a31fdc8c33088abb3040027d35e7c4026">Address::restoreXml()</a>, <a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">FuncProto::restoreXml()</a>, <a class="el" href="classFuncdata.html#a07a41bb91dd51c9a76d8f6d1e2f09328">restoreXmlJumpTable()</a>, <a class="el" href="classDatabase.html#a2988a943d95dd1b3f6f157543f765970">Database::restoreXmlScope()</a>, <a class="el" href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">FuncProto::setScope()</a>, <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>, <a class="el" href="classArchitecture.html#ab426c9baa9013d9826041a4083e844ef">Architecture::symboltab</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFunctionSymbol.html#afba4e81eed1ad378ae7f0531ec8f3d2b">FunctionSymbol::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a07a41bb91dd51c9a76d8f6d1e2f09328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::restoreXmlJumpTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore jump-tables from an XML description. </p>
<p>This parses a &lt;jumptablelist&gt; tag and builds a <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object for each &lt;jumptable&gt; sub-tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root &lt;jumptablelist&gt; tag </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>, and <a class="el" href="classJumpTable.html#a6c61097c622f85e04db056d9613e94f1">JumpTable::restoreXml()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncdata.html#a7419de8057421b8e9300c4a26c60ecef">restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="abade5bd2230b9f8d2cc19d271f5bb411"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveVarnodeXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>enditer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save XML descriptions for a set of Varnodes to stream. </p>
<p>This is an internal function for the function's save to XML system. Individual XML tags are written in sequence for Varnodes in a given set. The set is bounded by iterators using the 'loc' ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
    <tr><td class="paramname">iter</td><td>is the beginning of the set </td></tr>
    <tr><td class="paramname">enditer</td><td>is the end of the set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a665649dfbfa609bb27f7fe0f7ed78436">Varnode::saveXml()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a715a24e059f8fa8e8367e49828f53b7b">saveXmlTree()</a>.</p>

</div>
</div>
<a class="anchor" id="ad23142354572370c67625649f5119c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>savetree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an XML description of <b>this</b> function to stream. </p>
<p>An XML description of <b>this</b> function is written to the stream, including name, address, prototype, symbol, jump-table, and override information. If indicated by the caller, a description of the entire <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> tree is also emitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
    <tr><td class="paramname">id</td><td>is the unique id associated with the function symbol </td></tr>
    <tr><td class="paramname">savetree</td><td>is <b>true</b> if the p-code tree should be emitted </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="xml_8hh.html#a0fa1b18d881c70abd1489da2ba2f6792">a_v()</a>, <a class="el" href="xml_8hh.html#a87634423f394bc832a51957ee6fc85c9">a_v_b()</a>, <a class="el" href="xml_8hh.html#aa12f4a381037faf4e90d1876bb44aa02">a_v_i()</a>, <a class="el" href="xml_8hh.html#af098b9ed0ffa95b5f853eb3f88ec7064">a_v_u()</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a58a54cc73ea882bf0e829a6ee090070a">hasNoCode()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classFuncdata.html#a21754a3c362d2208f9ee7f317cf504b9">localoverride</a>, <a class="el" href="classFuncdata.html#abb2c1673cccd101653606f7f5e4a8eb8">name</a>, <a class="el" href="classOverride.html#a174b1daca9af097c7f2091958431b24d">Override::saveXml()</a>, <a class="el" href="classAddress.html#abddd3a282e1936bfed855f34824a2ec6">Address::saveXml()</a>, <a class="el" href="classFuncProto.html#a9d423d90f94aaed9c6f943a9e3b0e7b8">FuncProto::saveXml()</a>, <a class="el" href="classFuncdata.html#a8a72207c0e2dccc2dc7b3156cc11ad52">saveXmlHigh()</a>, <a class="el" href="classFuncdata.html#a503e8c3b03e9562c19a7550ce5d064f0">saveXmlJumpTable()</a>, <a class="el" href="classScope.html#aaa986065e802ab19dd807b76ea1a835b">Scope::saveXmlRecursive()</a>, <a class="el" href="classFuncdata.html#a715a24e059f8fa8e8367e49828f53b7b">saveXmlTree()</a>, and <a class="el" href="classFuncdata.html#a67995a51bd7f1a6ebf51ec0bb3836358">size</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, <a class="el" href="classDecompileAt.html#ae5dfee8a7e5fd8343f7cf59e53d4f78c">DecompileAt::rawAction()</a>, <a class="el" href="classFunctionSymbol.html#adff48887fff6cf550fd577f78cc4ebd2">FunctionSymbol::saveXml()</a>, and <a class="el" href="classVarnode.html#a163d10fe0e4d21feaf1b8db66ed28d57">Varnode::setLockedInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a72207c0e2dccc2dc7b3156cc11ad52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXmlHigh </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save an XML description of all HighVariables to stream. </p>
<p>This produces a single &lt;highlist&gt; tag, with a &lt;high&gt; sub-tag for each high-level variable (<a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>) currently associated with <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a6057f2bc7180ba1232bfd80f5c1f8c21">beginLoc()</a>, <a class="el" href="classHighVariable.html#ab5de82bcd8bc9bf3011018e79e3cf823">HighVariable::clearMark()</a>, <a class="el" href="classFuncdata.html#ac26dd8e3e8bad84b79a9a452bd953d8f">endLoc()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classVarnode.html#af7d640b593a55ac3eb63fa7322fb8a2a">Varnode::isAnnotation()</a>, <a class="el" href="classFuncdata.html#afef3b78bc9d85d2f69bf655c7d4d159f">isHighOn()</a>, <a class="el" href="classHighVariable.html#a63afa99edb788d34b85bb3944457c653">HighVariable::isMark()</a>, <a class="el" href="classHighVariable.html#a47773e6af9174c456ed9011de7dac1d8">HighVariable::saveXml()</a>, and <a class="el" href="classHighVariable.html#a9aca22722220828e753925df3cb86604">HighVariable::setMark()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncdata.html#ad23142354572370c67625649f5119c8a">saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a503e8c3b03e9562c19a7550ce5d064f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXmlJumpTable </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an XML description of jump-tables to stream. </p>
<p>A &lt;jumptablelist&gt; tag is written with &lt;jumptable&gt; sub-tags describing each jump-table associated with the control-flow of <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncdata.html#ad23142354572370c67625649f5119c8a">saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a715a24e059f8fa8e8367e49828f53b7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXmlTree </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save an XML description of the p-code tree to stream. </p>
<p>A single &lt;ast&gt; tag is produced with children describing Varnodes, PcodeOps, and basic blocks making up <b>this</b> function's current syntax tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="xml_8hh.html#aa12f4a381037faf4e90d1876bb44aa02">a_v_i()</a>, <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classVarnodeBank.html#aadc19c865c51af69f235b0553638a8bd">VarnodeBank::beginLoc()</a>, <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classBlockGraph.html#a8a8163564a0e9217cab5f085eab2684e">BlockGraph::getBlock()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classBlockGraph.html#aeb99315362f322e25d56e01ed8ac35e0">BlockGraph::getSize()</a>, <a class="el" href="classAddrSpaceManager.html#a8c4ce4f25454e86a0383852fe42b3b7a">AddrSpaceManager::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ad644dc33b71c7d421fcd0fb2003407c7">IPTR_IOP</a>, <a class="el" href="classAddrSpaceManager.html#abb27d4583ae1bfb9e2a16139bae922d3">AddrSpaceManager::numSpaces()</a>, <a class="el" href="classFuncdata.html#abade5bd2230b9f8d2cc19d271f5bb411">saveVarnodeXml()</a>, <a class="el" href="classPcodeOp.html#a34c19cc9ea613a4dcf359a61e59f6905">PcodeOp::saveXml()</a>, <a class="el" href="classBlockBasic.html#a4e481de448b74385fdbfd6f54a7b31f1">BlockBasic::saveXmlBody()</a>, <a class="el" href="classFlowBlock.html#ae9d42d070fe854e3f52aea698504df9a">FlowBlock::saveXmlEdges()</a>, <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncdata.html#ad23142354572370c67625649f5119c8a">saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="adc0c8b4dab63367913749e68fbd33789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::seenDeadcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark that dead Varnodes have been seen in a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space to mark </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classHeritage.html#abbcd7a583bd605db1177b9c2e0be599f">Heritage::seenDeadCode()</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a8fc0f3220ac7b0fef4613ba3666d9af9">ActionDeadCode::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a15885a8369e2c43c8c7883a4fabd533e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setBasicBlockRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the initial ownership range for the given basic block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">beg</td><td>is the beginning <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the owned code range </td></tr>
    <tr><td class="paramname">end</td><td>is the ending <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the owned code range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a5027da6d3c7a05a262e332b0c22c7c43">collapseIntMultMult()</a>, <a class="el" href="classFuncdata.html#a4456bfc523a4527c9fd924ecadacec63">compareCallspecs()</a>, <a class="el" href="classFuncdata.html#a1b94fb7b2f8e72df053f4d09d48cdf7b">distributeIntMultAdd()</a>, <a class="el" href="classFuncdata.html#ac9b35091642dc7527a537d01db5ad7e1">forceGoto()</a>, <a class="el" href="classFuncdata.html#a9021f01b57f8704db66341bc7f65f39f">installSwitchDefaults()</a>, <a class="el" href="classFuncdata.html#ad810c24ce5fb16a95de1f7d27c8856d8">nodeJoinCreateBlock()</a>, <a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit()</a>, <a class="el" href="classFuncdata.html#aa2d635570305e3ea710ade3cf090ba8c">pushBranch()</a>, <a class="el" href="classFuncdata.html#a3a53162bf9a1756c4f2f4d7d1d7bbcec">removeBranch()</a>, <a class="el" href="classFuncdata.html#aa486c5f0556919686a9fdad4ebc2dcc1">removeDoNothingBlock()</a>, <a class="el" href="classFuncdata.html#af83619924b5d0fed25d0563b0f243262">removeFromFlowSplit()</a>, <a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks()</a>, <a class="el" href="classFuncdata.html#a223a70ddb5e33f446fca85bc3b369911">replaceLessequal()</a>, <a class="el" href="classBlockBasic.html#ad15bba2ab501e8efff86dc40a832ffff">BlockBasic::setInitialRange()</a>, <a class="el" href="classFuncdata.html#a9f0c9d7c7fb4217731ae45f7848e4034">spliceBlockBasic()</a>, and <a class="el" href="classFuncdata.html#a5ba1555023c49006ed39936b9a40aba4">switchEdge()</a>.</p>

<p>Referenced by <a class="el" href="classFlowInfo.html#a5c8f51cb6c88719657801a2f26e87fae">FlowInfo::generateBlocks()</a>, and <a class="el" href="classFlowInfo.html#a95ba46643484d24fde597996b7aba4c3">FlowInfo::splitBasic()</a>.</p>

</div>
</div>
<a class="anchor" id="ac40aef88ca7a101e4697df5e0ec5f605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setDeadCodeDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a delay before removing dead code for a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the specific address space </td></tr>
    <tr><td class="paramname">delay</td><td>is the number of passes to delay </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classHeritage.html#a8377c55d2b77f230779ad43e341e6a29">Heritage::setDeadCodeDelay()</a>.</p>

<p>Referenced by <a class="el" href="classOverride.html#a75a0b8a3ef2d78ad0c6edb910810e408">Override::applyDeadCodeDelay()</a>.</p>

</div>
</div>
<a class="anchor" id="a23bcddc7a3b959812f9a1660b39cc6ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setDoublePrecisRecovery </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether double precision analysis is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if double precision analysis is enabled </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba6c39685abdf85f90ed252f9ebc4e62ce">double_precis_on</a>.</p>

<p>Referenced by <a class="el" href="classRuleDoubleIn.html#a9feb1ec4c3183551094c745c169ee14e">RuleDoubleIn::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a84a9880613a03f3aea65acf3dd1343d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::setInputVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as an input to the function. </p>
<p>An <em>input</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has a special designation within SSA form as not being defined by a p-code operation and is a formal input to the data-flow of the function. It is not necessarily a formal function parameter.</p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to be marked is also returned unless there is an input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that already exists which overlaps the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. If the Varnodes have the same size and storage address, the preexisting input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is returned instead. Otherwise an exception is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to mark as an input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the marked <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classVarnodeBank.html#a261374116c4581bd8aa748a3b3fe7d59">VarnodeBank::beginDef()</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classFuncProto.html#a116dd89589cc36e9c822426838658871">FuncProto::hasEffect()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca9c9363556459d8828a5ab58c370ccd2e">Varnode::input</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classVarnode.html#a7fb3376269b6c8585afb3ecc877a7cab">Varnode::overlap()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeafa04c6c617a1044c79c7bc9b7d661be2">EffectRecord::return_address</a>, <a class="el" href="classVarnodeBank.html#a132b64906ef393d34a4363ff816e4ba2">VarnodeBank::setInput()</a>, <a class="el" href="classVarnode.html#a5f5028eda92941ae7f12728c16e28243">Varnode::setReturnAddress()</a>, <a class="el" href="classVarnode.html#a1117128f706915a92240926b8d0efab1">Varnode::setUnaffected()</a>, <a class="el" href="classFuncdata.html#af7412778106b02b163e6d685deb826db">setVarnodeProperties()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea3488da6d6b149499cbe384f7b57d0564">EffectRecord::unaffected</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>, <a class="el" href="classSubvariableFlow.html#a6975acfca24824c2c0ae4f2b6b70dea3">SubvariableFlow::getReplaceVarnode()</a>, <a class="el" href="classFuncdata.html#ab8e8acf5b27d1e6886fd45eaf472ec4f">numVarnodes()</a>, <a class="el" href="classFuncdata.html#af855f5d5a715a50d52ac193b983cd7a9">opZeroMulti()</a>, <a class="el" href="classSubvariableFlow.html#a8f8c80032b3fa35e825e18b3d8d98197">SubvariableFlow::replaceInput()</a>, and <a class="el" href="classTransformManager.html#adf12b6bb5327a3bbba8a9ac2c5049681">TransformManager::transformInputVarnodes()</a>.</p>

</div>
</div>
<a class="anchor" id="ac33bb4d59a0125d36710fe80453b9526"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setJumptableRecovery </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether <b>this</b> is being used for jump-table recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> to indicate a jump-table is being recovered </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba73782af4d513cc7b8c73b9183067585e">jumptablerecovery_dont</a>.</p>

</div>
</div>
<a class="anchor" id="af21c852eb9f606c5cd19fb2456927ecd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setRestartPending </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether analysis needs to be restarted for <b>this</b> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if a reset is required </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba45ce5472ffe09854b56f87436062982c">restart_pending</a>.</p>

<p>Referenced by <a class="el" href="classActionSwitchNorm.html#afbafe42ea6a6c25321775656d0a1f6cb">ActionSwitchNorm::apply()</a>, <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">FuncCallSpecs::deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">FuncCallSpecs::forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="af7412778106b02b163e6d685deb826db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setVarnodeProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look-up boolean properties and data-type information. </p>
<p>Properties of a given storage location are gathered from symbol information and applied to the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#addc78d7786b99104f213a654534a3281">Varnode::calcCover()</a>, <a class="el" href="classVarnode.html#ab48054cb643a9f44fa980c4c3259f87a">Varnode::cover</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>, <a class="el" href="classFuncdata.html#afef3b78bc9d85d2f69bf655c7d4d159f">isHighOn()</a>, <a class="el" href="classVarnode.html#ad59af997fbae15bebc3112857c4d9e27">Varnode::isMapped()</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classScope.html#a81a607e1ba8c2cc85a14b84a1c86944e">Scope::queryProperties()</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classVarnode.html#a0ae87b8fb23c218185f4cee1d958b606">Varnode::setSymbolProperties()</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae49e063a1b1e7de4592afd3f19abbdc7">Varnode::typelock</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput()</a>, and <a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">setInputVarnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a58664772693fca369a469c1540c65e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::sortCallSpecs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort calls using a dominance based order. </p>
<p>Calls are put in dominance order so that earlier calls get evaluated first. Order affects parameter analysis. </p>

<p>References <a class="el" href="classFuncdata.html#a4456bfc523a4527c9fd924ecadacec63">compareCallspecs()</a>, and <a class="el" href="classFuncdata.html#aa8e08833a58a93938d74fb0775e13c2e">qlst</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">startProcessing()</a>.</p>

</div>
</div>
<a class="anchor" id="a96433773ee0126ce9a25b0970a6ef513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::spacebase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark registers that map to a virtual address space. </p>
<p>This routine searches for an marks <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> objects, like stack-pointer registers, that are used as a base address for a virtual address space. Each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> gets a special data-type and is marked so that <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae" title="Is this location used to store the base point for a virtual address space? ">Varnode::isSpacebase()</a> returns <b>true</b>. </p>

<p>References <a class="el" href="classVarnodeBank.html#aadc19c865c51af69f235b0553638a8bd">VarnodeBank::beginLoc()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classFuncdata.html#a91233c941630a3194e8287206314bb1e">getAddress()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classAddrSpaceManager.html#a8c4ce4f25454e86a0383852fe42b3b7a">AddrSpaceManager::getSpace()</a>, <a class="el" href="classAddrSpace.html#a3b16390dfa556c9bdd6fe5b31448f7d7">AddrSpace::getSpacebase()</a>, <a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">TypeFactory::getTypePointer()</a>, <a class="el" href="classTypeFactory.html#a85de9d19ce1dc44476a414f5ce69b97e">TypeFactory::getTypeSpacebase()</a>, <a class="el" href="classAddrSpace.html#a2a3d94aea39c4fc962e493b81452afe8">AddrSpace::getWordSize()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae">Varnode::isSpacebase()</a>, <a class="el" href="classAddrSpace.html#aae785e311543d4e95c7d344b0c93823c">AddrSpace::numSpacebase()</a>, <a class="el" href="classAddrSpaceManager.html#abb27d4583ae1bfb9e2a16139bae922d3">AddrSpaceManager::numSpaces()</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cac66fb19d44cde4a461d513f6d50a818f">Varnode::spacebase</a>, <a class="el" href="classFuncdata.html#a022a17a53f47adfd09ca88202f953342">splitUses()</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, <a class="el" href="classVarnode.html#a48932e5bf8aab53ae9b3a6a6d9b25ce8">Varnode::updateType()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionSpacebase.html#ace4b23e248568955820212813c911719">ActionSpacebase::apply()</a>, and <a class="el" href="classFuncdata.html#a287bc196bb5fa26fb1a8197a1e4c6eca">hasBadData()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf4a89f4e3da37a4107992689f7b89ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::spacebaseConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>rampoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>origval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>origsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a constant pointer into a <em>ram</em> CPUI_PTRSUB. </p>
<p>A constant known to be a pointer into an address space like <b>ram</b> is converted into a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> defined by CPUI_PTRSUB, which triggers a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> lookup at points during analysis. The constant must point to a known <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.</p>
<p>The PTRSUB takes the constant 0 as its first input, which is marked as a <em>spacebase</em> to indicate this situation. The second input to PTRSUB becomes the offset to the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> within the address space. An additional INT_SUB may be inserted to get from the start of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to the address indicated by the original constant pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> referencing the constant pointer </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the constant pointer </td></tr>
    <tr><td class="paramname">entry</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> being pointed (in)to </td></tr>
    <tr><td class="paramname">rampoint</td><td>is the constant pointer interpreted as an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">origval</td><td>is the constant </td></tr>
    <tr><td class="paramname">origsize</td><td>is the size of the constant </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a3c9149df492bdcaccc208eac261e8365">AddrSpace::byteToAddress()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a778868cfa2191f9621f632672e596702">CPUI_INT_ZEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7acd169003bfcb2e8dde0cb2dc1f534449">CPUI_PTRSUB</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classAddress.html#a45e9717c199593d3446eae0328499e43">Address::getAddrSize()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classSymbol.html#ad3bc7110cbcbeebbd642ba8e3342a59d">Symbol::getType()</a>, <a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">TypeFactory::getTypePointer()</a>, <a class="el" href="classTypeFactory.html#aff97843c231aea653d16621caa5f1ee6">TypeFactory::getTypePointerStripArray()</a>, <a class="el" href="classTypeFactory.html#a85de9d19ce1dc44476a414f5ce69b97e">TypeFactory::getTypeSpacebase()</a>, <a class="el" href="classAddrSpace.html#a2a3d94aea39c4fc962e493b81452afe8">AddrSpace::getWordSize()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classPcodeOp.html#a40a813424f6cac1fbbd987b734771e1d">PcodeOp::insertInput()</a>, <a class="el" href="classAddrSpace.html#aa7472d8a944382dab56e41ba5deca72c">AddrSpace::isTruncated()</a>, <a class="el" href="classSymbol.html#a17fd1dd4580930c34b6deb1f3daf447f">Symbol::isTypeLocked()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classVarnode.html#a5e156fe05fb86c5efda500797872692b">Varnode::setPtrCheck()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cac66fb19d44cde4a461d513f6d50a818f">Varnode::spacebase</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, and <a class="el" href="classVarnode.html#a48932e5bf8aab53ae9b3a6a6d9b25ce8">Varnode::updateType()</a>.</p>

<p>Referenced by <a class="el" href="classActionConstantPtr.html#a3667d599128a545967351ba54f4cce42">ActionConstantPtr::apply()</a>, and <a class="el" href="classFuncdata.html#a287bc196bb5fa26fb1a8197a1e4c6eca">hasBadData()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f0c9d7c7fb4217731ae45f7848e4034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::spliceBlockBasic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> the given basic block with the block it flows into. </p>
<p>The given block must have a single output block, which will be removed. The given block has the p-code from the output block concatenated to its own, and it inherits the output block's out edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>is the given basic block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a69ba7c0598d5d45876b8a2c02754e5db">PcodeOp::clearFlag()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classPcodeOp.html#a6195f7c7b53036df7081a9dcff633f69">PcodeOp::isBranch()</a>, <a class="el" href="classBlockBasic.html#a7b458bcf532dedd87875f3fac7208393">BlockBasic::mergeRange()</a>, <a class="el" href="classBlockBasic.html#a50f2525675e7fd2142677874ecd7001d">BlockBasic::op</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy()</a>, <a class="el" href="classBlockBasic.html#a119575eb3ad96d8d15ed19a3157c782c">BlockBasic::setOrder()</a>, <a class="el" href="classPcodeOp.html#ab2f1d471f3f964c3e5295e02d96cc5de">PcodeOp::setParent()</a>, <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>, <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>, <a class="el" href="classBlockGraph.html#a4f6da43f90aeadf0b19ddbcd95544fd3">BlockGraph::spliceBlock()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba87fc6777cadc38baf72c41c402042974">PcodeOp::startbasic</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

<p>Referenced by <a class="el" href="classActionRedundBranch.html#ac7caec1379a7cb37fba45fe2bd75199f">ActionRedundBranch::apply()</a>, and <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a022a17a53f47adfd09ca88202f953342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::splitUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make all reads of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> unique. </p>
<p>For the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, duplicate its defining <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at each read of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> so that the read becomes a new unique <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. This operation should not be performed on any <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with side effects like CPUI_CALL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classVarnode.html#a7a6543b02c57f78a06aaecd53f858b14">Varnode::descend</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">spacebase()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8b08186fd6b91718d81930f3dda621a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Funcdata::stageJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td>
          <td class="paramname"><em>jt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowInfo.html">FlowInfo</a> *&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recover a jump-table for a given BRANCHIND using existing flow information. </p>
<p>A partial function (copy) is built using the flow info. Simplification is performed on the partial function (using the "jumptable" strategy), then destination addresses of the branch are recovered by examining the simplified data-flow. The jump-table object is populated with the recovered addresses. An integer value is returned:</p><ul>
<li>0 = success</li>
<li>1 = normal could-not-recover failure</li>
<li>2 = <b>likely</b> <b>thunk</b> failure</li>
<li>3 = no legal flows to the BRANCHIND failure</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jt</td><td>is the jump-table object to populate </td></tr>
    <tr><td class="paramname">op</td><td>is the BRANCHIND p-code op to analyze </td></tr>
    <tr><td class="paramname">flow</td><td>is the existing flow information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the success/failure code </dd></dl>

<p>References <a class="el" href="classArchitecture.html#a4cbe1c5d170cb2a4d359765b97fef26f">Architecture::allacts</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ac9526d56fc1c9dc6dc1f98c05729281a">CPUI_BRANCHIND</a>, <a class="el" href="classFlowInfo.html#a7114cad4826a43bac1370300b0fe0652">FlowInfo::doesJumpRecord()</a>, <a class="el" href="structLowlevelError.html#afa821264468ba7772c966aab644796c4">LowlevelError::explain</a>, <a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classActionDatabase.html#ac447fd4be8a1353b700467f7549a2cf9">ActionDatabase::getCurrent()</a>, <a class="el" href="classActionDatabase.html#a8191b5d0de5fc03e378f18c200247748">ActionDatabase::getCurrentName()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">Scope::getParent()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classJumpTable.html#a1f864164256b456f2cbad1933e61e140">JumpTable::getStage()</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba867c97a7dfff6488a06fbd51badb48b3">jumptablerecovery_on</a>, <a class="el" href="classFuncdata.html#a9e403edd5b4b01e8629bff49d936f939">localmap</a>, <a class="el" href="classFuncdata.html#abb2c1673cccd101653606f7f5e4a8eb8">name</a>, <a class="el" href="classAction.html#a44042367ad3fd93c6dba73a41a047c5c">Action::perform()</a>, <a class="el" href="classAddress.html#a040ac0edbb01bd26c8956130ec4ef20e">Address::printRaw()</a>, <a class="el" href="classJumpTable.html#a98aaa32e26ede9547d5979cab872322c">JumpTable::recoverAddresses()</a>, <a class="el" href="classJumpTable.html#afba6e59f39d15b0f5b231ef9d849625e">JumpTable::recoverMultistage()</a>, <a class="el" href="classAction.html#ac7c1cf16bb63e0741ba16be5179cf943">Action::reset()</a>, <a class="el" href="classActionDatabase.html#a19e09431e4e66936090715ab8afe774b">ActionDatabase::setCurrent()</a>, <a class="el" href="classJumpTable.html#a999b901e638cfc2243b0e7578355c662">JumpTable::setIndirectOp()</a>, <a class="el" href="classJumpTable.html#a837e0e4ccf4f0be70df4f9b55106305a">JumpTable::setLoadCollect()</a>, <a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">truncatedFlow()</a>, and <a class="el" href="classFuncdata.html#a1c52c01a921d0ec70e263f0acba1344b">warning()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a38d58c33cdc77c663fceb7de1f6aadeb">recoverJumpTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a0637a2c7f6a1e511284cfeecb4b0d475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::startProcessing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start processing for this function. </p>
<p>This routine does basic set-up for analyzing the function. In particular, it generates the raw p-code, builds basic blocks, and generates the call specification objects. </p>

<p>References <a class="el" href="classOverride.html#a75a0b8a3ef2d78ad0c6edb910810e408">Override::applyDeadCodeDelay()</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classHeritage.html#a7cca3fa6fe1e5d6241ca3e0f0a29af42">Heritage::buildInfoList()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classFuncdata.html#a5c8f8e90f70db000a97d80677cdb133b">followFlow()</a>, <a class="el" href="classFuncdata.html#a4c933ff90fe37557164652d70f5b34d1">funcp</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classFuncdata.html#a74503254ffd9061b07f973580a0d1af6">heritage</a>, <a class="el" href="classFuncProto.html#a93ef8c7a2b09476fcfbdf21cd8a01fbf">FuncProto::isInline()</a>, <a class="el" href="classFuncdata.html#a21754a3c362d2208f9ee7f317cf504b9">localoverride</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba42380621eb49e673f20d9c68a0d8a0d2">processing_started</a>, <a class="el" href="classFuncdata.html#a58664772693fca369a469c1540c65e2a">sortCallSpecs()</a>, <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classActionStart.html#a9e21953bb17c18610189c3d28b1ab0a9">ActionStart::apply()</a>, and <a class="el" href="classFuncdata.html#a1665c646d412bf857673ecb8378eeae1">hasNoStructBlocks()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fde73229529d726f73be2fe9319c1b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::structureReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate initial basic block structures (after a control-flow change) </p>
<p>For the current control-flow graph, (re)calculate the loop structure and dominance. This can be called multiple times as changes are made to control-flow. The structured hierarchy is also reset. </p>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba2141384f04dddfa59948fa3169c74935">blocks_unreachable</a>, <a class="el" href="classBlockGraph.html#a9026a993cc70a3e67c5eeb19d33a9d98">BlockGraph::calcForwardDominator()</a>, <a class="el" href="classBlockGraph.html#a1220886c0c0cad9c8f482afe53dba5d4">BlockGraph::clear()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classHeritage.html#ad3b79b20f375f99c6ed06fc5941cccd5">Heritage::forceRestructure()</a>, <a class="el" href="classJumpTable.html#a40c6181b864e78426ddcc95b9feaed2f">JumpTable::getIndirectOp()</a>, <a class="el" href="classFuncdata.html#a74503254ffd9061b07f973580a0d1af6">heritage</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>, <a class="el" href="classFuncdata.html#a37058a8643a9c57cdf5e00e709730ea0">sblocks</a>, <a class="el" href="classBlockGraph.html#a468717bd5cf1e3bd34e5221a5d425bd9">BlockGraph::structureLoops()</a>, and <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">warningHeader()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ad810c24ce5fb16a95de1f7d27c8856d8">nodeJoinCreateBlock()</a>, <a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit()</a>, <a class="el" href="classFuncdata.html#aa2d635570305e3ea710ade3cf090ba8c">pushBranch()</a>, <a class="el" href="classFuncdata.html#a3a53162bf9a1756c4f2f4d7d1d7bbcec">removeBranch()</a>, <a class="el" href="classFuncdata.html#aa486c5f0556919686a9fdad4ebc2dcc1">removeDoNothingBlock()</a>, <a class="el" href="classFuncdata.html#af83619924b5d0fed25d0563b0f243262">removeFromFlowSplit()</a>, <a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks()</a>, <a class="el" href="classFuncdata.html#a9f0c9d7c7fb4217731ae45f7848e4034">spliceBlockBasic()</a>, <a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">startProcessing()</a>, and <a class="el" href="classFuncdata.html#a5ba1555023c49006ed39936b9a40aba4">switchEdge()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba1555023c49006ed39936b9a40aba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::switchEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFlowBlock.html">FlowBlock</a> *&#160;</td>
          <td class="paramname"><em>inblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>outbefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowBlock.html">FlowBlock</a> *&#160;</td>
          <td class="paramname"><em>outafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch an outgoing edge from the given <em>source</em> block to flow into another block. </p>
<p>This does <em>not</em> adjust MULTIEQUAL data-flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inblock</td><td>is the given <em>source</em> block </td></tr>
    <tr><td class="paramname">outbefore</td><td>is the other side of the desired edge </td></tr>
    <tr><td class="paramname">outafter</td><td>is the new destination block desired </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>, and <a class="el" href="classBlockGraph.html#a238a3ecac594008e2893b2fa1f85d95b">BlockGraph::switchEdge()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a307d12e7da23cd0c737549da4ff6679b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::switchOverJumpTables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFlowInfo.html">FlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>flow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert jump-table addresses to basic block indices. </p>
<p>For each jump-table, for each address, the corresponding basic block index is computed. This also calculates the <em>default</em> branch for each jump-table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow</td><td>is the flow object (mapping addresses to p-code ops) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a5c8f8e90f70db000a97d80677cdb133b">followFlow()</a>.</p>

</div>
</div>
<a class="anchor" id="a97d0b153ce9e5ff67bf0724ad945e866"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::syncVarnodesWithSymbol </td>
          <td>(</td>
          <td class="paramtype">VarnodeLocSet::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update properties (and the data-type) for a set of Varnodes associated with one <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. </p>
<p>The set of Varnodes with the same size and address all have their boolean properties updated to the given values. The set is specified by providing an iterator reference to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the set assuming a 'loc' ordering. This iterator is updated to point to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> after the affected set.</p>
<p>The only properties that can be effectively changed with this routine are <b>mapped</b>, <b>addrtied</b>, <b>addrforce</b>, and <b>nolocalalias</b>. <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> splits must occur if <b>addrtied</b> is cleared.</p>
<p>If the given data-type is non-null, an attempt is made to update all the Varnodes to this data-type. The <b>typelock</b> and <b>namelock</b> properties cannot be changed here. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>points to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the set </td></tr>
    <tr><td class="paramname">flags</td><td>holds the new set of boolean properties </td></tr>
    <tr><td class="paramname">ct</td><td>is the given data-type to set (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if at least one <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was modified </dd></dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cabecfcc64c4827f783e3e538b3b9dfd6c">Varnode::addrforce</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classVarnode.html#a3f713f10162d1318969b44b7d585fdfc">Varnode::clearFlags()</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classHighVariable.html#a1fa583acd137dfe2c9a2aae1c6a3c739">HighVariable::finalizeDatatype()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a436419e5a1ee0e2b2467e5b543a65596">Varnode::getFlags()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classVarnode.html#a1e44191c7c35c94122e1a2abe49a3292">Varnode::mapentry</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca682ddee1f9b9f32c4d8a69dc53b8bf69">Varnode::nolocalalias</a>, <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>, <a class="el" href="classVarnode.html#a48932e5bf8aab53ae9b3a6a6d9b25ce8">Varnode::updateType()</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aca583e76acc0a61bc30bd32461d25aee">syncVarnodesWithSymbols()</a>.</p>

</div>
</div>
<a class="anchor" id="aca583e76acc0a61bc30bd32461d25aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::syncVarnodesWithSymbols </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td>
          <td class="paramname"><em>lm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>typesyes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties based on (new) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> information. </p>
<p>Boolean properties <b>addrtied</b>, <b>addrforce</b>, and <b>nolocalalias</b> for Varnodes are updated based on new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> information they map to. The caller can elect to update data-type information as well, where Varnodes and their associated HighVariables have their data-type finalized based symbols. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> scope within which to search for mapped Varnodes </td></tr>
    <tr><td class="paramname">typesyes</td><td>is <b>true</b> if the caller wants to update data-types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if any <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was updated </dd></dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classVarnodeBank.html#aadc19c865c51af69f235b0553638a8bd">VarnodeBank::beginLoc()</a>, <a class="el" href="classVarnodeBank.html#a62b28211606f1709f9d9e8970141c2cc">VarnodeBank::endLoc()</a>, <a class="el" href="classScopeInternal.html#a46047e9ff93303ae939532c088b450e2">ScopeInternal::findOverlap()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classSymbolEntry.html#ac517c7893243db29758dff59f7615542">SymbolEntry::getAllFlags()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classSymbolEntry.html#ac4d58016d6b5561cc943b5ff53121c33">SymbolEntry::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classScopeLocal.html#a62a9177e39783b68d975d92bd6b308d8">ScopeLocal::getSpaceId()</a>, <a class="el" href="classDatatype.html#a88bdee9c5df55dba85ccb3868ee20582">Datatype::getSubType()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, <a class="el" href="classSymbol.html#ad3bc7110cbcbeebbd642ba8e3342a59d">Symbol::getType()</a>, <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">Scope::inScope()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0b1de824f917f0c708db4fa4b8caaeb8">Varnode::namelock</a>, <a class="el" href="classFuncdata.html#a97d0b153ce9e5ff67bf0724ad945e866">syncVarnodesWithSymbol()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cae49e063a1b1e7de4592afd3f19abbdc7">Varnode::typelock</a>, and <a class="el" href="classFuncdata.html#a70ffa1ac8ad55ab4510c4fd5fb592d30">vbank</a>.</p>

<p>Referenced by <a class="el" href="classActionRestructureVarnode.html#ae2fc4e8dada82bfc532f072aebeb1a73">ActionRestructureVarnode::apply()</a>, <a class="el" href="classActionRestructureHigh.html#aeeacf5bf4d99c638c486a23b69f19207">ActionRestructureHigh::apply()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="aab7f940f85609d395283520eca3a71f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::totalReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>newvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all read references to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (being replaced) </td></tr>
    <tr><td class="paramname">newvn</td><td>is the second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (the replacement) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, and <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes()</a>, <a class="el" href="classRulePushMulti.html#ae0c4fc01da336893e20b3ea0fb9c4f23">RulePushMulti::applyOp()</a>, <a class="el" href="classRuleIndirectCollapse.html#a0d4041209c44deabc2baa829c022d642">RuleIndirectCollapse::applyOp()</a>, <a class="el" href="classRuleMultiCollapse.html#a65f32f0c3dfaad6ba711cb1c9dc72954">RuleMultiCollapse::applyOp()</a>, <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>, <a class="el" href="funcdata_8hh.html#aec60042aabc4e62a2625348cf20d321c">cseElimination()</a>, <a class="el" href="classActionMultiCse.html#aeed5c0ca7367c55687a61bcc2df3b239">ActionMultiCse::processBlock()</a>, and <a class="el" href="classSubvariableFlow.html#a8f8c80032b3fa35e825e18b3d8d98197">SubvariableFlow::replaceInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a2934e1e4246d41a5e28f6fcb56acc937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::totalReplaceConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every read reference of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a constant value. </p>
<p>A new constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is created for each read site. If there are any marker ops (MULTIEQUAL) a single COPY op is inserted and the marker input is set to be the output of the COPY. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">val</td><td>is the constant value to replace it with </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncdata.html#afb7cb4ba7c665f0575d7f314ad329364">getBasicBlocks()</a>, <a class="el" href="classBlockGraph.html#a8a8163564a0e9217cab5f085eab2684e">BlockGraph::getBlock()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter()</a>, <a class="el" href="classFuncdata.html#ae6341eb8ca8a8004f1c77a8e8147a286">opInsertBegin()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, and <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode()</a>.</p>

<p>Referenced by <a class="el" href="classActionVarnodeProps.html#a531c9985eb2e6a5796009bea79a465fe">ActionVarnodeProps::apply()</a>, and <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>.</p>

</div>
</div>
<a class="anchor" id="a070edf06c2d300a7d6d1bda21189b477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::transferVarnodeProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>newVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>lsbOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy properties from an existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>The new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is assumed to overlap the storage of the existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. Properties like boolean flags and <em>consume</em> bits are copied as appropriate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">newVn</td><td>is the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that has its properties set </td></tr>
    <tr><td class="paramname">lsbOffset</td><td>is the significance offset of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> within the exising </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8cabecfcc64c4827f783e3e538b3b9dfd6c">Varnode::addrforce</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8caac2abc47efea38d093747758c9b204fd">Varnode::directwrite</a>, <a class="el" href="classVarnode.html#aa0509a14346e4be157b7040ef39d1843">Varnode::getConsume()</a>, <a class="el" href="classVarnode.html#a436419e5a1ee0e2b2467e5b543a65596">Varnode::getFlags()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a809aa02a00ff30f8348009bb31c2499a">Varnode::setConsume()</a>, and <a class="el" href="classVarnode.html#ac548830ed63593cd2af728082aa9a3fb">Varnode::setFlags()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap()</a>, and <a class="el" href="classTransformVar.html#a27d493f8328edf4b30a9856279973af3">TransformVar::createReplacement()</a>.</p>

</div>
</div>
<a class="anchor" id="a122718ad87c13b714676c61050461388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::truncatedFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFlowInfo.html">FlowInfo</a> *&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a clone with truncated control-flow given a partial function. </p>
<p>Existing p-code is cloned from another function whose flow has not been completely followed. Artificial halt operators are inserted wherever flow is incomplete and basic blocks are generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the partial function to clone </td></tr>
    <tr><td class="paramname">flow</td><td>is partial function's flow information </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a8a44b7fe1b50a7b0dfa195d0825bf5eb">bblocks</a>, <a class="el" href="classPcodeOpBank.html#acc4e2cf26d777465eddce69e9489103f">PcodeOpBank::beginDead()</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092baa5c01d2784c4599efd6b866439a2700c">blocks_generated</a>, <a class="el" href="classFlowInfo.html#a9484944b8fee15fc9a85ce26c4f878ae">FlowInfo::clearFlags()</a>, <a class="el" href="classFuncCallSpecs.html#ae24c733f6fbfbb4288d231869f69455d">FuncCallSpecs::clone()</a>, <a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp()</a>, <a class="el" href="classFuncdata.html#aa8657c4c04279316593adc6d2f389be5">deleteVarnode()</a>, <a class="el" href="classPcodeOpBank.html#a2a86c7b123691edbe60ba64aef82e770">PcodeOpBank::empty()</a>, <a class="el" href="classPcodeOpBank.html#a3440727d10a26a9cbf401b5933620fbb">PcodeOpBank::endDead()</a>, <a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp()</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classFlowInfo.html#a5c8f51cb6c88719657801a2f26e87fae">FlowInfo::generateBlocks()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFuncCallSpecs.html#a82b3a2d5f5b918348806e20d18cd0529">FuncCallSpecs::getOp()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classPcodeOpBank.html#aa7244342aa0738ce867f31312177b01c">PcodeOpBank::getUniqId()</a>, <a class="el" href="classFlowInfo.html#ae8db9c44a9f413332f7c7965638f7017">FlowInfo::hasInject()</a>, <a class="el" href="classFlowInfo.html#af91718ae694b4852c24f4af6cb0b07a0">FlowInfo::injectPcode()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a01bf4d06e504bf92eabbfd633e5c74c0">IPTR_FSPEC</a>, <a class="el" href="classFuncdata.html#ac6d550737246266d62752b5ebc18d881">jumpvec</a>, <a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">newVarnodeCallSpecs()</a>, <a class="el" href="classFuncdata.html#a9767dc1053f685ee11d0771d3aca1681">obank</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput()</a>, <a class="el" href="classFlowInfo.html#a3c397df76e4f7124bac4929736d56efca6dc22b8a298dc4a3b91ddb7b3574835d">FlowInfo::possible_unreachable</a>, <a class="el" href="classFuncdata.html#aa8e08833a58a93938d74fb0775e13c2e">qlst</a>, <a class="el" href="classJumpTable.html#a999b901e638cfc2243b0e7578355c662">JumpTable::setIndirectOp()</a>, and <a class="el" href="classPcodeOpBank.html#a598db9267369f9dbe7d044ac3dbb03e9">PcodeOpBank::setUniqId()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a4f8f18dcdcc8c4e53c9851678d897537">getCleanUpIndex()</a>, and <a class="el" href="classFuncdata.html#ae8b08186fd6b91718d81930f3dda621a">stageJumpTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c52c01a921d0ec70e263f0acba1344b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::warning </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>ad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a warning comment in the function body. </p>
<p>The comment is added to the global database, indexed via its placement address and the entry address of the function. The emitter will attempt to place the comment before the source expression that maps most closely to the address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txt</td><td>is the string body of the comment </td></tr>
    <tr><td class="paramname">ad</td><td>is the placement address </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classCommentDatabase.html#a41b306ed1b9ac26a4b2c80a927be3364">CommentDatabase::addCommentNoDuplicate()</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">Architecture::commentdb</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba867c97a7dfff6488a06fbd51badb48b3">jumptablerecovery_on</a>, and <a class="el" href="classComment.html#a25e5457bf3deeb109bdef2f532317cf2a2166c8f68c37806afa4c67052b04b51e">Comment::warning</a>.</p>

<p>Referenced by <a class="el" href="classActionSetCasts.html#a9999706f3347f707e39c28b5a208fbd3">ActionSetCasts::apply()</a>, <a class="el" href="classActionDoNothing.html#a731f2fd0ba173c40a794de849bfabe4b">ActionDoNothing::apply()</a>, <a class="el" href="classActionPrototypeWarnings.html#a6f52b3f6147c5baac2d7a27c90234001">ActionPrototypeWarnings::apply()</a>, <a class="el" href="classRuleIndirectCollapse.html#a0d4041209c44deabc2baa829c022d642">RuleIndirectCollapse::applyOp()</a>, <a class="el" href="classJumpBasic.html#a55ec8adb4212683112450bda55dafefd">JumpBasic::buildLabels()</a>, <a class="el" href="classJumpBasicOverride.html#a8e41d027d947b0260c07c74345158c16">JumpBasicOverride::buildLabels()</a>, <a class="el" href="classAddTreeState.html#a8f392e1525b28ab09bfda8c210bff22e">AddTreeState::buildTree()</a>, <a class="el" href="classFlowInfo.html#a5ee6e359bad18470fccb70737431794b">FlowInfo::checkContainedCall()</a>, <a class="el" href="classFlowInfo.html#a87f6db03a03d72828478d7bfcf62e3bc">FlowInfo::checkForFlowModification()</a>, <a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly()</a>, <a class="el" href="classFlowInfo.html#a1bbef8af1f3a1151deb610364a6b9be4">FlowInfo::handleOutOfBounds()</a>, <a class="el" href="classFuncdata.html#a1665c646d412bf857673ecb8378eeae1">hasNoStructBlocks()</a>, <a class="el" href="classFlowInfo.html#aef170ff26d02065875f05d30fcc5364d">FlowInfo::processInstruction()</a>, <a class="el" href="classJumpTable.html#aa104a5da577eb8a1a5ab9aa30bbc7210">JumpTable::recoverLabels()</a>, <a class="el" href="classJumpTable.html#afba6e59f39d15b0f5b231ef9d849625e">JumpTable::recoverMultistage()</a>, <a class="el" href="classJumpTable.html#a37b2d40418bb288b1c3f21a0b11904d5">JumpTable::sanityCheck()</a>, <a class="el" href="classFuncdata.html#ae8b08186fd6b91718d81930f3dda621a">stageJumpTable()</a>, <a class="el" href="classFlowInfo.html#a7ce3b6b33fb219117c69700e32b0c1ef">FlowInfo::testHardInlineRestrictions()</a>, and <a class="el" href="classFlowInfo.html#ae2f7f6ff7a348b02fae44fe60c284600">FlowInfo::truncateIndirectJump()</a>.</p>

</div>
</div>
<a class="anchor" id="a5084ee379b9bdbcd47ef1b4b73a7b362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::warningHeader </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>txt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a warning comment as part of the function header. </p>
<p>The warning will be emitted as part of the block comment printed right before the prototype. The comment is stored in the global comment database, indexed via the function's entry address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txt</td><td>is the string body of the comment </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classCommentDatabase.html#a41b306ed1b9ac26a4b2c80a927be3364">CommentDatabase::addCommentNoDuplicate()</a>, <a class="el" href="classFuncdata.html#ab458fa1ba652de0e05d7cad3c46a2860">baseaddr</a>, <a class="el" href="classArchitecture.html#a5425576df9b7ce15b6ddddbf17b03df6">Architecture::commentdb</a>, <a class="el" href="classFuncdata.html#a652b56184c061181d44733a6d5b19069">flags</a>, <a class="el" href="classFuncdata.html#a4891fce136f49993879f1bf1a9a6000c">glb</a>, <a class="el" href="classFuncdata.html#a0e9155d59329f73a01081dbe709d092ba867c97a7dfff6488a06fbd51badb48b3">jumptablerecovery_on</a>, and <a class="el" href="classComment.html#a25e5457bf3deeb109bdef2f532317cf2a22b7847860fc380835ca045cc01af9ee">Comment::warningheader</a>.</p>

<p>Referenced by <a class="el" href="classActionStackPtrFlow.html#a4f93079a3ade269842842a7fad126a12">ActionStackPtrFlow::analyzeExtraPop()</a>, <a class="el" href="classAddTreeState.html#a1fba7b1b0b2a97ada10a8a59ab2e6cd4">AddTreeState::apply()</a>, <a class="el" href="classActionRestartGroup.html#ab597697ab15a9b8f1a25832f43bdeb0d">ActionRestartGroup::apply()</a>, <a class="el" href="classActionInferTypes.html#a0f50c538353ecf22ba3651d8e1a661ed">ActionInferTypes::apply()</a>, <a class="el" href="classActionPrototypeWarnings.html#a6f52b3f6147c5baac2d7a27c90234001">ActionPrototypeWarnings::apply()</a>, <a class="el" href="classRuleSwitchSingle.html#ab884de26def65edb9ade3b981c6983e1">RuleSwitchSingle::applyOp()</a>, <a class="el" href="classFuncdata.html#a69dddb637a6e322632f9a4bb10c5c36e">attemptDynamicMappingLate()</a>, <a class="el" href="classFuncdata.html#abaec6200c5a0eec8dbb24aef0348ab3a">blockRemoveInternal()</a>, <a class="el" href="classFlowInfo.html#a5ee6e359bad18470fccb70737431794b">FlowInfo::checkContainedCall()</a>, <a class="el" href="classFlowInfo.html#a1bbef8af1f3a1151deb610364a6b9be4">FlowInfo::handleOutOfBounds()</a>, <a class="el" href="classFuncdata.html#a1665c646d412bf857673ecb8378eeae1">hasNoStructBlocks()</a>, <a class="el" href="classFlowInfo.html#af91718ae694b4852c24f4af6cb0b07a0">FlowInfo::injectPcode()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">mapGlobals()</a>, <a class="el" href="classScopeLocal.html#a560ea5441b79ef3c17b890c7d37ccaf1">ScopeLocal::markNotMapped()</a>, <a class="el" href="classFlowInfo.html#aef170ff26d02065875f05d30fcc5364d">FlowInfo::processInstruction()</a>, <a class="el" href="classFuncdata.html#ae76e681657570c6494c366c16825f130">pushMultiequals()</a>, <a class="el" href="classFlowInfo.html#a1dd41bca8d8ce3a17e7d2f987ba14807">FlowInfo::reinterpreted()</a>, <a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks()</a>, <a class="el" href="classFuncCallSpecs.html#a5ad2a3f374049dec6fdf0f9d20295305">FuncCallSpecs::resolveSpacebaseRelative()</a>, <a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">startProcessing()</a>, and <a class="el" href="classFuncdata.html#a5fde73229529d726f73be2fe9319c1b8">structureReset()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="funcdata_8hh.html">funcdata.hh</a></li>
<li>funcdata.cc</li>
<li>funcdata_block.cc</li>
<li>funcdata_op.cc</li>
<li>funcdata_varnode.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
