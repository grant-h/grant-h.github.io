<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: Heritage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classHeritage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Heritage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manage the construction of Static Single Assignment (SSA) form.  
 <a href="classHeritage.html#details">More...</a></p>

<p><code>#include &lt;heritage.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHeritage_1_1StackNode.html">StackNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node for depth-first traversal of stack references.  <a href="structHeritage_1_1StackNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9241f6a476085c88c540e34a44c5f197"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9241f6a476085c88c540e34a44c5f197">Heritage</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *data)</td></tr>
<tr class="memdesc:a9241f6a476085c88c540e34a44c5f197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9241f6a476085c88c540e34a44c5f197">More...</a><br /></td></tr>
<tr class="separator:a9241f6a476085c88c540e34a44c5f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa572fa9111fcc29b4341445794271886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa572fa9111fcc29b4341445794271886"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#aa572fa9111fcc29b4341445794271886">getPass</a> (void) const </td></tr>
<tr class="memdesc:aa572fa9111fcc29b4341445794271886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get overall count of heritage passes. <br /></td></tr>
<tr class="separator:aa572fa9111fcc29b4341445794271886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431e524dcdc8abbef3d6755023d5eee9"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a431e524dcdc8abbef3d6755023d5eee9">heritagePass</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a431e524dcdc8abbef3d6755023d5eee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pass number when the given address was heritaged.  <a href="#a431e524dcdc8abbef3d6755023d5eee9">More...</a><br /></td></tr>
<tr class="separator:a431e524dcdc8abbef3d6755023d5eee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24cd8c63c9efbc8bb17cd17a3530d8a"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ac24cd8c63c9efbc8bb17cd17a3530d8a">numHeritagePasses</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:ac24cd8c63c9efbc8bb17cd17a3530d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number times heritage was performed for the given address space.  <a href="#ac24cd8c63c9efbc8bb17cd17a3530d8a">More...</a><br /></td></tr>
<tr class="separator:ac24cd8c63c9efbc8bb17cd17a3530d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcd7a583bd605db1177b9c2e0be599f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#abbcd7a583bd605db1177b9c2e0be599f">seenDeadCode</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:abbcd7a583bd605db1177b9c2e0be599f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform system of dead code removal in given space.  <a href="#abbcd7a583bd605db1177b9c2e0be599f">More...</a><br /></td></tr>
<tr class="separator:abbcd7a583bd605db1177b9c2e0be599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2a23ac011d09fad5c4e388e706d47b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#aac2a23ac011d09fad5c4e388e706d47b">getDeadCodeDelay</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:aac2a23ac011d09fad5c4e388e706d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pass delay for heritaging the given space.  <a href="#aac2a23ac011d09fad5c4e388e706d47b">More...</a><br /></td></tr>
<tr class="separator:aac2a23ac011d09fad5c4e388e706d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377c55d2b77f230779ad43e341e6a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a8377c55d2b77f230779ad43e341e6a29">setDeadCodeDelay</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 delay)</td></tr>
<tr class="memdesc:a8377c55d2b77f230779ad43e341e6a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set delay for a specific space.  <a href="#a8377c55d2b77f230779ad43e341e6a29">More...</a><br /></td></tr>
<tr class="separator:a8377c55d2b77f230779ad43e341e6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a0931e4aec896e41751c4569f22f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a323a0931e4aec896e41751c4569f22f4">deadRemovalAllowed</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:a323a0931e4aec896e41751c4569f22f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if it is <em>safe</em> to remove dead code.  <a href="#a323a0931e4aec896e41751c4569f22f4">More...</a><br /></td></tr>
<tr class="separator:a323a0931e4aec896e41751c4569f22f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbf92b2085d45de9f3920824a51786c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a2bbf92b2085d45de9f3920824a51786c">deadRemovalAllowedSeen</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a2bbf92b2085d45de9f3920824a51786c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if dead code removal is safe and mark that removal has happened.  <a href="#a2bbf92b2085d45de9f3920824a51786c">More...</a><br /></td></tr>
<tr class="separator:a2bbf92b2085d45de9f3920824a51786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cca3fa6fe1e5d6241ca3e0f0a29af42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a7cca3fa6fe1e5d6241ca3e0f0a29af42">buildInfoList</a> (void)</td></tr>
<tr class="memdesc:a7cca3fa6fe1e5d6241ca3e0f0a29af42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize information for each space.  <a href="#a7cca3fa6fe1e5d6241ca3e0f0a29af42">More...</a><br /></td></tr>
<tr class="separator:a7cca3fa6fe1e5d6241ca3e0f0a29af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b79b20f375f99c6ed06fc5941cccd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3b79b20f375f99c6ed06fc5941cccd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ad3b79b20f375f99c6ed06fc5941cccd5">forceRestructure</a> (void)</td></tr>
<tr class="memdesc:ad3b79b20f375f99c6ed06fc5941cccd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force regeneration of basic block structures. <br /></td></tr>
<tr class="separator:ad3b79b20f375f99c6ed06fc5941cccd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdea4058aa42f91bbdb5a9b3171950f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a7cdea4058aa42f91bbdb5a9b3171950f">clear</a> (void)</td></tr>
<tr class="memdesc:a7cdea4058aa42f91bbdb5a9b3171950f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all analysis of heritage.  <a href="#a7cdea4058aa42f91bbdb5a9b3171950f">More...</a><br /></td></tr>
<tr class="separator:a7cdea4058aa42f91bbdb5a9b3171950f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad710084ce475a863e5d5d800300e3fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ad710084ce475a863e5d5d800300e3fd8">heritage</a> (void)</td></tr>
<tr class="memdesc:ad710084ce475a863e5d5d800300e3fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one pass of heritage.  <a href="#ad710084ce475a863e5d5d800300e3fd8">More...</a><br /></td></tr>
<tr class="separator:ad710084ce475a863e5d5d800300e3fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933cb9f2d15ee5a99281152c73de3671"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a933cb9f2d15ee5a99281152c73de3671"></a>
const list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a933cb9f2d15ee5a99281152c73de3671">getLoadGuards</a> (void) const </td></tr>
<tr class="memdesc:a933cb9f2d15ee5a99281152c73de3671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of LOAD ops that are guarded. <br /></td></tr>
<tr class="separator:a933cb9f2d15ee5a99281152c73de3671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396cc1d53bea01595f6dea0e45e1b385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a396cc1d53bea01595f6dea0e45e1b385"></a>
const list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a396cc1d53bea01595f6dea0e45e1b385">getStoreGuards</a> (void) const </td></tr>
<tr class="memdesc:a396cc1d53bea01595f6dea0e45e1b385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of STORE ops that are guarded. <br /></td></tr>
<tr class="separator:a396cc1d53bea01595f6dea0e45e1b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e83d0857be5f4e3691dd095da2089a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLoadGuard.html">LoadGuard</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a7e83d0857be5f4e3691dd095da2089a8">getStoreGuard</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const </td></tr>
<tr class="memdesc:a7e83d0857be5f4e3691dd095da2089a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> record associated with given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a7e83d0857be5f4e3691dd095da2089a8">More...</a><br /></td></tr>
<tr class="separator:a7e83d0857be5f4e3691dd095da2089a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a8f4969857c70b95f52ff187801784e39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a8f4969857c70b95f52ff187801784e39">heritage_flags</a> { <a class="el" href="classHeritage.html#a8f4969857c70b95f52ff187801784e39a139d8056b56fe06ee44712a26d0261b5">boundary_node</a> = 1, 
<a class="el" href="classHeritage.html#a8f4969857c70b95f52ff187801784e39ac87fb7719d1f75c85379a9fc39ab5ec0">mark_node</a> = 2, 
<a class="el" href="classHeritage.html#a8f4969857c70b95f52ff187801784e39afb347c510a9f922416d835f8d292892b">merged_node</a> = 4
 }<tr class="memdesc:a8f4969857c70b95f52ff187801784e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra boolean properties on basic blocks for the Augmented Dominator Tree.  <a href="classHeritage.html#a8f4969857c70b95f52ff187801784e39">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8f4969857c70b95f52ff187801784e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a101ba7f429e87d2316b757d98199ecc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a101ba7f429e87d2316b757d98199ecc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a101ba7f429e87d2316b757d98199ecc2">clearInfoList</a> (void)</td></tr>
<tr class="memdesc:a101ba7f429e87d2316b757d98199ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset heritage status for all address spaces. <br /></td></tr>
<tr class="separator:a101ba7f429e87d2316b757d98199ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7623c071b5550fbc1df9066b9fccb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd7623c071b5550fbc1df9066b9fccb6"></a>
<a class="el" href="classHeritageInfo.html">HeritageInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#abd7623c071b5550fbc1df9066b9fccb6">getInfo</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:abd7623c071b5550fbc1df9066b9fccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the heritage status for the given address space. <br /></td></tr>
<tr class="separator:abd7623c071b5550fbc1df9066b9fccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75006a0db8a4a117a00790a7cea46739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75006a0db8a4a117a00790a7cea46739"></a>
const <a class="el" href="classHeritageInfo.html">HeritageInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a75006a0db8a4a117a00790a7cea46739">getInfo</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:a75006a0db8a4a117a00790a7cea46739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the heritage status for the given address space. <br /></td></tr>
<tr class="separator:a75006a0db8a4a117a00790a7cea46739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f48a8d050661256a4e76500f2aafc67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a5f48a8d050661256a4e76500f2aafc67">splitJoinLevel</a> (vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;lastcombo, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;nextlev, <a class="el" href="classJoinRecord.html">JoinRecord</a> *joinrec)</td></tr>
<tr class="memdesc:a5f48a8d050661256a4e76500f2aafc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one level of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> splitting to match a <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>.  <a href="#a5f48a8d050661256a4e76500f2aafc67">More...</a><br /></td></tr>
<tr class="separator:a5f48a8d050661256a4e76500f2aafc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4209665a068f85407a721865b8cfbd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a4209665a068f85407a721865b8cfbd14">splitJoinRead</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classJoinRecord.html">JoinRecord</a> *joinrec)</td></tr>
<tr class="memdesc:a4209665a068f85407a721865b8cfbd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct pieces for a <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> read by an operation.  <a href="#a4209665a068f85407a721865b8cfbd14">More...</a><br /></td></tr>
<tr class="separator:a4209665a068f85407a721865b8cfbd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c978bf61697b1725ccc7e4159c39d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a7c978bf61697b1725ccc7e4159c39d4a">splitJoinWrite</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classJoinRecord.html">JoinRecord</a> *joinrec)</td></tr>
<tr class="memdesc:a7c978bf61697b1725ccc7e4159c39d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a written <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into specified pieces.  <a href="#a7c978bf61697b1725ccc7e4159c39d4a">More...</a><br /></td></tr>
<tr class="separator:a7c978bf61697b1725ccc7e4159c39d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eee152b9eed9584ff2a5e7512c863ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a4eee152b9eed9584ff2a5e7512c863ff">floatExtensionRead</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classJoinRecord.html">JoinRecord</a> *joinrec)</td></tr>
<tr class="memdesc:a4eee152b9eed9584ff2a5e7512c863ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create float truncation into a free lower precision <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a4eee152b9eed9584ff2a5e7512c863ff">More...</a><br /></td></tr>
<tr class="separator:a4eee152b9eed9584ff2a5e7512c863ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ac655570588881959ee7aaeccc2188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a91ac655570588881959ee7aaeccc2188">floatExtensionWrite</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classJoinRecord.html">JoinRecord</a> *joinrec)</td></tr>
<tr class="memdesc:a91ac655570588881959ee7aaeccc2188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create float extension from a lower precision <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a91ac655570588881959ee7aaeccc2188">More...</a><br /></td></tr>
<tr class="separator:a91ac655570588881959ee7aaeccc2188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0650d1067110e8e82aeafaffa4324fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a0650d1067110e8e82aeafaffa4324fba">processJoins</a> (void)</td></tr>
<tr class="memdesc:a0650d1067110e8e82aeafaffa4324fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <em>join-space</em> Varnodes up into their real components.  <a href="#a0650d1067110e8e82aeafaffa4324fba">More...</a><br /></td></tr>
<tr class="separator:a0650d1067110e8e82aeafaffa4324fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5315c2907b7c90bc1bdd5d97f656dcb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a5315c2907b7c90bc1bdd5d97f656dcb6">buildADT</a> (void)</td></tr>
<tr class="memdesc:a5315c2907b7c90bc1bdd5d97f656dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the augmented dominator tree.  <a href="#a5315c2907b7c90bc1bdd5d97f656dcb6">More...</a><br /></td></tr>
<tr class="separator:a5315c2907b7c90bc1bdd5d97f656dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af722d75a0f8383480883c89adfbfee35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#af722d75a0f8383480883c89adfbfee35">removeRevisitedMarkers</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;remove, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:af722d75a0f8383480883c89adfbfee35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove deprecated CPUI_MULTIEQUAL or CPUI_INDIRECT ops, preparing to re-heritage.  <a href="#af722d75a0f8383480883c89adfbfee35">More...</a><br /></td></tr>
<tr class="separator:af722d75a0f8383480883c89adfbfee35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a2ec772f8cf4a7304848698588978d"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a09a2ec772f8cf4a7304848698588978d">collect</a> (<a class="el" href="classAddress.html">Address</a> addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;read, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;input, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;remove) const </td></tr>
<tr class="memdesc:a09a2ec772f8cf4a7304848698588978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect free reads, writes, and inputs in the given address range.  <a href="#a09a2ec772f8cf4a7304848698588978d">More...</a><br /></td></tr>
<tr class="separator:a09a2ec772f8cf4a7304848698588978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77f98c62d1bfd1062314c6c2a5035bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#aa77f98c62d1bfd1062314c6c2a5035bf">callOpIndirectEffect</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const </td></tr>
<tr class="memdesc:aa77f98c62d1bfd1062314c6c2a5035bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the address range is affected by the given call p-code op.  <a href="#aa77f98c62d1bfd1062314c6c2a5035bf">More...</a><br /></td></tr>
<tr class="separator:aa77f98c62d1bfd1062314c6c2a5035bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba48dbc84d89bd4fbd6db8f1053e015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#aaba48dbc84d89bd4fbd6db8f1053e015">normalizeReadSize</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:aaba48dbc84d89bd4fbd6db8f1053e015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the size of a read <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, prior to heritage.  <a href="#aaba48dbc84d89bd4fbd6db8f1053e015">More...</a><br /></td></tr>
<tr class="separator:aaba48dbc84d89bd4fbd6db8f1053e015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbbe85327f1494e087268d6f64b95b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9fbbe85327f1494e087268d6f64b95b8">normalizeWriteSize</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:a9fbbe85327f1494e087268d6f64b95b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the size of a written <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, prior to heritage.  <a href="#a9fbbe85327f1494e087268d6f64b95b8">More...</a><br /></td></tr>
<tr class="separator:a9fbbe85327f1494e087268d6f64b95b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9246dd5d8a7bbc7503ae1feff5342c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9246dd5d8a7bbc7503ae1feff5342c93">concatPieces</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;vnlist, <a class="el" href="classPcodeOp.html">PcodeOp</a> *insertop, <a class="el" href="classVarnode.html">Varnode</a> *finalvn)</td></tr>
<tr class="memdesc:a9246dd5d8a7bbc7503ae1feff5342c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a list of Varnodes together at the given location.  <a href="#a9246dd5d8a7bbc7503ae1feff5342c93">More...</a><br /></td></tr>
<tr class="separator:a9246dd5d8a7bbc7503ae1feff5342c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f30a5f936640e1aed8200a5fea0081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a40f30a5f936640e1aed8200a5fea0081">splitPieces</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;vnlist, <a class="el" href="classPcodeOp.html">PcodeOp</a> *insertop, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="classVarnode.html">Varnode</a> *startvn)</td></tr>
<tr class="memdesc:a40f30a5f936640e1aed8200a5fea0081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a set of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> piece expression at the given location.  <a href="#a40f30a5f936640e1aed8200a5fea0081">More...</a><br /></td></tr>
<tr class="separator:a40f30a5f936640e1aed8200a5fea0081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be0e3e2d24e0f434ea9ef54305f5afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9be0e3e2d24e0f434ea9ef54305f5afb">findAddressForces</a> (vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;copySinks, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;forces)</td></tr>
<tr class="memdesc:a9be0e3e2d24e0f434ea9ef54305f5afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last PcodeOps that write to specific addresses that flow to specific sites.  <a href="#a9be0e3e2d24e0f434ea9ef54305f5afb">More...</a><br /></td></tr>
<tr class="separator:a9be0e3e2d24e0f434ea9ef54305f5afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf53171a2207b2dad917b29c27fb538b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#acf53171a2207b2dad917b29c27fb538b">propagateCopyAway</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:acf53171a2207b2dad917b29c27fb538b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate a COPY sink preserving its data-flow.  <a href="#acf53171a2207b2dad917b29c27fb538b">More...</a><br /></td></tr>
<tr class="separator:acf53171a2207b2dad917b29c27fb538b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3b93fdab6eb48af508e81face11b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9c3b93fdab6eb48af508e81face11b17">handleNewLoadCopies</a> (void)</td></tr>
<tr class="memdesc:a9c3b93fdab6eb48af508e81face11b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the boundary of artificial ops introduced by load guards.  <a href="#a9c3b93fdab6eb48af508e81face11b17">More...</a><br /></td></tr>
<tr class="separator:a9c3b93fdab6eb48af508e81face11b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d518d053e1834e600be703ba0ac91b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a7d518d053e1834e600be703ba0ac91b1">analyzeNewLoadGuards</a> (void)</td></tr>
<tr class="memdesc:a7d518d053e1834e600be703ba0ac91b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make final determination of what range new LoadGuards are protecting.  <a href="#a7d518d053e1834e600be703ba0ac91b1">More...</a><br /></td></tr>
<tr class="separator:a7d518d053e1834e600be703ba0ac91b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b618cb9ee8b808ac256a6b55495f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a715b618cb9ee8b808ac256a6b55495f4">generateLoadGuard</a> (<a class="el" href="structHeritage_1_1StackNode.html">StackNode</a> &amp;node, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a715b618cb9ee8b808ac256a6b55495f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a guard record given an indexed LOAD into a stack space.  <a href="#a715b618cb9ee8b808ac256a6b55495f4">More...</a><br /></td></tr>
<tr class="separator:a715b618cb9ee8b808ac256a6b55495f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebebdbb80a796aab5ddab6dc6bb942d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9ebebdbb80a796aab5ddab6dc6bb942d">generateStoreGuard</a> (<a class="el" href="structHeritage_1_1StackNode.html">StackNode</a> &amp;node, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a9ebebdbb80a796aab5ddab6dc6bb942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a guard record given an indexed STORE to a stack space.  <a href="#a9ebebdbb80a796aab5ddab6dc6bb942d">More...</a><br /></td></tr>
<tr class="separator:a9ebebdbb80a796aab5ddab6dc6bb942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10902f4c1f68ed29b9b9f6803f81b82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ac10902f4c1f68ed29b9b9f6803f81b82">protectFreeStores</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;freeStores)</td></tr>
<tr class="memdesc:ac10902f4c1f68ed29b9b9f6803f81b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify any CPUI_STORE ops that use a free pointer from a given address space.  <a href="#ac10902f4c1f68ed29b9b9f6803f81b82">More...</a><br /></td></tr>
<tr class="separator:ac10902f4c1f68ed29b9b9f6803f81b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af292a2c38cdf9b300d433be7abacbee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#af292a2c38cdf9b300d433be7abacbee4">discoverIndexedStackPointers</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;freeStores, bool checkFreeStores)</td></tr>
<tr class="memdesc:af292a2c38cdf9b300d433be7abacbee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace input stack-pointer to any indexed loads.  <a href="#af292a2c38cdf9b300d433be7abacbee4">More...</a><br /></td></tr>
<tr class="separator:af292a2c38cdf9b300d433be7abacbee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c727cc9c420ab56b33a7b3d1342534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#aa7c727cc9c420ab56b33a7b3d1342534">reprocessFreeStores</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;freeStores)</td></tr>
<tr class="memdesc:aa7c727cc9c420ab56b33a7b3d1342534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revisit STOREs with free pointers now that a heritage pass has completed.  <a href="#aa7c727cc9c420ab56b33a7b3d1342534">More...</a><br /></td></tr>
<tr class="separator:aa7c727cc9c420ab56b33a7b3d1342534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f5419ca04e8266634478db0059a10d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#af6f5419ca04e8266634478db0059a10d">guard</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;read, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;inputvars)</td></tr>
<tr class="memdesc:af6f5419ca04e8266634478db0059a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize p-code ops so that phi-node placement and renaming works.  <a href="#af6f5419ca04e8266634478db0059a10d">More...</a><br /></td></tr>
<tr class="separator:af6f5419ca04e8266634478db0059a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa7b23fef6b20dfc2bb31f82a881d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a2aa7b23fef6b20dfc2bb31f82a881d3a">guardInput</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;input)</td></tr>
<tr class="memdesc:a2aa7b23fef6b20dfc2bb31f82a881d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure existing inputs for the given range fill it entirely.  <a href="#a2aa7b23fef6b20dfc2bb31f82a881d3a">More...</a><br /></td></tr>
<tr class="separator:a2aa7b23fef6b20dfc2bb31f82a881d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e83865af3d5e10a05513db464902b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#af7e83865af3d5e10a05513db464902b6">guardCallOverlappingInput</a> (<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *fc, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;transAddr, int4 size)</td></tr>
<tr class="memdesc:af7e83865af3d5e10a05513db464902b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard an address range that is larger than any single parameter.  <a href="#af7e83865af3d5e10a05513db464902b6">More...</a><br /></td></tr>
<tr class="separator:af7e83865af3d5e10a05513db464902b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eee271623cb06fb85aa3d99fda9f653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">guardCalls</a> (uint4 <a class="el" href="classHeritage.html#a4c5fd1df887850a5b2fe0d84af73c8a3">flags</a>, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write)</td></tr>
<tr class="memdesc:a8eee271623cb06fb85aa3d99fda9f653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard CALL/CALLIND ops in preparation for renaming algorithm.  <a href="#a8eee271623cb06fb85aa3d99fda9f653">More...</a><br /></td></tr>
<tr class="separator:a8eee271623cb06fb85aa3d99fda9f653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c1de2a4c6df7d4703112333e092303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ab4c1de2a4c6df7d4703112333e092303">guardStores</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write)</td></tr>
<tr class="memdesc:ab4c1de2a4c6df7d4703112333e092303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard STORE ops in preparation for the renaming algorithm.  <a href="#ab4c1de2a4c6df7d4703112333e092303">More...</a><br /></td></tr>
<tr class="separator:ab4c1de2a4c6df7d4703112333e092303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8e7c97c95c182b4264214ade1646fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#afe8e7c97c95c182b4264214ade1646fb">guardLoads</a> (uint4 <a class="el" href="classHeritage.html#a4c5fd1df887850a5b2fe0d84af73c8a3">flags</a>, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write)</td></tr>
<tr class="memdesc:afe8e7c97c95c182b4264214ade1646fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard LOAD ops in preparation for the renaming algorithm.  <a href="#afe8e7c97c95c182b4264214ade1646fb">More...</a><br /></td></tr>
<tr class="separator:afe8e7c97c95c182b4264214ade1646fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb8ba496fc607af9fa49743345f4ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#abdb8ba496fc607af9fa49743345f4ae7">guardReturns</a> (uint4 <a class="el" href="classHeritage.html#a4c5fd1df887850a5b2fe0d84af73c8a3">flags</a>, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write)</td></tr>
<tr class="memdesc:abdb8ba496fc607af9fa49743345f4ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard global data-flow at RETURN ops in preparation for renaming.  <a href="#abdb8ba496fc607af9fa49743345f4ae7">More...</a><br /></td></tr>
<tr class="separator:abdb8ba496fc607af9fa49743345f4ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25035a9cc1aeaadc38c1d9fc19ae9b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ab25035a9cc1aeaadc38c1d9fc19ae9b7">splitByRefinement</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const vector&lt; int4 &gt; &amp;refine, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;split)</td></tr>
<tr class="memdesc:ab25035a9cc1aeaadc38c1d9fc19ae9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split up a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> by the given <em>refinement</em>.  <a href="#ab25035a9cc1aeaadc38c1d9fc19ae9b7">More...</a><br /></td></tr>
<tr class="separator:ab25035a9cc1aeaadc38c1d9fc19ae9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc102fb06f08d2f8aa9f28c4a4e06be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#acbc102fb06f08d2f8aa9f28c4a4e06be">refineRead</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const vector&lt; int4 &gt; &amp;refine, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newvn)</td></tr>
<tr class="memdesc:acbc102fb06f08d2f8aa9f28c4a4e06be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split up a <b>free</b> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> based on the given refinement.  <a href="#acbc102fb06f08d2f8aa9f28c4a4e06be">More...</a><br /></td></tr>
<tr class="separator:acbc102fb06f08d2f8aa9f28c4a4e06be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6c3f775e4f08d3101cf2ca3a68e996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a7c6c3f775e4f08d3101cf2ca3a68e996">refineWrite</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const vector&lt; int4 &gt; &amp;refine, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newvn)</td></tr>
<tr class="memdesc:a7c6c3f775e4f08d3101cf2ca3a68e996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split up an output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> based on the given refinement.  <a href="#a7c6c3f775e4f08d3101cf2ca3a68e996">More...</a><br /></td></tr>
<tr class="separator:a7c6c3f775e4f08d3101cf2ca3a68e996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c6927fa0bd3e1347d4abc9258b2ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a97c6927fa0bd3e1347d4abc9258b2ec8">refineInput</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const vector&lt; int4 &gt; &amp;refine, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newvn)</td></tr>
<tr class="memdesc:a97c6927fa0bd3e1347d4abc9258b2ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split up a known input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> based on the given refinement.  <a href="#a97c6927fa0bd3e1347d4abc9258b2ec8">More...</a><br /></td></tr>
<tr class="separator:a97c6927fa0bd3e1347d4abc9258b2ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b94d5d447b2b9fa45dd98191ca9d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a22b94d5d447b2b9fa45dd98191ca9d18">remove13Refinement</a> (vector&lt; int4 &gt; &amp;refine)</td></tr>
<tr class="memdesc:a22b94d5d447b2b9fa45dd98191ca9d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we see 1-3 or 3-1 pieces in the partition, replace with a 4.  <a href="#a22b94d5d447b2b9fa45dd98191ca9d18">More...</a><br /></td></tr>
<tr class="separator:a22b94d5d447b2b9fa45dd98191ca9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e9ba0669069dd19eda511ab82be81a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a51e9ba0669069dd19eda511ab82be81a">refinement</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;readvars, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;writevars, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;inputvars)</td></tr>
<tr class="memdesc:a51e9ba0669069dd19eda511ab82be81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the common refinement of all reads and writes in the address range.  <a href="#a51e9ba0669069dd19eda511ab82be81a">More...</a><br /></td></tr>
<tr class="separator:a51e9ba0669069dd19eda511ab82be81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25aa595351a7c5877215f3a79cea33cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a25aa595351a7c5877215f3a79cea33cc">visitIncr</a> (<a class="el" href="classFlowBlock.html">FlowBlock</a> *qnode, <a class="el" href="classFlowBlock.html">FlowBlock</a> *vnode)</td></tr>
<tr class="memdesc:a25aa595351a7c5877215f3a79cea33cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heart of the phi-node placement algorithm.  <a href="#a25aa595351a7c5877215f3a79cea33cc">More...</a><br /></td></tr>
<tr class="separator:a25aa595351a7c5877215f3a79cea33cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e99606cab431e67415baba11d627f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a6f0e99606cab431e67415baba11d627f">calcMultiequals</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;write)</td></tr>
<tr class="memdesc:a6f0e99606cab431e67415baba11d627f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate blocks that should contain MULTIEQUALs for one address range.  <a href="#a6f0e99606cab431e67415baba11d627f">More...</a><br /></td></tr>
<tr class="separator:a6f0e99606cab431e67415baba11d627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdca2d8bbf0803bbe3c417161e113c42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#acdca2d8bbf0803bbe3c417161e113c42">renameRecurse</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, <a class="el" href="heritage_8hh.html#a06c866be068de18f657eeea50b3790ba">VariableStack</a> &amp;varstack)</td></tr>
<tr class="memdesc:acdca2d8bbf0803bbe3c417161e113c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heart of the renaming algorithm.  <a href="#acdca2d8bbf0803bbe3c417161e113c42">More...</a><br /></td></tr>
<tr class="separator:acdca2d8bbf0803bbe3c417161e113c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cc571403fc9d4277be2e985e76721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a051cc571403fc9d4277be2e985e76721">bumpDeadcodeDelay</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a051cc571403fc9d4277be2e985e76721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the heritage delay for the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and request a restart.  <a href="#a051cc571403fc9d4277be2e985e76721">More...</a><br /></td></tr>
<tr class="separator:a051cc571403fc9d4277be2e985e76721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf14995e58b23df915ad06e9ff7f1165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#acf14995e58b23df915ad06e9ff7f1165">placeMultiequals</a> (void)</td></tr>
<tr class="memdesc:acf14995e58b23df915ad06e9ff7f1165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform phi-node placement for the current set of address ranges.  <a href="#acf14995e58b23df915ad06e9ff7f1165">More...</a><br /></td></tr>
<tr class="separator:acf14995e58b23df915ad06e9ff7f1165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d25aa348dd9e8c5f13d708b2310772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a68d25aa348dd9e8c5f13d708b2310772">rename</a> (void)</td></tr>
<tr class="memdesc:a68d25aa348dd9e8c5f13d708b2310772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the renaming algorithm for the current set of address ranges.  <a href="#a68d25aa348dd9e8c5f13d708b2310772">More...</a><br /></td></tr>
<tr class="separator:a68d25aa348dd9e8c5f13d708b2310772"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a92cf595314cc2440d589a2728e3bfef3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a92cf595314cc2440d589a2728e3bfef3">buildRefinement</a> (vector&lt; int4 &gt; &amp;refine, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;vnlist)</td></tr>
<tr class="memdesc:a92cf595314cc2440d589a2728e3bfef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a refinement array given an address range and a list of Varnodes.  <a href="#a92cf595314cc2440d589a2728e3bfef3">More...</a><br /></td></tr>
<tr class="separator:a92cf595314cc2440d589a2728e3bfef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6efdce5e6dc6d14926d9122716bfad23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6efdce5e6dc6d14926d9122716bfad23"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a6efdce5e6dc6d14926d9122716bfad23">fd</a></td></tr>
<tr class="memdesc:a6efdce5e6dc6d14926d9122716bfad23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <b>this</b> is controlling SSA construction. <br /></td></tr>
<tr class="separator:a6efdce5e6dc6d14926d9122716bfad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cea641592e45d73795e4a2fad2a30e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42cea641592e45d73795e4a2fad2a30e"></a>
<a class="el" href="classLocationMap.html">LocationMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a42cea641592e45d73795e4a2fad2a30e">globaldisjoint</a></td></tr>
<tr class="memdesc:a42cea641592e45d73795e4a2fad2a30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint cover of every heritaged memory location. <br /></td></tr>
<tr class="separator:a42cea641592e45d73795e4a2fad2a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7f2cb625e9b3cd8babfc40e3f100cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c7f2cb625e9b3cd8babfc40e3f100cf"></a>
<a class="el" href="classLocationMap.html">LocationMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a4c7f2cb625e9b3cd8babfc40e3f100cf">disjoint</a></td></tr>
<tr class="memdesc:a4c7f2cb625e9b3cd8babfc40e3f100cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint cover of memory locations currently being heritaged. <br /></td></tr>
<tr class="separator:a4c7f2cb625e9b3cd8babfc40e3f100cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686351676373a38f353472dcb5e91b6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a686351676373a38f353472dcb5e91b6b"></a>
vector&lt; vector&lt; <a class="el" href="classFlowBlock.html">FlowBlock</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a686351676373a38f353472dcb5e91b6b">domchild</a></td></tr>
<tr class="memdesc:a686351676373a38f353472dcb5e91b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent-&gt;child edges in dominator tree. <br /></td></tr>
<tr class="separator:a686351676373a38f353472dcb5e91b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d59cf79a6320bbf710ecf0c1a5dd4d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d59cf79a6320bbf710ecf0c1a5dd4d2"></a>
vector&lt; vector&lt; <a class="el" href="classFlowBlock.html">FlowBlock</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a9d59cf79a6320bbf710ecf0c1a5dd4d2">augment</a></td></tr>
<tr class="memdesc:a9d59cf79a6320bbf710ecf0c1a5dd4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augmented edges. <br /></td></tr>
<tr class="separator:a9d59cf79a6320bbf710ecf0c1a5dd4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5fd1df887850a5b2fe0d84af73c8a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c5fd1df887850a5b2fe0d84af73c8a3"></a>
vector&lt; uint4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a4c5fd1df887850a5b2fe0d84af73c8a3">flags</a></td></tr>
<tr class="memdesc:a4c5fd1df887850a5b2fe0d84af73c8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block properties for phi-node placement algorithm. <br /></td></tr>
<tr class="separator:a4c5fd1df887850a5b2fe0d84af73c8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334f1c2b3a105a9a99b466ec4ba9d9a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334f1c2b3a105a9a99b466ec4ba9d9a6"></a>
vector&lt; int4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a334f1c2b3a105a9a99b466ec4ba9d9a6">depth</a></td></tr>
<tr class="memdesc:a334f1c2b3a105a9a99b466ec4ba9d9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dominator depth of individual blocks. <br /></td></tr>
<tr class="separator:a334f1c2b3a105a9a99b466ec4ba9d9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f19c06aa55c25dff6e758ac329d8f41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f19c06aa55c25dff6e758ac329d8f41"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a1f19c06aa55c25dff6e758ac329d8f41">maxdepth</a></td></tr>
<tr class="memdesc:a1f19c06aa55c25dff6e758ac329d8f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum depth of the dominator tree. <br /></td></tr>
<tr class="separator:a1f19c06aa55c25dff6e758ac329d8f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad307b292f0f0a70345e697717f675798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad307b292f0f0a70345e697717f675798"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#ad307b292f0f0a70345e697717f675798">pass</a></td></tr>
<tr class="memdesc:ad307b292f0f0a70345e697717f675798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current pass being executed. <br /></td></tr>
<tr class="separator:ad307b292f0f0a70345e697717f675798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc0e7c507b33eb1f9eba37d9e23d210"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc0e7c507b33eb1f9eba37d9e23d210"></a>
<a class="el" href="classPriorityQueue.html">PriorityQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a8dc0e7c507b33eb1f9eba37d9e23d210">pq</a></td></tr>
<tr class="memdesc:a8dc0e7c507b33eb1f9eba37d9e23d210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority queue for phi-node placement. <br /></td></tr>
<tr class="separator:a8dc0e7c507b33eb1f9eba37d9e23d210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9e0785364ee9733c3cadc651aba3d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd9e0785364ee9733c3cadc651aba3d3"></a>
vector&lt; <a class="el" href="classFlowBlock.html">FlowBlock</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#acd9e0785364ee9733c3cadc651aba3d3">merge</a></td></tr>
<tr class="memdesc:acd9e0785364ee9733c3cadc651aba3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate merge points (blocks containing phi-nodes) <br /></td></tr>
<tr class="separator:acd9e0785364ee9733c3cadc651aba3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007d0fca86e6f5ec989ffef1338e5a99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a007d0fca86e6f5ec989ffef1338e5a99"></a>
vector&lt; <a class="el" href="classHeritageInfo.html">HeritageInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a007d0fca86e6f5ec989ffef1338e5a99">infolist</a></td></tr>
<tr class="memdesc:a007d0fca86e6f5ec989ffef1338e5a99"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classHeritage.html" title="Manage the construction of Static Single Assignment (SSA) form. ">Heritage</a> status for individual address spaces. <br /></td></tr>
<tr class="separator:a007d0fca86e6f5ec989ffef1338e5a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ac199f4b6ad6d3c836b4343a3bd34b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4ac199f4b6ad6d3c836b4343a3bd34b"></a>
list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#aa4ac199f4b6ad6d3c836b4343a3bd34b">loadGuard</a></td></tr>
<tr class="memdesc:aa4ac199f4b6ad6d3c836b4343a3bd34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of LOAD operations that need to be guarded. <br /></td></tr>
<tr class="separator:aa4ac199f4b6ad6d3c836b4343a3bd34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667fe33a5e03235812b0b605d7d1343e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a667fe33a5e03235812b0b605d7d1343e"></a>
list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a667fe33a5e03235812b0b605d7d1343e">storeGuard</a></td></tr>
<tr class="memdesc:a667fe33a5e03235812b0b605d7d1343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of STORE operations taking an indexed pointer to the stack. <br /></td></tr>
<tr class="separator:a667fe33a5e03235812b0b605d7d1343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d480fa84932df7d15a0a8ff5bc5e87d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d480fa84932df7d15a0a8ff5bc5e87d"></a>
vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeritage.html#a2d480fa84932df7d15a0a8ff5bc5e87d">loadCopyOps</a></td></tr>
<tr class="memdesc:a2d480fa84932df7d15a0a8ff5bc5e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of COPY ops generated by load guards. <br /></td></tr>
<tr class="separator:a2d480fa84932df7d15a0a8ff5bc5e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manage the construction of Static Single Assignment (SSA) form. </p>
<p>With a specific function (<a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a>), this class links the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects into the formal data-flow graph structure, SSA form. The full structure can be built over multiple passes. In particular, this allows register data-flow to be analyzed first, and then stack locations can be discovered and promoted to first-class Varnodes in a second pass.</p>
<p>Varnodes for which it is not known whether they are written to by a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> are referred to as <b>free</b>. The method <a class="el" href="classHeritage.html#ad710084ce475a863e5d5d800300e3fd8" title="Perform one pass of heritage. ">heritage()</a> performs a <em>single</em> <em>pass</em> of constructing SSA form, collecting any <em>eligible</em> free Varnodes for the pass and linking them in to the data-flow. A <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is considered eligible for a given pass generally based on its address space (see <a class="el" href="classHeritageInfo.html" title="Information about heritage passes performed for a specific address space. ">HeritageInfo</a>), which is the main method for delaying linking for stack locations until they are all discovered. In principle a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be discovered very late and still get linked in on a subsequent pass. Linking causes Varnodes to gain new descendant PcodeOps, which has impact on dead code elimination (see <a class="el" href="classLocationMap.html" title="Map object for keeping track of which address ranges have been heritaged. ">LocationMap</a>).</p>
<p>The two big aspects of SSA construction are phi-node placement, performed by <a class="el" href="classHeritage.html#acf14995e58b23df915ad06e9ff7f1165" title="Perform phi-node placement for the current set of address ranges. ">placeMultiequals()</a>, and the <em>renaming</em> algorithm, performed by <a class="el" href="classHeritage.html#a68d25aa348dd9e8c5f13d708b2310772" title="Perform the renaming algorithm for the current set of address ranges. ">rename()</a>. The various guard* methods are concerned with labeling analyzing data-flow across function calls, STORE, and LOAD operations.</p>
<p>The phi-node placement algorithm is from (preprint?) "The Static Single Assignment Form and its Computation" by Gianfranco Bilardi and Keshav Pingali, July 22, 1999</p>
<p>The renaming algorithm taken from "Efficiently computing static single assignment form and the
 control dependence graph." R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck ACM Transactions on Programming Languages and Systems, 13(4):451-490, October 1991 </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8f4969857c70b95f52ff187801784e39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classHeritage.html#a8f4969857c70b95f52ff187801784e39">Heritage::heritage_flags</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extra boolean properties on basic blocks for the Augmented Dominator Tree. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8f4969857c70b95f52ff187801784e39a139d8056b56fe06ee44712a26d0261b5"></a>boundary_node&#160;</td><td class="fielddoc">
<p>Augmented Dominator Tree boundary node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4969857c70b95f52ff187801784e39ac87fb7719d1f75c85379a9fc39ab5ec0"></a>mark_node&#160;</td><td class="fielddoc">
<p>Node has already been in queue. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4969857c70b95f52ff187801784e39afb347c510a9f922416d835f8d292892b"></a>merged_node&#160;</td><td class="fielddoc">
<p>Node has already been merged. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9241f6a476085c88c540e34a44c5f197"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Heritage::Heritage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Instantiate the heritage manager for a particular function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7d518d053e1834e600be703ba0ac91b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::analyzeNewLoadGuards </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make final determination of what range new LoadGuards are protecting. </p>
<p>Actual LOAD operations are guarded with an initial version of the <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> record. Now that heritage has completed, a full analysis of each LOAD is conducted, using value set analysis, to reach a conclusion about what range of stack values the LOAD might actually alias. All new <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> records are updated with the analysis, which then informs handling of LOAD COPYs and possible later heritage passes. </p>

<p>References <a class="el" href="classLoadGuard.html#ae6a1b2e627bbe10d8977f4944486634e">LoadGuard::analysisState</a>, <a class="el" href="classLoadGuard.html#af5f21fe404934e7ea77c39450875ae65">LoadGuard::establishRange()</a>, <a class="el" href="classValueSetSolver.html#a43a4cb32e3aef1c1cb92cd5b8d6dd300">ValueSetSolver::establishValueSets()</a>, <a class="el" href="classLoadGuard.html#a6a34f49c8dca6df740f4a31b8d4d6fcc">LoadGuard::finalizeRange()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classValueSetSolver.html#ab52959c6069ee9e6cde934dd207d1e2f">ValueSetSolver::getValueSetRead()</a>, <a class="el" href="classAddrSpace.html#aae785e311543d4e95c7d344b0c93823c">AddrSpace::numSpacebase()</a>, <a class="el" href="classLoadGuard.html#a209e755a1fe8712c9b6e87d7a94862a5">LoadGuard::op</a>, and <a class="el" href="classValueSetSolver.html#a8dec4550f9502575b92ca93bf997185c">ValueSetSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a5315c2907b7c90bc1bdd5d97f656dcb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::buildADT </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the augmented dominator tree. </p>
<p>Assume the dominator tree is already built. Assume nodes are in dfs order. </p>

<p>References <a class="el" href="classFlowBlock.html#af89021d9b4861fa2b1c6b8de466a2231">FlowBlock::getImmedDom()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classBlockGraph.html#aeb99315362f322e25d56e01ed8ac35e0">BlockGraph::getSize()</a>, and <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cca3fa6fe1e5d6241ca3e0f0a29af42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::buildInfoList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize information for each space. </p>
<p>This is called once to initialize <b>this</b> class in preparation for doing the heritage passes. An information structure is allocated and mapped to each address space. </p>

<p>References <a class="el" href="classAddrSpace.html#a844c74531e892138675449ccbd5cbf76">AddrSpace::getDeadcodeDelay()</a>, <a class="el" href="classAddrSpace.html#a3497d662ef4ed44dc1b936f2a07c30cd">AddrSpace::getDelay()</a>, <a class="el" href="classAddrSpaceManager.html#a8c4ce4f25454e86a0383852fe42b3b7a">AddrSpaceManager::getSpace()</a>, <a class="el" href="classAddrSpace.html#a9c88339e07b5da212fee17205ddf20d1">AddrSpace::isHeritaged()</a>, and <a class="el" href="classAddrSpaceManager.html#abb27d4583ae1bfb9e2a16139bae922d3">AddrSpaceManager::numSpaces()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">Funcdata::startProcessing()</a>.</p>

</div>
</div>
<a class="anchor" id="a92cf595314cc2440d589a2728e3bfef3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::buildRefinement </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vnlist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a refinement array given an address range and a list of Varnodes. </p>
<p>The array is a preallocated array of ints, one for each byte in the address range. Each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the given list has a 1 entered in the refinement array, at the position corresponding to the starting address of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and at the position corresponding to the address immediately following the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refine</td><td>is the refinement array </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">vnlist</td><td>is the list of Varnodes to add to the array </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a051cc571403fc9d4277be2e985e76721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::bumpDeadcodeDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the heritage delay for the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and request a restart. </p>
<p>If applicable, look up the heritage stats for the address space for the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and increment the delay. The address space must allow an additional delay and can only be incremented once. If the increment succeeds, the function is marked as having a <em>restart</em> pending. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a844c74531e892138675449ccbd5cbf76">AddrSpace::getDeadcodeDelay()</a>, <a class="el" href="classAddrSpace.html#a3497d662ef4ed44dc1b936f2a07c30cd">AddrSpace::getDelay()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ac6a759a590195b56c099150c63cdd7b2">IPTR_PROCESSOR</a>, and <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>.</p>

</div>
</div>
<a class="anchor" id="a6f0e99606cab431e67415baba11d627f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::calcMultiequals </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate blocks that should contain MULTIEQUALs for one address range. </p>
<p>This is the main entry point for the phi-node placement algorithm. It is provided the normalized list of written Varnodes in this range. All refinement and guarding must already be performed for the Varnodes, and the dominance tree and its augmentation must already be computed. After this executes, the <b>merge</b> array holds blocks that should contain a MULTIEQUAL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">write</td><td>is the list of written Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="aa77f98c62d1bfd1062314c6c2a5035bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Heritage::callOpIndirectEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the address range is affected by the given call p-code op. </p>
<p>We assume the op is CALL, CALLIND, CALLOTHER, or NEW and that its output overlaps the given address range. We look up any effect the op might have on the address range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">op</td><td>is the given <em>call</em> p-code op </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b>, unless the range is unaffected by the op </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a500b63ecb17a75652c705bfab98bc8e5">CPUI_CALLIND</a>, <a class="el" href="classFuncCallSpecs.html#a2f782d0e91a83336fa722483c79d42aa">FuncCallSpecs::hasEffectTranslate()</a>, and <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea3488da6d6b149499cbe384f7b57d0564">EffectRecord::unaffected</a>.</p>

</div>
</div>
<a class="anchor" id="a7cdea4058aa42f91bbdb5a9b3171950f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all analysis of heritage. </p>
<p>Reset all analysis as if no heritage passes have yet taken place for the function. This does not directly affect Varnodes and PcodeOps in the underlying <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a>. </p>

<p>Referenced by <a class="el" href="classFuncdata.html#a25b616d10d9514eda69dd9d974c62eb8">Funcdata::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="a09a2ec772f8cf4a7304848698588978d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Heritage::collect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddress.html">Address</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect free reads, writes, and inputs in the given address range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">read</td><td>will hold any read Varnodes in the range </td></tr>
    <tr><td class="paramname">write</td><td>will hold any written Varnodes </td></tr>
    <tr><td class="paramname">input</td><td>will hold any input Varnodes </td></tr>
    <tr><td class="paramname">remove</td><td>will hold any PcodeOps that need to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum size of a write </dd></dl>

<p>References <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classAddrSpace.html#a592b7cfae93217aac10c62dd63b30941">AddrSpace::getHighest()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a5c45dac8cef168f501199944a367a28a">Varnode::isHeritageKnown()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>, <a class="el" href="classVarnode.html#a2692842139f3b1c22b2dc924a08615d7">Varnode::isWriteMask()</a>, and <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>.</p>

</div>
</div>
<a class="anchor" id="a9246dd5d8a7bbc7503ae1feff5342c93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Heritage::concatPieces </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vnlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>insertop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>finalvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate a list of Varnodes together at the given location. </p>
<p>There must be at least 2 Varnodes in list, they must be in order from most to least significant. The Varnodes in the list become inputs to a single expression of PIECE ops resulting in a final specified <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vnlist</td><td>is the list of Varnodes to concatenate </td></tr>
    <tr><td class="paramname">insertop</td><td>is the point where the expression should be inserted (before) </td></tr>
    <tr><td class="paramname">finalvn</td><td>is the final specified output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final unified <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#ae4dbd2e0b83e5fadebf7186e904921ca">PcodeOp::getBasicIter()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, and <a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">Address::isBigEndian()</a>.</p>

</div>
</div>
<a class="anchor" id="a323a0931e4aec896e41751c4569f22f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Heritage::deadRemovalAllowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <b>true</b> if it is <em>safe</em> to remove dead code. </p>
<p>Check if the required number of passes have transpired to allow removal of dead Varnodes in the given address space. If allowed, presumably no new Varnodes will be generated for the space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if dead code removal is allowed </dd></dl>

<p>References <a class="el" href="classHeritageInfo.html#ae46bc1a0815eeeb4afb51190c997ba34">HeritageInfo::deadcodedelay</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a3ab8607ddd18885dfa6732df8d4057e9">Funcdata::deadRemovalAllowed()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bbf92b2085d45de9f3920824a51786c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Heritage::deadRemovalAllowedSeen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if dead code removal is safe and mark that removal has happened. </p>
<p>A convenience function combining <a class="el" href="classHeritage.html#a323a0931e4aec896e41751c4569f22f4" title="Return true if it is safe to remove dead code. ">deadRemovalAllowed()</a> and <a class="el" href="classHeritage.html#abbcd7a583bd605db1177b9c2e0be599f" title="Inform system of dead code removal in given space. ">seenDeadCode()</a>. Return <b>true</b> if it is <em>safe</em> to remove dead code, and, if so, also inform the system that dead code has happened for the given space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if dead code removal is allowed </dd></dl>

<p>References <a class="el" href="classHeritageInfo.html#ae46bc1a0815eeeb4afb51190c997ba34">HeritageInfo::deadcodedelay</a>, and <a class="el" href="classHeritageInfo.html#a506a80bb3d61a5a8ed5d6e632aa77f18">HeritageInfo::deadremoved</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adba7696040378f0eaa679e684b72bf96">Funcdata::deadRemovalAllowedSeen()</a>.</p>

</div>
</div>
<a class="anchor" id="af292a2c38cdf9b300d433be7abacbee4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Heritage::discoverIndexedStackPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>freeStores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkFreeStores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trace input stack-pointer to any indexed loads. </p>
<p>Look for expressions of the form val = *(SP(i) + vn + #c), where the base stack pointer has an (optional) constant added to it and a non-constant index, then a value is loaded from the resulting address. The LOAD operations are added to the list of ops that potentially need to be guarded during a heritage pass. The routine can checks for STOREs where the data-flow path hasn't been completed yet and returns <b>true</b> if they exist, passing back a list of those that might use a pointer to the stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the particular address space with a stackpointer (into it) </td></tr>
    <tr><td class="paramname">freeStores</td><td>will hold the list of any STOREs that need follow-up analysis </td></tr>
    <tr><td class="paramname">checkFreeStores</td><td>is <b>true</b> if the routine should check for free STOREs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there are incomplete STOREs </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a14ab8d826af51873faa33b33e2bbc5fb">CPUI_STORE</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a3b16390dfa556c9bdd6fe5b31448f7d7">AddrSpace::getSpacebase()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="structHeritage_1_1StackNode.html#aa2fc728a686b383521c2d53612f01025">Heritage::StackNode::iter</a>, <a class="el" href="classAddrSpace.html#aae785e311543d4e95c7d344b0c93823c">AddrSpace::numSpacebase()</a>, <a class="el" href="classVarnode.html#a98825616d50a27a615057e625a61285e">Varnode::setMark()</a>, <a class="el" href="structHeritage_1_1StackNode.html#a48eda777b416490ab175d69b74d328d7">Heritage::StackNode::vn</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a9be0e3e2d24e0f434ea9ef54305f5afb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::findAddressForces </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copySinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last PcodeOps that write to specific addresses that flow to specific sites. </p>
<p>Given a set of sites for which data-flow needs to be preserved at a specific address, find the <em>last</em> ops that write to the address such that data flows to the site only through <em>artificial</em> COPYs and MULTIEQUALs. A COPY/MULTIEQUAL is artificial if all of its input and output Varnodes have the same storage address. The specific sites are presented as artificial COPY ops. The final set of ops that are not artificial will all have an output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that matches the specific address of a COPY sink and will need to be marked address forcing. The original set of COPY sinks will be extended to all artificial COPY/MULTIEQUALs encountered. Every <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> encountered will have its mark set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copySinks</td><td>is the list of sinks that we are trying to find flow to </td></tr>
    <tr><td class="paramname">forces</td><td>is the final list of address forcing PcodeOps </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#a254f805a8eceaabd170b3e4c24b08987">Varnode::isAddrForce()</a>, <a class="el" href="classPcodeOp.html#a7a604238b180a059aebdfb4e43f871ff">PcodeOp::isIndirectStore()</a>, <a class="el" href="classPcodeOp.html#af03aefce85152f7f638a5d87ceccc495">PcodeOp::isMark()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, and <a class="el" href="classPcodeOp.html#ab2ba9f66448cd77b6f274de6fae433e2">PcodeOp::setMark()</a>.</p>

</div>
</div>
<a class="anchor" id="a4eee152b9eed9584ff2a5e7512c863ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::floatExtensionRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td>
          <td class="paramname"><em>joinrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create float truncation into a free lower precision <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with logically lower precision, as given by a float extension record (<a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>), create the real full-precision <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and define the lower precision <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as a truncation (FLOAT2FLOAT) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the lower precision <em>join-space</em> input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">joinrec</td><td>is the float extension record </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aab409a4f8049204cbe5be65787497842">CPUI_FLOAT_FLOAT2FLOAT</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classJoinRecord.html#af371494cd9c83437c4096cfc6e10b759">JoinRecord::getPiece()</a>, and <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>.</p>

</div>
</div>
<a class="anchor" id="a91ac655570588881959ee7aaeccc2188"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::floatExtensionWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td>
          <td class="paramname"><em>joinrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create float extension from a lower precision <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with logically lower precision, as given by a float extension record (<a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>), create the full precision <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> specified by the record, making it defined by an extension (FLOAT2FLOAT). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the lower precision <em>join-space</em> output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">joinrec</td><td>is the float extension record </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aab409a4f8049204cbe5be65787497842">CPUI_FLOAT_FLOAT2FLOAT</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classJoinRecord.html#af371494cd9c83437c4096cfc6e10b759">JoinRecord::getPiece()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, and <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a715b618cb9ee8b808ac256a6b55495f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::generateLoadGuard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeritage_1_1StackNode.html">StackNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a guard record given an indexed LOAD into a stack space. </p>
<p>Record the LOAD op and the (likely) range of addresses in the stack space that might be loaded from. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>is the path element containing the constructed <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">op</td><td>is the LOAD <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">spc</td><td>is the stack space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structHeritage_1_1StackNode.html#a4dd93980ccd009b6dc6cd82fd5af5530">Heritage::StackNode::offset</a>, and <a class="el" href="classPcodeOp.html#a36d71b7742a88aab62637a1cea9310f4">PcodeOp::usesSpacebasePtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ebebdbb80a796aab5ddab6dc6bb942d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::generateStoreGuard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structHeritage_1_1StackNode.html">StackNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a guard record given an indexed STORE to a stack space. </p>
<p>Record the STORE op and the (likely) range of addresses in the stack space that might be stored to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>is the path element containing the constructed <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">op</td><td>is the STORE <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">spc</td><td>is the stack space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structHeritage_1_1StackNode.html#a4dd93980ccd009b6dc6cd82fd5af5530">Heritage::StackNode::offset</a>, and <a class="el" href="classPcodeOp.html#a36d71b7742a88aab62637a1cea9310f4">PcodeOp::usesSpacebasePtr()</a>.</p>

</div>
</div>
<a class="anchor" id="aac2a23ac011d09fad5c4e388e706d47b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Heritage::getDeadCodeDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pass delay for heritaging the given space. </p>
<p>Linking in Varnodes can be delayed for specific address spaces (to make sure all Varnodes for the space have been generated. Return the number of <em>passes</em> to delay for the given space. 0 means no delay. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of passes heritage is delayed </dd></dl>

<p>References <a class="el" href="classHeritageInfo.html#ae46bc1a0815eeeb4afb51190c997ba34">HeritageInfo::deadcodedelay</a>.</p>

</div>
</div>
<a class="anchor" id="a7e83d0857be5f4e3691dd095da2089a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLoadGuard.html">LoadGuard</a> * Heritage::getStoreGuard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> record associated with given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> or NULL </dd></dl>

<p>Referenced by <a class="el" href="classFuncdata.html#a215ce81074cb2bebd8218243b7156e71">Funcdata::getStoreGuard()</a>.</p>

</div>
</div>
<a class="anchor" id="af6f5419ca04e8266634478db0059a10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize p-code ops so that phi-node placement and renaming works. </p>
<p>The traditional phi-node placement and renaming algorithms don't expect variable pairs where there is partial overlap. For the given address range, we make all the free <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> sizes look uniform by adding PIECE and SUBPIECE ops. We also add INDIRECT ops, so that we can ignore indirect effects of LOAD/STORE/CALL ops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">read</td><td>is the set of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> values reading from the range </td></tr>
    <tr><td class="paramname">write</td><td>is the set of written Varnodes in the range </td></tr>
    <tr><td class="paramname">inputvars</td><td>is the set of Varnodes in the range already marked as input </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a254f805a8eceaabd170b3e4c24b08987">Varnode::isAddrForce()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, and <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="af7e83865af3d5e10a05513db464902b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guardCallOverlappingInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>transAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard an address range that is larger than any single parameter. </p>
<p>In this situation, an address range is being heritaged, but only a piece of it can be a parameter for a given call. We have to construct a SUBPIECE that pulls out the potential parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fc</td><td>is the call site potentially taking a parameter </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">transAddr</td><td>is the start of the same range from the callee's stack perspective </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the range in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classFuncCallSpecs.html#a32432a6c7b201dc160ae0b2480a1b8b9">FuncCallSpecs::getActiveInput()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncProto.html#a1b0977d7bbeb3feb291f9bba86e127e3">FuncProto::getBiggestContainedInputParam()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classFuncCallSpecs.html#a82b3a2d5f5b918348806e20d18cd0529">FuncCallSpecs::getOp()</a>, <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, and <a class="el" href="classParamActive.html#a96ddb19f584727f4ef9b956fb0b8026d">ParamActive::whichTrial()</a>.</p>

</div>
</div>
<a class="anchor" id="a8eee271623cb06fb85aa3d99fda9f653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guardCalls </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard CALL/CALLIND ops in preparation for renaming algorithm. </p>
<p>For the given address range, we decide what the data-flow effect is across each call site in the function. If an effect is unknown, an INDIRECT op is added, prepopulating data-flow through the call. Any new INDIRECT causes a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to be added to the <b>write</b> list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>are any boolean properties associated with the address range </td></tr>
    <tr><td class="paramname">addr</td><td>is the first address of given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">write</td><td>is the list of written Varnodes in the range (may be updated) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#ad3c3231b5c523e491d65f31ddb688cc1">FuncCallSpecs::abortSpacebaseRelative()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classFuncProto.html#aea7f34957c913ca07bae0c9547c7ecf9">FuncProto::characterizeAsInputParam()</a>, <a class="el" href="classFuncCallSpecs.html#a32432a6c7b201dc160ae0b2480a1b8b9">FuncCallSpecs::getActiveInput()</a>, <a class="el" href="classFuncCallSpecs.html#a866e9a9406614829224612035f28d311">FuncCallSpecs::getActiveOutput()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classFuncCallSpecs.html#a82b3a2d5f5b918348806e20d18cd0529">FuncCallSpecs::getOp()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classFuncCallSpecs.html#aacb8dcbd6e0efb15a933cc9ded517f28">FuncCallSpecs::getSpacebaseOffset()</a>, <a class="el" href="classFuncCallSpecs.html#a529e03f3574558d54ccb08a8262d37a7">FuncCallSpecs::getStackPlaceholderSlot()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classFuncCallSpecs.html#a2f782d0e91a83336fa722483c79d42aa">FuncCallSpecs::hasEffectTranslate()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classPcodeOp.html#abc2ed5aba256816975fd9fcee6e90dab">PcodeOp::isAssignment()</a>, <a class="el" href="classFuncCallSpecs.html#a535463c18ea83b3ede30b02c701d0b09">FuncCallSpecs::isInputActive()</a>, <a class="el" href="classFuncCallSpecs.html#a3c8ce3364e76b8350b02a663dc2282fc">FuncCallSpecs::isOutputActive()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeaacd8991c4ebdeb4057e15faf1d08abc2">EffectRecord::killedbycall</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncCallSpecs.html#abbbb64f2e2d7f1af62d3226e110079c3a584ec7401809588c22798803bff5b796">FuncCallSpecs::offset_unknown</a>, <a class="el" href="classFuncProto.html#a0d78264270ac627f7fb50bf582510861">FuncProto::possibleOutputParam()</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeafa04c6c617a1044c79c7bc9b7d661be2">EffectRecord::return_address</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, <a class="el" href="classVarnode.html#a0117b1856bd2977cd1eed1dd8df2dcce">Varnode::setAddrForce()</a>, <a class="el" href="classVarnode.html#a5f5028eda92941ae7f12728c16e28243">Varnode::setReturnAddress()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea02697f294ad0f4b53317da792c577a10">EffectRecord::unknown_effect</a>, <a class="el" href="classParamActive.html#a96ddb19f584727f4ef9b956fb0b8026d">ParamActive::whichTrial()</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a2aa7b23fef6b20dfc2bb31f82a881d3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guardInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure existing inputs for the given range fill it entirely. </p>
<p>The method is provided any Varnodes that overlap the range and are already marked as input. If there are any holes in coverage, new input Varnodes are created to cover them. A final unified <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> covering the whole range is built out of the pieces. In any event, things are set up so the renaming algorithm sees only a single <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the first address in the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">input</td><td>are the pre-existing inputs, given in address order </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classLocationMap.html#a9d4bddedee005e780986d9752b93e4f0">LocationMap::end()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, and <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="afe8e7c97c95c182b4264214ade1646fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guardLoads </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard LOAD ops in preparation for the renaming algorithm. </p>
<p>The op must be in the loadGuard list, which means it may pull values from an indexed range on the stack. A COPY guard is placed for the given range on any LOAD op whose indexed range it intersects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is boolean properties associated with the address </td></tr>
    <tr><td class="paramname">addr</td><td>is the first address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">write</td><td>is the list of written Varnodes in the range (may be updated) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classLoadGuard.html#aac8abc6f4c37a6258da9a99279120fc6">LoadGuard::isValid()</a>, <a class="el" href="classLoadGuard.html#a5c80c1d6ce27cdcdb1102238eef20989">LoadGuard::maximumOffset</a>, <a class="el" href="classLoadGuard.html#a05a86fd59865a06da11d31fc39725046">LoadGuard::minimumOffset</a>, <a class="el" href="classLoadGuard.html#a209e755a1fe8712c9b6e87d7a94862a5">LoadGuard::op</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, <a class="el" href="classVarnode.html#a0117b1856bd2977cd1eed1dd8df2dcce">Varnode::setAddrForce()</a>, and <a class="el" href="classLoadGuard.html#a9765ce20df002a86c1955ae00ca75785">LoadGuard::spc</a>.</p>

</div>
</div>
<a class="anchor" id="abdb8ba496fc607af9fa49743345f4ae7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guardReturns </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard global data-flow at RETURN ops in preparation for renaming. </p>
<p>For the given global (persistent) address range, data-flow must persist up to (beyond) the end of the function. This method prepopulates data-flow for the range at all the RETURN ops, in order to enforce this. Either a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is added as input to the RETURN (for possible return values), or a COPY is inserted right before the RETURN with its output marked as <b>address</b> <b>forced</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>are any boolean properties associated with the address range </td></tr>
    <tr><td class="paramname">addr</td><td>is the first address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">write</td><td>is the list of written Varnodes in the range (unused) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7af2f97499d0b08f223110ad8f59353b44">CPUI_RETURN</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classPcodeOp.html#a4dea8b1b9e9b0d40ecd0cbf9954790f8">PcodeOp::getHaltType()</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, and <a class="el" href="classVarnode.html#a0117b1856bd2977cd1eed1dd8df2dcce">Varnode::setAddrForce()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4c1de2a4c6df7d4703112333e092303"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::guardStores </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guard STORE ops in preparation for the renaming algorithm. </p>
<p>Depending on the pointer, a STORE operation may affect data-flow across the given address range. This method adds an INDIRECT op, prepopulating data-flow across the STORE. Any new INDIRECT causes a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to be added to the <b>write</b> list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the first address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">write</td><td>is the list of written Varnodes in the range (may be updated) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a14ab8d826af51873faa33b33e2bbc5fb">CPUI_STORE</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classAddrSpace.html#a5971d35628c019b97c34a4b90001a5f8">AddrSpace::getContain()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classAddress.html#acd17db20230415cb1fe1ad33c34c11ff">Address::getSpaceFromConst()</a>, <a class="el" href="classPcodeOp.html#aea2c42b4c40152406f2542c51c0681bba804c49efe7baaf2c7f00cfefd6db0112">PcodeOp::indirect_store</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, and <a class="el" href="classPcodeOp.html#a36d71b7742a88aab62637a1cea9310f4">PcodeOp::usesSpacebasePtr()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c3b93fdab6eb48af508e81face11b17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::handleNewLoadCopies </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the boundary of artificial ops introduced by load guards. </p>
<p>Having just completed renaming, run through all new COPY sinks from load guards and mark boundary Varnodes (Varnodes whose data-flow along all paths traverses only COPY/INDIRECT/MULTIEQUAL ops and hits a load guard). This lets dead code removal run forward from the boundary while still preserving the address force on the load guard. </p>

<p>References <a class="el" href="classPcodeOp.html#aaf4ba146f90fc4550f8e5809617afae3">PcodeOp::clearMark()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classRangeList.html#a83ace846d1d6faedd894e5756e1f7cf8">RangeList::inRange()</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classLoadGuard.html#a5c80c1d6ce27cdcdb1102238eef20989">LoadGuard::maximumOffset</a>, <a class="el" href="classLoadGuard.html#a05a86fd59865a06da11d31fc39725046">LoadGuard::minimumOffset</a>, <a class="el" href="classVarnode.html#a0117b1856bd2977cd1eed1dd8df2dcce">Varnode::setAddrForce()</a>, and <a class="el" href="classLoadGuard.html#a9765ce20df002a86c1955ae00ca75785">LoadGuard::spc</a>.</p>

</div>
</div>
<a class="anchor" id="ad710084ce475a863e5d5d800300e3fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::heritage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one pass of heritage. </p>
<p>From any address space that is active for this pass, free Varnodes are collected and then fully integrated into SSA form. Reads are connected to writes, inputs are identified, and phi-nodes are placed. </p>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classHeritageInfo.html#a506a80bb3d61a5a8ed5d6e632aa77f18">HeritageInfo::deadremoved</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classHeritageInfo.html#a6d4c4f49ad825e3f484b1bb881f4008c">HeritageInfo::isHeritaged()</a>, <a class="el" href="classVarnode.html#a5c45dac8cef168f501199944a367a28a">Varnode::isHeritageKnown()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classVarnode.html#a43dce9fe4c264cec97e430c618d4afad">Varnode::isUnaffected()</a>, <a class="el" href="classVarnode.html#a2692842139f3b1c22b2dc924a08615d7">Varnode::isWriteMask()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classHeritageInfo.html#a187e242eca76fa0a9d2f727269092f35">HeritageInfo::loadGuardSearch</a>, <a class="el" href="classAddress.html#a040ac0edbb01bd26c8956130ec4ef20e">Address::printRaw()</a>, <a class="el" href="classVarnode.html#a2811174882a9120c04aac92f0f83a354">Varnode::printRawNoMarkup()</a>, <a class="el" href="classHeritageInfo.html#a43f692f828c8a6352a2b9b74bf27ed4c">HeritageInfo::space</a>, and <a class="el" href="classHeritageInfo.html#a6ea4686f874eb42a50b2e9e59341ad48">HeritageInfo::warningissued</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">Funcdata::opHeritage()</a>.</p>

</div>
</div>
<a class="anchor" id="a431e524dcdc8abbef3d6755023d5eee9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Heritage::heritagePass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pass number when the given address was heritaged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pass number or -1 if the address has not been heritaged </dd></dl>

<p>References <a class="el" href="classLocationMap.html#a8e49d707bfeb154a8e762752c46c2585">LocationMap::findPass()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a803cbb38fe59825f59858a16afa54b7d">Funcdata::isHeritaged()</a>.</p>

</div>
</div>
<a class="anchor" id="aaba48dbc84d89bd4fbd6db8f1053e015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Heritage::normalizeReadSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize the size of a read <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, prior to heritage. </p>
<p>Given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> being read that does not match the (larger) size of the address range currently being linked, create a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the correct size and define the original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as a SUBPIECE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given too small <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the start of the (larger) range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new larger <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classAddress.html#a45e9717c199593d3446eae0328499e43">Address::getAddrSize()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#a7fb3376269b6c8585afb3ecc877a7cab">Varnode::overlap()</a>, and <a class="el" href="classVarnode.html#ae5fb93c31c77ab156b9a9a88045e83db">Varnode::setWriteMask()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fbbe85327f1494e087268d6f64b95b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Heritage::normalizeWriteSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize the size of a written <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, prior to heritage. </p>
<p>Given a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that is written that does not match the (larger) size of the address range currently being linked, create the missing pieces in the range and concatenate everything into a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the correct size.</p>
<p>One or more <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces are created depending on how the original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> overlaps the given range. An expression is created using PIECE ops resulting in a final <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given too small <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the start of the (larger) range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created final <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classAddress.html#a45e9717c199593d3446eae0328499e43">Address::getAddrSize()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">Address::isBigEndian()</a>, <a class="el" href="classPcodeOp.html#a091539b02c09c885351f789b24afba7b">PcodeOp::isCall()</a>, <a class="el" href="classVarnode.html#a7fb3376269b6c8585afb3ecc877a7cab">Varnode::overlap()</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, and <a class="el" href="classVarnode.html#ae5fb93c31c77ab156b9a9a88045e83db">Varnode::setWriteMask()</a>.</p>

</div>
</div>
<a class="anchor" id="ac24cd8c63c9efbc8bb17cd17a3530d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Heritage::numHeritagePasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number times heritage was performed for the given address space. </p>
<p>A negative number indicates the number of passes to wait before the first heritage will occur. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of heritage passes performed </dd></dl>

<p>References <a class="el" href="classHeritageInfo.html#a95a6e8bb94b7d65ddf6199b4cfa13780">HeritageInfo::delay</a>, and <a class="el" href="classHeritageInfo.html#a6d4c4f49ad825e3f484b1bb881f4008c">HeritageInfo::isHeritaged()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a363bd02cb2f20cf1583951d5429a057b">Funcdata::numHeritagePasses()</a>.</p>

</div>
</div>
<a class="anchor" id="acf14995e58b23df915ad06e9ff7f1165"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::placeMultiequals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform phi-node placement for the current set of address ranges. </p>
<p>Main entry point for performing the phi-node placement algorithm. Assume <b>disjoint</b> is filled with all the free Varnodes to be heritaged </p>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a1eef2cfc279c246cc7ea0387d8c0aa66">IPTR_INTERNAL</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, and <a class="el" href="classFlowBlock.html#a8a068e9ce69fa88e809b582559d65384">FlowBlock::sizeIn()</a>.</p>

</div>
</div>
<a class="anchor" id="a0650d1067110e8e82aeafaffa4324fba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::processJoins </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <em>join-space</em> Varnodes up into their real components. </p>
<p>For any <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the <em>join-space</em>, look up its <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> and split it up into the specified real components so that join-space addresses play no role in the heritage process, i.e. there should be no free Varnodes in the <em>join-space</em>. </p>

<p>References <a class="el" href="classHeritageInfo.html#a95a6e8bb94b7d65ddf6199b4cfa13780">HeritageInfo::delay</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classJoinRecord.html#af371494cd9c83437c4096cfc6e10b759">JoinRecord::getPiece()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classJoinRecord.html#ac132c6494158b3f82e48eae6a161ea56">JoinRecord::getUnified()</a>, <a class="el" href="classJoinRecord.html#adae83ed2238cd8555b70a2f153776ee4">JoinRecord::isFloatExtension()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

</div>
</div>
<a class="anchor" id="acf53171a2207b2dad917b29c27fb538b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::propagateCopyAway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminate a COPY sink preserving its data-flow. </p>
<p>Given a COPY from a storage location to itself, propagate the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> version of the storage location to all the ops reading the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, so the output no longer has any descendants. Then eliminate the COPY. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given COPY sink </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, and <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>.</p>

</div>
</div>
<a class="anchor" id="ac10902f4c1f68ed29b9b9f6803f81b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Heritage::protectFreeStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>freeStores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify any CPUI_STORE ops that use a free pointer from a given address space. </p>
<p>When performing heritage for stack Varnodes, data-flow around a STORE with a free pointer must be guarded (with an INDIRECT) to be safe. This routine collects and marks the STORE ops that trigger this guard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">freeStores</td><td>will hold the list of STOREs if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there are any new STOREs needing a guard </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ab13948fae3194faced3994780ca08061">CPUI_INT_ADD</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a14ab8d826af51873faa33b33e2bbc5fb">CPUI_STORE</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, and <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>.</p>

</div>
</div>
<a class="anchor" id="a97c6927fa0bd3e1347d4abc9258b2ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::refineInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split up a known input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> based on the given refinement. </p>
<p>The <em>refinement</em> array is an array of integers, one for each byte in the given range. Any non-zero entry is the size of a particular element of the refinement starting at that corresponding byte in the range. I.e. the array [4,0,0,0,4,0,0,0] indicates the address range is 8-bytes long covered by two elements of length 4, starting at offsets 0 and 4 respectively.</p>
<p>If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> overlaps the refinement, it is replaced with 2 or more covering Varnodes with boundaries that are on the refinement. These pieces may be supplemented with additional pieces to obtain a disjoint cover of the entire address range. A defining SUBPIECE op is generated for each piece. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the address range being refined </td></tr>
    <tr><td class="paramname">refine</td><td>is the refinement array </td></tr>
    <tr><td class="paramname">newvn</td><td>is preallocated space for the holding the array of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, and <a class="el" href="classVarnode.html#ae5fb93c31c77ab156b9a9a88045e83db">Varnode::setWriteMask()</a>.</p>

</div>
</div>
<a class="anchor" id="a51e9ba0669069dd19eda511ab82be81a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Heritage::refinement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>readvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>writevars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputvars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the common refinement of all reads and writes in the address range. </p>
<p>Split the reads and writes so they match the refinement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the first address in the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">readvars</td><td>is all <em>free</em> Varnodes overlapping the address range </td></tr>
    <tr><td class="paramname">writevars</td><td>is all written Varnodes overlapping the address range </td></tr>
    <tr><td class="paramname">inputvars</td><td>is all known input Varnodes overlapping the address range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there is a non-trivial refinement </dd></dl>

</div>
</div>
<a class="anchor" id="acbc102fb06f08d2f8aa9f28c4a4e06be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::refineRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split up a <b>free</b> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> based on the given refinement. </p>
<p>The <em>refinement</em> array is an array of integers, one for each byte in the given range. Any non-zero entry is the size of a particular element of the refinement starting at that corresponding byte in the range. I.e. the array [4,0,0,0,4,0,0,0] indicates the address range is 8-bytes long covered by two elements of length 4, starting at offsets 0 and 4 respectively.</p>
<p>If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> overlaps the refinement, it is replaced with 2 or more covering Varnodes with boundaries that are on the refinement. A concatenation expression is formed reconstructing the original value from the pieces. The original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is replaced, in its p-code op, with a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that is the final output of the concatenation expression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the address range being refined </td></tr>
    <tr><td class="paramname">refine</td><td>is the refinement array </td></tr>
    <tr><td class="paramname">newvn</td><td>is preallocated space for the holding the array of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, and <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c6c3f775e4f08d3101cf2ca3a68e996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::refineWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split up an output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> based on the given refinement. </p>
<p>The <em>refinement</em> array is an array of integers, one for each byte in the given range. Any non-zero entry is the size of a particular element of the refinement starting at that corresponding byte in the range. I.e. the array [4,0,0,0,4,0,0,0] indicates the address range is 8-bytes long covered by two elements of length 4, starting at offsets 0 and 4 respectively.</p>
<p>If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> overlaps the refinement, it is replaced with 2 or more covering Varnodes with boundaries that are on the refinement. These pieces may be supplemented with additional pieces to obtain a disjoint cover of the entire address range. A defining SUBPIECE op is generated for each piece. The original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is replaced with a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the address range being refined </td></tr>
    <tr><td class="paramname">refine</td><td>is the refinement array </td></tr>
    <tr><td class="paramname">newvn</td><td>is preallocated space for the holding the array of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, and <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a22b94d5d447b2b9fa45dd98191ca9d18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::remove13Refinement </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we see 1-3 or 3-1 pieces in the partition, replace with a 4. </p>
<p>A refinement of a 4-byte range into a 1-byte and 3-byte cover is highly likely to be artificial, so we eliminate this configuration.</p>
<p>The <em>refinement</em> array is an array of integers, one for each byte in the given range. Any non-zero entry is the size of a particular element of the refinement starting at that corresponding byte in the range. I.e. the array [4,0,0,0,4,0,0,0] indicates the address range is 8-bytes long covered by two elements of length 4, starting at offsets 0 and 4 respectively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refine</td><td>is the refinement array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af722d75a0f8383480883c89adfbfee35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::removeRevisitedMarkers </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove deprecated CPUI_MULTIEQUAL or CPUI_INDIRECT ops, preparing to re-heritage. </p>
<p>If a previous <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was heritaged through a MULTIEQUAL or INDIRECT op, but now a larger range containing the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is being heritaged, we throw away the op, letting the data-flow for the new larger range determine the data-flow for the old <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is redefined as the output of a SUBPIECE of a larger free <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove</td><td>is the list of Varnodes written by MULTIEQUAL or INDIRECT </td></tr>
    <tr><td class="paramname">addr</td><td>is the start of the larger range </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#ae4dbd2e0b83e5fadebf7186e904921ca">PcodeOp::getBasicIter()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classVarnode.html#a7fb3376269b6c8585afb3ecc877a7cab">Varnode::overlap()</a>, <a class="el" href="classVarnode.html#a61ae30aaf78c612ba253611e0aad2dc1">Varnode::setActiveHeritage()</a>, and <a class="el" href="classVarnode.html#ae5fb93c31c77ab156b9a9a88045e83db">Varnode::setWriteMask()</a>.</p>

</div>
</div>
<a class="anchor" id="a68d25aa348dd9e8c5f13d708b2310772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::rename </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the renaming algorithm for the current set of address ranges. </p>
<p>Phi-node placement must already have happened. </p>

</div>
</div>
<a class="anchor" id="acdca2d8bbf0803bbe3c417161e113c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::renameRecurse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="heritage_8hh.html#a06c866be068de18f657eeea50b3790ba">VariableStack</a> &amp;&#160;</td>
          <td class="paramname"><em>varstack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The heart of the renaming algorithm. </p>
<p>From the given block, recursively walk the dominance tree. At each block, visit the PcodeOps in execution order looking for Varnodes that need to be renamed. As write Varnodes are encountered, a set of stack containers, differentiated by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>'s address, are updated so the so the current <em>active</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is always ready for any <em>free</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that is encountered. In this was all <em>free</em> Varnodes are replaced with the appropriate write <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or are promoted to a formal <em>input</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>is the current basic block in the dominance tree walk </td></tr>
    <tr><td class="paramname">varstack</td><td>is the system of stacks, organized by address </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classVarnode.html#acb345a601ccf9b3d13038d01b1963fa5">Varnode::clearActiveHeritage()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFlowBlock.html#ab95b430d4c8470c379dba93613c3073b">FlowBlock::getOut()</a>, <a class="el" href="classFlowBlock.html#a53eb84ad35f0bfd147cebe862bdce1ca">FlowBlock::getOutRevIndex()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca2b40cdc5083e1a49cd5195d46711e5f5">Varnode::insert</a>, <a class="el" href="classVarnode.html#a8da27a871281dd1aef436846be2ac944">Varnode::isActiveHeritage()</a>, <a class="el" href="classVarnode.html#a5c45dac8cef168f501199944a367a28a">Varnode::isHeritageKnown()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, and <a class="el" href="classFlowBlock.html#a270403199d68a394a209937d1449a3f9">FlowBlock::sizeOut()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c727cc9c420ab56b33a7b3d1342534"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::reprocessFreeStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>freeStores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Revisit STOREs with free pointers now that a heritage pass has completed. </p>
<p>We regenerate STORE <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> records then cross-reference with STOREs that were originally free to see if they actually needed a LoadGaurd. If not, the STORE is unmarked and INDIRECTs it has caused are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space being guarded </td></tr>
    <tr><td class="paramname">freeStores</td><td>is the list of STOREs that were marked as free </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ad644dc33b71c7d421fcd0fb2003407c7">IPTR_IOP</a>, <a class="el" href="classPcodeOp.html#adeb9d3faf14ef41ad35915f149cc8830">PcodeOp::previousOp()</a>, and <a class="el" href="classPcodeOp.html#a36d71b7742a88aab62637a1cea9310f4">PcodeOp::usesSpacebasePtr()</a>.</p>

</div>
</div>
<a class="anchor" id="abbcd7a583bd605db1177b9c2e0be599f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::seenDeadCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inform system of dead code removal in given space. </p>
<p>Record that Varnodes have been removed from the given space so that we can tell if there is any new heritage <em>after</em> the dead code removal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classHeritageInfo.html#a506a80bb3d61a5a8ed5d6e632aa77f18">HeritageInfo::deadremoved</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#adc0c8b4dab63367913749e68fbd33789">Funcdata::seenDeadcode()</a>.</p>

</div>
</div>
<a class="anchor" id="a8377c55d2b77f230779ad43e341e6a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::setDeadCodeDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set delay for a specific space. </p>
<p>Set the number of heritage passes that are skipped before allowing dead code removal for Varnodes in the given address space (to make sure all Varnodes have been linked in before deciding what is dead). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">delay</td><td>is the number of passes to delay </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classHeritageInfo.html#ae46bc1a0815eeeb4afb51190c997ba34">HeritageInfo::deadcodedelay</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ac40aef88ca7a101e4697df5e0ec5f605">Funcdata::setDeadCodeDelay()</a>.</p>

</div>
</div>
<a class="anchor" id="ab25035a9cc1aeaadc38c1d9fc19ae9b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::splitByRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split up a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> by the given <em>refinement</em>. </p>
<p>The <em>refinement</em> array is an array of integers, one for each byte in the given range. Any non-zero entry is the size of a particular element of the refinement starting at that corresponding byte in the range. I.e. the array [4,0,0,0,4,0,0,0] indicates the address range is 8-bytes long covered by two elements of length 4, starting at offsets 0 and 4 respectively. The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> must be contained in the address range that the refinement array describes.</p>
<p>A new set of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces are returned in the <b>split</b> container, where the pieces form a disjoint cover of the original <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, and where the piece boundaries match the refinement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the range described by the refinement </td></tr>
    <tr><td class="paramname">refine</td><td>is the refinement array </td></tr>
    <tr><td class="paramname">split</td><td>will hold the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f48a8d050661256a4e76500f2aafc67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::splitJoinLevel </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>lastcombo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nextlev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td>
          <td class="paramname"><em>joinrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform one level of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> splitting to match a <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>. </p>
<p>Split all the pieces in <b>lastcombo</b>, putting them into <b>nextlev</b> in order, to get closer to the representation described by the given <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>. <b>nextlev</b> contains the two split pieces for each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in <b>lastcombo</b>. If a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not split this level, an extra <b>null</b> is put into <b>nextlev</b> to maintain the 2-1 mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastcombo</td><td>is the list of Varnodes to split </td></tr>
    <tr><td class="paramname">nextlev</td><td>will hold the new split Varnodes in a 2-1 ratio </td></tr>
    <tr><td class="paramname">joinrec</td><td>is the splitting specification we are trying to match </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classJoinRecord.html#af371494cd9c83437c4096cfc6e10b759">JoinRecord::getPiece()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classJoinRecord.html#a50960a501a7d9cee771e541f634ae725">JoinRecord::numPieces()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

</div>
</div>
<a class="anchor" id="a4209665a068f85407a721865b8cfbd14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::splitJoinRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td>
          <td class="paramname"><em>joinrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct pieces for a <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> read by an operation. </p>
<p>Given a splitting specification (<a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>) and a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, build a concatenation expression (out of PIECE operations) that constructs the the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> out of the specified <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">joinrec</td><td>is the splitting specification </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>, <a class="el" href="classJoinRecord.html#a50960a501a7d9cee771e541f634ae725">JoinRecord::numPieces()</a>, <a class="el" href="classVarnode.html#ad7569812931abb759cd4150aab347f7f">Varnode::setPrecisHi()</a>, and <a class="el" href="classVarnode.html#a62d871a96ac123caa3b851738cf49760">Varnode::setPrecisLo()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c978bf61697b1725ccc7e4159c39d4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::splitJoinWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td>
          <td class="paramname"><em>joinrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a written <em>join-space</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into specified pieces. </p>
<p>Given a splitting specification (<a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>) and a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, build a series of expressions that construct the specified <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> pieces using SUBPIECE ops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">joinrec</td><td>is the splitting specification </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classJoinRecord.html#a50960a501a7d9cee771e541f634ae725">JoinRecord::numPieces()</a>, <a class="el" href="classVarnode.html#ad7569812931abb759cd4150aab347f7f">Varnode::setPrecisHi()</a>, and <a class="el" href="classVarnode.html#a62d871a96ac123caa3b851738cf49760">Varnode::setPrecisLo()</a>.</p>

</div>
</div>
<a class="anchor" id="a40f30a5f936640e1aed8200a5fea0081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::splitPieces </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vnlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>insertop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>startvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a set of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> piece expression at the given location. </p>
<p>Given a list of small Varnodes and the address range they are a piece of, construct a SUBPIECE op that defines each piece. The truncation parameters are calculated based on the overlap of the piece with the whole range, and a single input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is used for all SUBPIECE ops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vnlist</td><td>is the list of piece Varnodes </td></tr>
    <tr><td class="paramname">insertop</td><td>is the point where the op expressions are inserted (before) </td></tr>
    <tr><td class="paramname">addr</td><td>is the first address of the whole range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the whole range </td></tr>
    <tr><td class="paramname">startvn</td><td>is designated input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classPcodeOp.html#ae4dbd2e0b83e5fadebf7186e904921ca">PcodeOp::getBasicIter()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, and <a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">Address::isBigEndian()</a>.</p>

</div>
</div>
<a class="anchor" id="a25aa595351a7c5877215f3a79cea33cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Heritage::visitIncr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFlowBlock.html">FlowBlock</a> *&#160;</td>
          <td class="paramname"><em>qnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowBlock.html">FlowBlock</a> *&#160;</td>
          <td class="paramname"><em>vnode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The heart of the phi-node placement algorithm. </p>
<p>Recursively walk the dominance tree starting from a given block. Calculate any children that are in the dominance frontier and add them to the <b>merge</b> array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qnode</td><td>is the parent of the given block </td></tr>
    <tr><td class="paramname">vnode</td><td>is the given block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFlowBlock.html#af89021d9b4861fa2b1c6b8de466a2231">FlowBlock::getImmedDom()</a>, and <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="heritage_8hh.html">heritage.hh</a></li>
<li>heritage.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
