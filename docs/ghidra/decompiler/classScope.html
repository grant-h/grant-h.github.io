<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: Scope Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classScope-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scope Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> objects within a single (namespace or functional) scope.  
 <a href="classScope.html#details">More...</a></p>

<p><code>#include &lt;database.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Scope:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classScope.png" usemap="#Scope_map" alt=""/>
  <map id="Scope_map" name="Scope_map">
<area href="classScopeGhidra.html" title="An implementation of the Scope interface by querying a Ghidra client for Symbol information. " alt="ScopeGhidra" shape="rect" coords="0,56,152,80"/>
<area href="classScopeInternal.html" title="An in-memory implementation of the Scope interface. " alt="ScopeInternal" shape="rect" coords="162,56,314,80"/>
<area href="classScopeGhidraNamespace.html" title="A global namespace Scope. " alt="ScopeGhidraNamespace" shape="rect" coords="81,112,233,136"/>
<area href="classScopeLocal.html" title="A Symbol scope for local variables of a particular function. " alt="ScopeLocal" shape="rect" coords="243,112,395,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5008924767949a4b9ef81481ad40d6ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5008924767949a4b9ef81481ad40d6ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a5008924767949a4b9ef81481ad40d6ce">Scope</a> (uint8 id, const string &amp;nm, <a class="el" href="classArchitecture.html">Architecture</a> *g, <a class="el" href="classScope.html">Scope</a> *own)</td></tr>
<tr class="memdesc:a5008924767949a4b9ef81481ad40d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty scope, given a name and <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a>. <br /></td></tr>
<tr class="separator:a5008924767949a4b9ef81481ad40d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571dad0bea947a7c5c1cfea083733963"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a571dad0bea947a7c5c1cfea083733963"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a571dad0bea947a7c5c1cfea083733963">~Scope</a> (void)</td></tr>
<tr class="memdesc:a571dad0bea947a7c5c1cfea083733963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a571dad0bea947a7c5c1cfea083733963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054e7b7c470035be94e1e4229ff188d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a054e7b7c470035be94e1e4229ff188d4"></a>
virtual <a class="el" href="classMapIterator.html">MapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a054e7b7c470035be94e1e4229ff188d4">begin</a> (void) const =0</td></tr>
<tr class="memdesc:a054e7b7c470035be94e1e4229ff188d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to mapped SymbolEntrys. <br /></td></tr>
<tr class="separator:a054e7b7c470035be94e1e4229ff188d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186b8c11ebef0f2d3838bfe1e46b6db6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a186b8c11ebef0f2d3838bfe1e46b6db6"></a>
virtual <a class="el" href="classMapIterator.html">MapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a186b8c11ebef0f2d3838bfe1e46b6db6">end</a> (void) const =0</td></tr>
<tr class="memdesc:a186b8c11ebef0f2d3838bfe1e46b6db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to mapped SymbolEntrys. <br /></td></tr>
<tr class="separator:a186b8c11ebef0f2d3838bfe1e46b6db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0f92c9d85a20b77b562e5a499b9e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab0f92c9d85a20b77b562e5a499b9e6d"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aab0f92c9d85a20b77b562e5a499b9e6d">beginDynamic</a> (void) const =0</td></tr>
<tr class="memdesc:aab0f92c9d85a20b77b562e5a499b9e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:aab0f92c9d85a20b77b562e5a499b9e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add98c4a0c13d3497f82d0a5c2353b578"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add98c4a0c13d3497f82d0a5c2353b578"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#add98c4a0c13d3497f82d0a5c2353b578">endDynamic</a> (void) const =0</td></tr>
<tr class="memdesc:add98c4a0c13d3497f82d0a5c2353b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:add98c4a0c13d3497f82d0a5c2353b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ad2607f2c7859b49b45100c2c0011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a883ad2607f2c7859b49b45100c2c0011"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a883ad2607f2c7859b49b45100c2c0011">beginDynamic</a> (void)=0</td></tr>
<tr class="memdesc:a883ad2607f2c7859b49b45100c2c0011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:a883ad2607f2c7859b49b45100c2c0011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c892157b9de825a3b475581fbf4019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c892157b9de825a3b475581fbf4019"></a>
virtual list&lt; <a class="el" href="classSymbolEntry.html">SymbolEntry</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a37c892157b9de825a3b475581fbf4019">endDynamic</a> (void)=0</td></tr>
<tr class="memdesc:a37c892157b9de825a3b475581fbf4019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator to dynamic SymbolEntrys. <br /></td></tr>
<tr class="separator:a37c892157b9de825a3b475581fbf4019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21">clear</a> (void)=0</td></tr>
<tr class="memdesc:a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all symbols from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a9bfa2b0a98ba3ceeafd5a1e7ad2e2c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8275b6500a9cc620cc31f32ed267e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c8275b6500a9cc620cc31f32ed267e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab3c8275b6500a9cc620cc31f32ed267e">clearCategory</a> (int4 cat)=0</td></tr>
<tr class="memdesc:ab3c8275b6500a9cc620cc31f32ed267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all symbols of the given category from <b>this</b> scope. <br /></td></tr>
<tr class="separator:ab3c8275b6500a9cc620cc31f32ed267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d58385a87dca33d128300c666e5064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7d58385a87dca33d128300c666e5064"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac7d58385a87dca33d128300c666e5064">clearUnlocked</a> (void)=0</td></tr>
<tr class="memdesc:ac7d58385a87dca33d128300c666e5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all unlocked symbols from <b>this</b> scope. <br /></td></tr>
<tr class="separator:ac7d58385a87dca33d128300c666e5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc66a463ca11a4c533991cea0639c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15fc66a463ca11a4c533991cea0639c8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a15fc66a463ca11a4c533991cea0639c8">clearUnlockedCategory</a> (int4 cat)=0</td></tr>
<tr class="memdesc:a15fc66a463ca11a4c533991cea0639c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear unlocked symbols of the given category from <b>this</b> scope. <br /></td></tr>
<tr class="separator:a15fc66a463ca11a4c533991cea0639c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6654289ce3a02ab373eb96e78818d3ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a6654289ce3a02ab373eb96e78818d3ca">adjustCaches</a> (void)=0</td></tr>
<tr class="memdesc:a6654289ce3a02ab373eb96e78818d3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let scopes internally adjust any caches.  <a href="#a6654289ce3a02ab373eb96e78818d3ca">More...</a><br /></td></tr>
<tr class="separator:a6654289ce3a02ab373eb96e78818d3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012d7b340b2b06e2f96a103da3654bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const </td></tr>
<tr class="memdesc:a2012d7b340b2b06e2f96a103da3654bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the given range is owned by <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a2012d7b340b2b06e2f96a103da3654bd">More...</a><br /></td></tr>
<tr class="separator:a2012d7b340b2b06e2f96a103da3654bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f86985c8d27f20e444d2d36385617a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4f86985c8d27f20e444d2d36385617a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad4f86985c8d27f20e444d2d36385617a">removeSymbolMappings</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)=0</td></tr>
<tr class="memdesc:ad4f86985c8d27f20e444d2d36385617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all SymbolEntrys from the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. <br /></td></tr>
<tr class="separator:ad4f86985c8d27f20e444d2d36385617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172591847f6a1b338ad324f28732f7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0172591847f6a1b338ad324f28732f7f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0172591847f6a1b338ad324f28732f7f">removeSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *symbol)=0</td></tr>
<tr class="memdesc:a0172591847f6a1b338ad324f28732f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> from <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. <br /></td></tr>
<tr class="separator:a0172591847f6a1b338ad324f28732f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab576de2e768be9507ee03faa163c1ddf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab576de2e768be9507ee03faa163c1ddf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab576de2e768be9507ee03faa163c1ddf">renameSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, const string &amp;newname)=0</td></tr>
<tr class="memdesc:ab576de2e768be9507ee03faa163c1ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. <br /></td></tr>
<tr class="separator:ab576de2e768be9507ee03faa163c1ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef6a133b07fa176c08b67c44064e69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#afeef6a133b07fa176c08b67c44064e69">retypeSymbol</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, <a class="el" href="classDatatype.html">Datatype</a> *ct)=0</td></tr>
<tr class="memdesc:afeef6a133b07fa176c08b67c44064e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#afeef6a133b07fa176c08b67c44064e69">More...</a><br /></td></tr>
<tr class="separator:afeef6a133b07fa176c08b67c44064e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49f329dcfe47129bf11acac543233e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a49f329dcfe47129bf11acac543233e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7a49f329dcfe47129bf11acac543233e">setAttribute</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)=0</td></tr>
<tr class="memdesc:a7a49f329dcfe47129bf11acac543233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties on a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. <br /></td></tr>
<tr class="separator:a7a49f329dcfe47129bf11acac543233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb57165fd0d3c182e18ea24e7231975d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb57165fd0d3c182e18ea24e7231975d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#afb57165fd0d3c182e18ea24e7231975d">clearAttribute</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)=0</td></tr>
<tr class="memdesc:afb57165fd0d3c182e18ea24e7231975d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties on a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. <br /></td></tr>
<tr class="separator:afb57165fd0d3c182e18ea24e7231975d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae799cc3171536b9ee10497631aea8c5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae799cc3171536b9ee10497631aea8c5b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ae799cc3171536b9ee10497631aea8c5b">setDisplayFormat</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 attr)=0</td></tr>
<tr class="memdesc:ae799cc3171536b9ee10497631aea8c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the display format for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. <br /></td></tr>
<tr class="separator:ae799cc3171536b9ee10497631aea8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4ea61f9a55ddfc9defd8548654c8e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aae4ea61f9a55ddfc9defd8548654c8e5">findAddr</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const =0</td></tr>
<tr class="memdesc:aae4ea61f9a55ddfc9defd8548654c8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at a given address and <b>usepoint</b>.  <a href="#aae4ea61f9a55ddfc9defd8548654c8e5">More...</a><br /></td></tr>
<tr class="separator:aae4ea61f9a55ddfc9defd8548654c8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fc1ef47d047717da65827e025cfdd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a609fc1ef47d047717da65827e025cfdd">findContainer</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const =0</td></tr>
<tr class="memdesc:a609fc1ef47d047717da65827e025cfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> containing the given memory range.  <a href="#a609fc1ef47d047717da65827e025cfdd">More...</a><br /></td></tr>
<tr class="separator:a609fc1ef47d047717da65827e025cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab679fe786be2fb949af78054cb2041a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ab679fe786be2fb949af78054cb2041a8">findClosestFit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const =0</td></tr>
<tr class="memdesc:ab679fe786be2fb949af78054cb2041a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> which is the closest fit to the given memory range.  <a href="#ab679fe786be2fb949af78054cb2041a8">More...</a><br /></td></tr>
<tr class="separator:ab679fe786be2fb949af78054cb2041a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c621196f6fdb4b8ce4ee1f3dc953107"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2c621196f6fdb4b8ce4ee1f3dc953107">findFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const =0</td></tr>
<tr class="memdesc:a2c621196f6fdb4b8ce4ee1f3dc953107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the function starting at the given address.  <a href="#a2c621196f6fdb4b8ce4ee1f3dc953107">More...</a><br /></td></tr>
<tr class="separator:a2c621196f6fdb4b8ce4ee1f3dc953107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e0f77b621a3ba6436f8a1c0010d1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af69e0f77b621a3ba6436f8a1c0010d1c">findExternalRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const =0</td></tr>
<tr class="memdesc:af69e0f77b621a3ba6436f8a1c0010d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an <em>external</em> <em>reference</em> at the given address.  <a href="#af69e0f77b621a3ba6436f8a1c0010d1c">More...</a><br /></td></tr>
<tr class="separator:af69e0f77b621a3ba6436f8a1c0010d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bac52b9d64974b87432c0379cc38c6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af4bac52b9d64974b87432c0379cc38c6">findCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const =0</td></tr>
<tr class="memdesc:af4bac52b9d64974b87432c0379cc38c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at the given address.  <a href="#af4bac52b9d64974b87432c0379cc38c6">More...</a><br /></td></tr>
<tr class="separator:af4bac52b9d64974b87432c0379cc38c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395b6194a59515caa1ede92fd6ac511"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a3395b6194a59515caa1ede92fd6ac511">findOverlap</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const =0</td></tr>
<tr class="memdesc:a3395b6194a59515caa1ede92fd6ac511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> overlapping the given memory range.  <a href="#a3395b6194a59515caa1ede92fd6ac511">More...</a><br /></td></tr>
<tr class="separator:a3395b6194a59515caa1ede92fd6ac511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979222d28577e6e8d07e35f12d38bff7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a979222d28577e6e8d07e35f12d38bff7">findByName</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;res) const =0</td></tr>
<tr class="memdesc:a979222d28577e6e8d07e35f12d38bff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> by name within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a979222d28577e6e8d07e35f12d38bff7">More...</a><br /></td></tr>
<tr class="separator:a979222d28577e6e8d07e35f12d38bff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc7f2e38bb4a16ad059bd1edd844dcf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7bc7f2e38bb4a16ad059bd1edd844dcf">isNameUsed</a> (const string &amp;nm, const <a class="el" href="classScope.html">Scope</a> *op2) const =0</td></tr>
<tr class="memdesc:a7bc7f2e38bb4a16ad059bd1edd844dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given name is occurs within the given scope path.  <a href="#a7bc7f2e38bb4a16ad059bd1edd844dcf">More...</a><br /></td></tr>
<tr class="separator:a7bc7f2e38bb4a16ad059bd1edd844dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c45025894f1996ef0f3556752cd997"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af4c45025894f1996ef0f3556752cd997">resolveExternalRefFunction</a> (<a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *sym) const =0</td></tr>
<tr class="memdesc:af4c45025894f1996ef0f3556752cd997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <em>external</em> <em>reference</em> to the referenced function.  <a href="#af4c45025894f1996ef0f3556752cd997">More...</a><br /></td></tr>
<tr class="separator:af4c45025894f1996ef0f3556752cd997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925baecb33b6f0d9212e42c1b48a64ba"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a925baecb33b6f0d9212e42c1b48a64ba">buildVariableName</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, <a class="el" href="classDatatype.html">Datatype</a> *ct, int4 &amp;index, uint4 flags) const =0</td></tr>
<tr class="memdesc:a925baecb33b6f0d9212e42c1b48a64ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an address and data-type, build a suitable generic symbol name.  <a href="#a925baecb33b6f0d9212e42c1b48a64ba">More...</a><br /></td></tr>
<tr class="separator:a925baecb33b6f0d9212e42c1b48a64ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47d5c1c949be84a27a138be0febacb2"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac47d5c1c949be84a27a138be0febacb2">buildUndefinedName</a> (void) const =0</td></tr>
<tr class="memdesc:ac47d5c1c949be84a27a138be0febacb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a formal <b>undefined</b> name, used internally when a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is not given a name.  <a href="#ac47d5c1c949be84a27a138be0febacb2">More...</a><br /></td></tr>
<tr class="separator:ac47d5c1c949be84a27a138be0febacb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0d945c44f4874743496b2814fbb631"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2e0d945c44f4874743496b2814fbb631">makeNameUnique</a> (const string &amp;nm) const =0</td></tr>
<tr class="memdesc:a2e0d945c44f4874743496b2814fbb631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a version of the given symbol name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a2e0d945c44f4874743496b2814fbb631">More...</a><br /></td></tr>
<tr class="separator:a2e0d945c44f4874743496b2814fbb631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2583da1be37d68197dfbb0445fa1f3e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2583da1be37d68197dfbb0445fa1f3e0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2583da1be37d68197dfbb0445fa1f3e0">saveXml</a> (ostream &amp;s) const =0</td></tr>
<tr class="memdesc:a2583da1be37d68197dfbb0445fa1f3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out <b>this</b> as a &lt;scope&gt; XML tag. <br /></td></tr>
<tr class="separator:a2583da1be37d68197dfbb0445fa1f3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad509027899b5f6af11f499f722d61f66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad509027899b5f6af11f499f722d61f66"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad509027899b5f6af11f499f722d61f66">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)=0</td></tr>
<tr class="memdesc:ad509027899b5f6af11f499f722d61f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> from a &lt;scope&gt; XML tag. <br /></td></tr>
<tr class="separator:ad509027899b5f6af11f499f722d61f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d67a1b9e60078023b508dd3cbe4447d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d67a1b9e60078023b508dd3cbe4447d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7d67a1b9e60078023b508dd3cbe4447d">printEntries</a> (ostream &amp;s) const =0</td></tr>
<tr class="memdesc:a7d67a1b9e60078023b508dd3cbe4447d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a description of all <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> objects to a stream. <br /></td></tr>
<tr class="separator:a7d67a1b9e60078023b508dd3cbe4447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909e15a7a96c9b402855b56b6bfdbd9f"><td class="memItemLeft" align="right" valign="top">virtual int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a909e15a7a96c9b402855b56b6bfdbd9f">getCategorySize</a> (int4 cat) const =0</td></tr>
<tr class="memdesc:a909e15a7a96c9b402855b56b6bfdbd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Symbols in the given category.  <a href="#a909e15a7a96c9b402855b56b6bfdbd9f">More...</a><br /></td></tr>
<tr class="separator:a909e15a7a96c9b402855b56b6bfdbd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a168d7ea71f00da419dd864901ccb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a491a168d7ea71f00da419dd864901ccb">getCategorySymbol</a> (int4 cat, int4 ind) const =0</td></tr>
<tr class="memdesc:a491a168d7ea71f00da419dd864901ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> by index within a specific <em>category</em>.  <a href="#a491a168d7ea71f00da419dd864901ccb">More...</a><br /></td></tr>
<tr class="separator:a491a168d7ea71f00da419dd864901ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac807e11df36854d2f7983bdd6779e83a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac807e11df36854d2f7983bdd6779e83a">setCategory</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, int4 cat, int4 ind)=0</td></tr>
<tr class="memdesc:ac807e11df36854d2f7983bdd6779e83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <em>category</em> and index for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.  <a href="#ac807e11df36854d2f7983bdd6779e83a">More...</a><br /></td></tr>
<tr class="separator:ac807e11df36854d2f7983bdd6779e83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c79f7f535ba4e819fcf95185896a019"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7c79f7f535ba4e819fcf95185896a019">addSymbol</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a7c79f7f535ba4e819fcf95185896a019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, given a name, data-type, and a single mapping.  <a href="#a7c79f7f535ba4e819fcf95185896a019">More...</a><br /></td></tr>
<tr class="separator:a7c79f7f535ba4e819fcf95185896a019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38c5095ed734cacbf95e3eab8724c13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38c5095ed734cacbf95e3eab8724c13"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa38c5095ed734cacbf95e3eab8724c13">getName</a> (void) const </td></tr>
<tr class="memdesc:aa38c5095ed734cacbf95e3eab8724c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. <br /></td></tr>
<tr class="separator:aa38c5095ed734cacbf95e3eab8724c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af087df2fe8d5576e169d7fbffd55c583"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af087df2fe8d5576e169d7fbffd55c583"></a>
uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af087df2fe8d5576e169d7fbffd55c583">getId</a> (void) const </td></tr>
<tr class="memdesc:af087df2fe8d5576e169d7fbffd55c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the globally unique id. <br /></td></tr>
<tr class="separator:af087df2fe8d5576e169d7fbffd55c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66098c4a665995b7fa4335028b6e8d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66098c4a665995b7fa4335028b6e8d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa66098c4a665995b7fa4335028b6e8d8">isGlobal</a> (void) const </td></tr>
<tr class="memdesc:aa66098c4a665995b7fa4335028b6e8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> scope is global. <br /></td></tr>
<tr class="separator:aa66098c4a665995b7fa4335028b6e8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a2a9e084183e6ec689e1ac5ca6d119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a04a2a9e084183e6ec689e1ac5ca6d119">queryByName</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;res) const </td></tr>
<tr class="memdesc:a04a2a9e084183e6ec689e1ac5ca6d119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up symbols by name.  <a href="#a04a2a9e084183e6ec689e1ac5ca6d119">More...</a><br /></td></tr>
<tr class="separator:a04a2a9e084183e6ec689e1ac5ca6d119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a05c603b8ca02ead72b4aa6ea7ad1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa8a05c603b8ca02ead72b4aa6ea7ad1c">queryFunction</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>) const </td></tr>
<tr class="memdesc:aa8a05c603b8ca02ead72b4aa6ea7ad1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function by name.  <a href="#aa8a05c603b8ca02ead72b4aa6ea7ad1c">More...</a><br /></td></tr>
<tr class="separator:aa8a05c603b8ca02ead72b4aa6ea7ad1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42106908373c17acd69e390252c041a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a42106908373c17acd69e390252c041a3">queryByAddr</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const </td></tr>
<tr class="memdesc:a42106908373c17acd69e390252c041a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> with matching address.  <a href="#a42106908373c17acd69e390252c041a3">More...</a><br /></td></tr>
<tr class="separator:a42106908373c17acd69e390252c041a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658cdbd473ad897981a48f4b41584aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a658cdbd473ad897981a48f4b41584aaf">queryContainer</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const </td></tr>
<tr class="memdesc:a658cdbd473ad897981a48f4b41584aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.  <a href="#a658cdbd473ad897981a48f4b41584aaf">More...</a><br /></td></tr>
<tr class="separator:a658cdbd473ad897981a48f4b41584aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a607e1ba8c2cc85a14b84a1c86944e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a81a607e1ba8c2cc85a14b84a1c86944e">queryProperties</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, uint4 &amp;flags) const </td></tr>
<tr class="memdesc:a81a607e1ba8c2cc85a14b84a1c86944e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> or properties at the given address.  <a href="#a81a607e1ba8c2cc85a14b84a1c86944e">More...</a><br /></td></tr>
<tr class="separator:a81a607e1ba8c2cc85a14b84a1c86944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6e7756d027c21483e2dea62e3e8e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#acc6e7756d027c21483e2dea62e3e8e0d">queryFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:acc6e7756d027c21483e2dea62e3e8e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function by address.  <a href="#acc6e7756d027c21483e2dea62e3e8e0d">More...</a><br /></td></tr>
<tr class="separator:acc6e7756d027c21483e2dea62e3e8e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865abee846f171d39b39d36474b96fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a865abee846f171d39b39d36474b96fae">queryExternalRefFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a865abee846f171d39b39d36474b96fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a function thru an <em>external</em> <em>reference</em>.  <a href="#a865abee846f171d39b39d36474b96fae">More...</a><br /></td></tr>
<tr class="separator:a865abee846f171d39b39d36474b96fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dc6d9ed629d4630a58b0a66e911f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a83dc6d9ed629d4630a58b0a66e911f1c">queryCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const </td></tr>
<tr class="memdesc:a83dc6d9ed629d4630a58b0a66e911f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up a code label by address.  <a href="#a83dc6d9ed629d4630a58b0a66e911f1c">More...</a><br /></td></tr>
<tr class="separator:a83dc6d9ed629d4630a58b0a66e911f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26deba0c14204470aa92b6f131aaccb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a26deba0c14204470aa92b6f131aaccb2">resolveScope</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, bool strategy) const </td></tr>
<tr class="memdesc:a26deba0c14204470aa92b6f131aaccb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>.  <a href="#a26deba0c14204470aa92b6f131aaccb2">More...</a><br /></td></tr>
<tr class="separator:a26deba0c14204470aa92b6f131aaccb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef5f179b42a9696fd077dbc7144ecc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">discoverScope</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:aaef5f179b42a9696fd077dbc7144ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the owning <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of a given memory range.  <a href="#aaef5f179b42a9696fd077dbc7144ecc2">More...</a><br /></td></tr>
<tr class="separator:aaef5f179b42a9696fd077dbc7144ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5631c4b933fb1acc9ffaea6a71a267a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5631c4b933fb1acc9ffaea6a71a267a0"></a>
ScopeMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a5631c4b933fb1acc9ffaea6a71a267a0">childrenBegin</a> () const </td></tr>
<tr class="memdesc:a5631c4b933fb1acc9ffaea6a71a267a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator of child scopes. <br /></td></tr>
<tr class="separator:a5631c4b933fb1acc9ffaea6a71a267a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f82c4f7301b043a4d19694cd0501dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4f82c4f7301b043a4d19694cd0501dc"></a>
ScopeMap::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ae4f82c4f7301b043a4d19694cd0501dc">childrenEnd</a> () const </td></tr>
<tr class="memdesc:ae4f82c4f7301b043a4d19694cd0501dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator of child scopes. <br /></td></tr>
<tr class="separator:ae4f82c4f7301b043a4d19694cd0501dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa986065e802ab19dd807b76ea1a835b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aaa986065e802ab19dd807b76ea1a835b">saveXmlRecursive</a> (ostream &amp;s, bool onlyGlobal) const </td></tr>
<tr class="memdesc:aaa986065e802ab19dd807b76ea1a835b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save all contained scopes as an XML stream.  <a href="#aaa986065e802ab19dd807b76ea1a835b">More...</a><br /></td></tr>
<tr class="separator:aaa986065e802ab19dd807b76ea1a835b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a05df4f8df1764859bec8372d64b1ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0a05df4f8df1764859bec8372d64b1ee">overrideSizeLockType</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a0a05df4f8df1764859bec8372d64b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> that is <em>sizelocked</em>.  <a href="#a0a05df4f8df1764859bec8372d64b1ee">More...</a><br /></td></tr>
<tr class="separator:a0a05df4f8df1764859bec8372d64b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af52229967e3a507a5367e14a298142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4af52229967e3a507a5367e14a298142">resetSizeLockType</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym)</td></tr>
<tr class="memdesc:a4af52229967e3a507a5367e14a298142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>'s <em>size-locked</em> data-type.  <a href="#a4af52229967e3a507a5367e14a298142">More...</a><br /></td></tr>
<tr class="separator:a4af52229967e3a507a5367e14a298142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b6e6d45b1a2a2ca97d7a6a2616bf8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0b6e6d45b1a2a2ca97d7a6a2616bf8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa0b6e6d45b1a2a2ca97d7a6a2616bf8d">setThisPointer</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, bool val)</td></tr>
<tr class="memdesc:aa0b6e6d45b1a2a2ca97d7a6a2616bf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> as the "this" pointer. <br /></td></tr>
<tr class="separator:aa0b6e6d45b1a2a2ca97d7a6a2616bf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efed6f12d75ad6508a09a83bd990afb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a9efed6f12d75ad6508a09a83bd990afb">isSubScope</a> (const <a class="el" href="classScope.html">Scope</a> *scp) const </td></tr>
<tr class="memdesc:a9efed6f12d75ad6508a09a83bd990afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a sub-scope of the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a9efed6f12d75ad6508a09a83bd990afb">More...</a><br /></td></tr>
<tr class="separator:a9efed6f12d75ad6508a09a83bd990afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c322733ba867f8d86172ce39bfd9366"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c322733ba867f8d86172ce39bfd9366"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a9c322733ba867f8d86172ce39bfd9366">getFullName</a> (void) const </td></tr>
<tr class="memdesc:a9c322733ba867f8d86172ce39bfd9366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. <br /></td></tr>
<tr class="separator:a9c322733ba867f8d86172ce39bfd9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491e95f677b001f9592269da20ee8c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a491e95f677b001f9592269da20ee8c49">getScopePath</a> (vector&lt; const <a class="el" href="classScope.html">Scope</a> * &gt; &amp;vec) const </td></tr>
<tr class="memdesc:a491e95f677b001f9592269da20ee8c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ordered list of scopes up to <b>this</b>.  <a href="#a491e95f677b001f9592269da20ee8c49">More...</a><br /></td></tr>
<tr class="separator:a491e95f677b001f9592269da20ee8c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f46e51996466b9768e0f5e0fb1b86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#abc4f46e51996466b9768e0f5e0fb1b86">findDistinguishingScope</a> (const <a class="el" href="classScope.html">Scope</a> *op2) const </td></tr>
<tr class="memdesc:abc4f46e51996466b9768e0f5e0fb1b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first ancestor of <b>this</b> not shared by given scope.  <a href="#abc4f46e51996466b9768e0f5e0fb1b86">More...</a><br /></td></tr>
<tr class="separator:abc4f46e51996466b9768e0f5e0fb1b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e2018c6c10aaca1403cc9850e065e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb0e2018c6c10aaca1403cc9850e065e"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#adb0e2018c6c10aaca1403cc9850e065e">getArch</a> (void) const </td></tr>
<tr class="memdesc:adb0e2018c6c10aaca1403cc9850e065e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> associated with <b>this</b>. <br /></td></tr>
<tr class="separator:adb0e2018c6c10aaca1403cc9850e065e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40c99093bd5fc683aa63b9e4bf7daa2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af40c99093bd5fc683aa63b9e4bf7daa2"></a>
<a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent</a> (void) const </td></tr>
<tr class="memdesc:af40c99093bd5fc683aa63b9e4bf7daa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> (or NULL if <b>this</b> is the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>) <br /></td></tr>
<tr class="separator:af40c99093bd5fc683aa63b9e4bf7daa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e7adcd07f0dbd9cf1777e2b3be9fe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a96e7adcd07f0dbd9cf1777e2b3be9fe2">addSymbol</a> (const string &amp;<a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, <a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:a96e7adcd07f0dbd9cf1777e2b3be9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> <em>without</em> mapping it to an address.  <a href="#a96e7adcd07f0dbd9cf1777e2b3be9fe2">More...</a><br /></td></tr>
<tr class="separator:a96e7adcd07f0dbd9cf1777e2b3be9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a0309ce54c25e56871edbfdfe25675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a03a0309ce54c25e56871edbfdfe25675">addMapPoint</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a03a0309ce54c25e56871edbfdfe25675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a specific address.  <a href="#a03a0309ce54c25e56871edbfdfe25675">More...</a><br /></td></tr>
<tr class="separator:a03a0309ce54c25e56871edbfdfe25675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421f1b66be24bd5a20c77761e7a51268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a421f1b66be24bd5a20c77761e7a51268">addMapSym</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a421f1b66be24bd5a20c77761e7a51268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> from a &lt;mapsym&gt; XML tag.  <a href="#a421f1b66be24bd5a20c77761e7a51268">More...</a><br /></td></tr>
<tr class="separator:a421f1b66be24bd5a20c77761e7a51268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f8bc9f073a957d43298394cac0678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a8f7f8bc9f073a957d43298394cac0678">addFunction</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const string &amp;nm)</td></tr>
<tr class="memdesc:a8f7f8bc9f073a957d43298394cac0678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a8f7f8bc9f073a957d43298394cac0678">More...</a><br /></td></tr>
<tr class="separator:a8f7f8bc9f073a957d43298394cac0678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648715fd4a06419df21ecdc060ff2911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a648715fd4a06419df21ecdc060ff2911">addExternalRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;refaddr, const string &amp;nm)</td></tr>
<tr class="separator:a648715fd4a06419df21ecdc060ff2911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcaf595e4437d91af6a243ef0d49640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLabSymbol.html">LabSymbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4dcaf595e4437d91af6a243ef0d49640">addCodeLabel</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, const string &amp;nm)</td></tr>
<tr class="memdesc:a4dcaf595e4437d91af6a243ef0d49640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a code label at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a4dcaf595e4437d91af6a243ef0d49640">More...</a><br /></td></tr>
<tr class="separator:a4dcaf595e4437d91af6a243ef0d49640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42668b79a23d2e4e67f54e2185a2b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#af42668b79a23d2e4e67f54e2185a2b58">addDynamicSymbol</a> (const string &amp;nm, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;caddr, uint8 hash)</td></tr>
<tr class="memdesc:af42668b79a23d2e4e67f54e2185a2b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dynamically mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> attached to a specific data-flow.  <a href="#af42668b79a23d2e4e67f54e2185a2b58">More...</a><br /></td></tr>
<tr class="separator:af42668b79a23d2e4e67f54e2185a2b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7676c111d5ff3bd5a41643fae42e400"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad7676c111d5ff3bd5a41643fae42e400">buildDefaultName</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, int4 &amp;base, <a class="el" href="classVarnode.html">Varnode</a> *vn) const </td></tr>
<tr class="memdesc:ad7676c111d5ff3bd5a41643fae42e400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default name for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.  <a href="#ad7676c111d5ff3bd5a41643fae42e400">More...</a><br /></td></tr>
<tr class="separator:ad7676c111d5ff3bd5a41643fae42e400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792b7d35442a4f7b476c13bcd54f7d69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a792b7d35442a4f7b476c13bcd54f7d69">isReadOnly</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint) const </td></tr>
<tr class="memdesc:a792b7d35442a4f7b476c13bcd54f7d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given memory range marked as <em>read-only</em>.  <a href="#a792b7d35442a4f7b476c13bcd54f7d69">More...</a><br /></td></tr>
<tr class="separator:a792b7d35442a4f7b476c13bcd54f7d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2175d7e4c8b85f5ea8c0d9a583e8ac93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2175d7e4c8b85f5ea8c0d9a583e8ac93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2175d7e4c8b85f5ea8c0d9a583e8ac93">printBounds</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a2175d7e4c8b85f5ea8c0d9a583e8ac93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>'s <em>owned</em> memory ranges. <br /></td></tr>
<tr class="separator:a2175d7e4c8b85f5ea8c0d9a583e8ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a91bf6ab42a5e9b86ba1f9c3af46c2ef1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91bf6ab42a5e9b86ba1f9c3af46c2ef1"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a91bf6ab42a5e9b86ba1f9c3af46c2ef1">getRangeTree</a> (void) const </td></tr>
<tr class="memdesc:a91bf6ab42a5e9b86ba1f9c3af46c2ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the address ranges owned by <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. <br /></td></tr>
<tr class="separator:a91bf6ab42a5e9b86ba1f9c3af46c2ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c255b9739cb57e0ecf8a9ee3220f15"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ac9c255b9739cb57e0ecf8a9ee3220f15">buildSubScope</a> (uint8 id, const string &amp;nm)=0</td></tr>
<tr class="memdesc:ac9c255b9739cb57e0ecf8a9ee3220f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an unattached <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to be associated as a sub-scope of <b>this</b>.  <a href="#ac9c255b9739cb57e0ecf8a9ee3220f15">More...</a><br /></td></tr>
<tr class="separator:ac9c255b9739cb57e0ecf8a9ee3220f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21556c257fbea888f9004c654599dfe9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a21556c257fbea888f9004c654599dfe9">restrictScope</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:a21556c257fbea888f9004c654599dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <b>this</b> to a local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a21556c257fbea888f9004c654599dfe9">More...</a><br /></td></tr>
<tr class="separator:a21556c257fbea888f9004c654599dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33adf8d24b5e22aa420b840b817131e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a33adf8d24b5e22aa420b840b817131e0">addRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:a33adf8d24b5e22aa420b840b817131e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory range to the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#a33adf8d24b5e22aa420b840b817131e0">More...</a><br /></td></tr>
<tr class="separator:a33adf8d24b5e22aa420b840b817131e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4a9faa5d12ef3b0be55810dac6d35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#ad1b4a9faa5d12ef3b0be55810dac6d35">removeRange</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb first, uintb last)</td></tr>
<tr class="memdesc:ad1b4a9faa5d12ef3b0be55810dac6d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a memory range from the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>.  <a href="#ad1b4a9faa5d12ef3b0be55810dac6d35">More...</a><br /></td></tr>
<tr class="separator:ad1b4a9faa5d12ef3b0be55810dac6d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d3198f4bd28cf9e8a2a6bc00d065d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a66d3198f4bd28cf9e8a2a6bc00d065d8">addSymbolInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym)=0</td></tr>
<tr class="memdesc:a66d3198f4bd28cf9e8a2a6bc00d065d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> into the name map.  <a href="#a66d3198f4bd28cf9e8a2a6bc00d065d8">More...</a><br /></td></tr>
<tr class="separator:a66d3198f4bd28cf9e8a2a6bc00d065d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0451f131ea214a174e00a434be36e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aec0451f131ea214a174e00a434be36e9">addMapInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 exfl, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 off, int4 sz, const <a class="el" href="classRangeList.html">RangeList</a> &amp;uselim)=0</td></tr>
<tr class="memdesc:aec0451f131ea214a174e00a434be36e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> given a memory range.  <a href="#aec0451f131ea214a174e00a434be36e9">More...</a><br /></td></tr>
<tr class="separator:aec0451f131ea214a174e00a434be36e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b5f792b07b023d43309472cd6f4d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a5d3b5f792b07b023d43309472cd6f4d9">addDynamicMapInternal</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint4 exfl, uint8 hash, int4 off, int4 sz, const <a class="el" href="classRangeList.html">RangeList</a> &amp;uselim)=0</td></tr>
<tr class="memdesc:a5d3b5f792b07b023d43309472cd6f4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> given a dynamic hash.  <a href="#a5d3b5f792b07b023d43309472cd6f4d9">More...</a><br /></td></tr>
<tr class="separator:a5d3b5f792b07b023d43309472cd6f4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885d1c31a74185504f2ec8647fe170e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a7885d1c31a74185504f2ec8647fe170e">addMap</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> &amp;entry)</td></tr>
<tr class="memdesc:a7885d1c31a74185504f2ec8647fe170e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> into the range maps.  <a href="#a7885d1c31a74185504f2ec8647fe170e">More...</a><br /></td></tr>
<tr class="separator:a7885d1c31a74185504f2ec8647fe170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80234ab4fb6adc6dc9aa57b6736fa399"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80234ab4fb6adc6dc9aa57b6736fa399"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a80234ab4fb6adc6dc9aa57b6736fa399">setSymbolId</a> (<a class="el" href="classSymbol.html">Symbol</a> *sym, uint8 id) const </td></tr>
<tr class="memdesc:a80234ab4fb6adc6dc9aa57b6736fa399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the id associated with a symbol. <br /></td></tr>
<tr class="separator:a80234ab4fb6adc6dc9aa57b6736fa399"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a598536926659c304d35346aba6d79fa2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="memdesc:a598536926659c304d35346aba6d79fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for Symbols starting at a given address, which match a given <b>usepoint</b>.  <a href="#a598536926659c304d35346aba6d79fa2">More...</a><br /></td></tr>
<tr class="separator:a598536926659c304d35346aba6d79fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e00dad81427a8595cf7bf13d8e1e0d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="separator:a63e00dad81427a8595cf7bf13d8e1e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de9b51d8c57e33e9394512489539664"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> **addrmatch)</td></tr>
<tr class="separator:a4de9b51d8c57e33e9394512489539664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0d2e90ee5d4bc7e3dc761390be5e47"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classFuncdata.html">Funcdata</a> **addrmatch)</td></tr>
<tr class="separator:a1e0d2e90ee5d4bc7e3dc761390be5e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44898a2294de74a77dd21583ca6254e2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a44898a2294de74a77dd21583ca6254e2">stackExternalRef</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> **addrmatch)</td></tr>
<tr class="separator:a44898a2294de74a77dd21583ca6254e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26992d3bf69e5c2c02e57943b1355f0d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel</a> (const <a class="el" href="classScope.html">Scope</a> *scope1, const <a class="el" href="classScope.html">Scope</a> *scope2, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classLabSymbol.html">LabSymbol</a> **addrmatch)</td></tr>
<tr class="separator:a26992d3bf69e5c2c02e57943b1355f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa5939cb5690f2f2b4f52a88ae561622d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5939cb5690f2f2b4f52a88ae561622d"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#aa5939cb5690f2f2b4f52a88ae561622d">glb</a></td></tr>
<tr class="memdesc:aa5939cb5690f2f2b4f52a88ae561622d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> of <b>this</b> scope. <br /></td></tr>
<tr class="separator:aa5939cb5690f2f2b4f52a88ae561622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4900f6409e8a82c1b1cea827e4e2c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb4900f6409e8a82c1b1cea827e4e2c5"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a></td></tr>
<tr class="memdesc:abb4900f6409e8a82c1b1cea827e4e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of <b>this</b> scope. <br /></td></tr>
<tr class="separator:abb4900f6409e8a82c1b1cea827e4e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f6c31e73c46216482a6902d22b3330"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72f6c31e73c46216482a6902d22b3330"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a72f6c31e73c46216482a6902d22b3330">fd</a></td></tr>
<tr class="memdesc:a72f6c31e73c46216482a6902d22b3330"><td class="mdescLeft">&#160;</td><td class="mdescRight">(If non-null) the function which <b>this</b> is the local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> for <br /></td></tr>
<tr class="separator:a72f6c31e73c46216482a6902d22b3330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b6a027bf415a1f821a33844301188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f1b6a027bf415a1f821a33844301188"></a>
uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a9f1b6a027bf415a1f821a33844301188">uniqueId</a></td></tr>
<tr class="memdesc:a9f1b6a027bf415a1f821a33844301188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique id for the scope, for deduping scope names, assigning symbol ids. <br /></td></tr>
<tr class="separator:a9f1b6a027bf415a1f821a33844301188"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a267c957503a77a651230beedbc9f27ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a267c957503a77a651230beedbc9f27ec">attachScope</a> (<a class="el" href="classScope.html">Scope</a> *child)</td></tr>
<tr class="memdesc:a267c957503a77a651230beedbc9f27ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a new child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to <b>this</b>.  <a href="#a267c957503a77a651230beedbc9f27ec">More...</a><br /></td></tr>
<tr class="separator:a267c957503a77a651230beedbc9f27ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0b94bbfa2b7a8391f8be410547cc67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a4a0b94bbfa2b7a8391f8be410547cc67">detachScope</a> (ScopeMap::iterator iter)</td></tr>
<tr class="memdesc:a4a0b94bbfa2b7a8391f8be410547cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> from <b>this</b>.  <a href="#a4a0b94bbfa2b7a8391f8be410547cc67">More...</a><br /></td></tr>
<tr class="separator:a4a0b94bbfa2b7a8391f8be410547cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a1457346b2f6c9e7196032a21917dd42c"><td class="memItemLeft" align="right" valign="top">static uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a1457346b2f6c9e7196032a21917dd42c">hashScopeName</a> (uint8 baseId, const string &amp;nm)</td></tr>
<tr class="memdesc:a1457346b2f6c9e7196032a21917dd42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> id based on the scope's name and its parent's id.  <a href="#a1457346b2f6c9e7196032a21917dd42c">More...</a><br /></td></tr>
<tr class="separator:a1457346b2f6c9e7196032a21917dd42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a588172ad2f5c11ee6e9f793c2e599071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a588172ad2f5c11ee6e9f793c2e599071"></a>
<a class="el" href="classRangeList.html">RangeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a588172ad2f5c11ee6e9f793c2e599071">rangetree</a></td></tr>
<tr class="memdesc:a588172ad2f5c11ee6e9f793c2e599071"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRange.html" title="A contiguous range of bytes in some address space. ">Range</a> of data addresses <em>owned</em> by <b>this</b> scope. <br /></td></tr>
<tr class="separator:a588172ad2f5c11ee6e9f793c2e599071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df68cab954d40b15c9e45bca324fcbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2df68cab954d40b15c9e45bca324fcbc"></a>
<a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a></td></tr>
<tr class="memdesc:a2df68cab954d40b15c9e45bca324fcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent scope. <br /></td></tr>
<tr class="separator:a2df68cab954d40b15c9e45bca324fcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0be1fce6be8dd14da24427c9654aff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f0be1fce6be8dd14da24427c9654aff"></a>
<a class="el" href="classScope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a0f0be1fce6be8dd14da24427c9654aff">owner</a></td></tr>
<tr class="memdesc:a0f0be1fce6be8dd14da24427c9654aff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> using <b>this</b> as a cache. <br /></td></tr>
<tr class="separator:a0f0be1fce6be8dd14da24427c9654aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6abc6a7c8631a1309d74ce9aa85e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a6abc6a7c8631a1309d74ce9aa85e8"></a>
<a class="el" href="database_8hh.html#a41b5ded5068e42fce5a6703ff374b192">ScopeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScope.html#a10a6abc6a7c8631a1309d74ce9aa85e8">children</a></td></tr>
<tr class="memdesc:a10a6abc6a7c8631a1309d74ce9aa85e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorted list of child scopes. <br /></td></tr>
<tr class="separator:a10a6abc6a7c8631a1309d74ce9aa85e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6efef52d7a939622bbc934ff6b90ffe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6efef52d7a939622bbc934ff6b90ffe0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Database</b></td></tr>
<tr class="separator:a6efef52d7a939622bbc934ff6b90ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec804b298dc727f18acb363664fb4f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ec804b298dc727f18acb363664fb4f5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ScopeCompare</b></td></tr>
<tr class="separator:a7ec804b298dc727f18acb363664fb4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> objects within a single (namespace or functional) scope. </p>
<p>This acts as a traditional <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> container, allowing them to be accessed by name, but it also keeps track of how a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is mapped into memory. It allows a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to be looked up by its location in memory, which is sensitive to the address of the code accessing the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.</p>
<p>Capabilities include:</p><ul>
<li>Search for Symbols<ul>
<li>By name</li>
<li>By storage address</li>
<li>By type of <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a></li>
<li>Containing a range</li>
<li>Overlapping a range</li>
</ul>
</li>
<li>Insert or remove a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a></li>
<li>Add or remove <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> objects which associate Symbols with storage and the code that accesses it</li>
<li>Modify properties of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a></li>
</ul>
<p>A scope also supports the idea of <b>ownership</b> of memory. In theory, for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> in the scope, at the code locations where the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> storage is valid, the scope <em>owns</em> the storage memory. In practice, a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object knows about memory ranges where a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> might be <em>discovered</em>. For instance, the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> usually owns all memory in the <em>ram</em> address space. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4dcaf595e4437d91af6a243ef0d49640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLabSymbol.html">LabSymbol</a> * Scope::addCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a code label at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>A <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function. ">LabSymbol</a> is created and mapped to the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address to map to </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the symbol/label </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function. ">LabSymbol</a> </dd></dl>

<p>References <a class="el" href="classSymbol.html#aee9da22d9d9f511694bb1eb95f5033e9">Symbol::getName()</a>, and <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>.</p>

<p>Referenced by <a class="el" href="classScopeGhidra.html#add0b4446a2a4d381709055717830ed99">ScopeGhidra::findCodeLabel()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d3b5f792b07b023d43309472cd6f4d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::addDynamicMapInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>exfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>uselim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> given a dynamic hash. </p>
<p>The <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> is specified in terms of a <b>hash</b> and <b>usepoint</b>, which describe how to find the temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the symbol value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> being mapped </td></tr>
    <tr><td class="paramname">exfl</td><td>are any boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties </td></tr>
    <tr><td class="paramname">hash</td><td>is the given dynamic hash </td></tr>
    <tr><td class="paramname">off</td><td>is the byte offset of the new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> (relative to the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>) </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes occupied by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">uselim</td><td>is the given <b>usepoint</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#abd7bd6f565efa0e9eb5a7415fab0fca5">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a1344895b80746ac226f1b86029c17e05">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="af42668b79a23d2e4e67f54e2185a2b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Scope::addDynamicSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>caddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dynamically mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> attached to a specific data-flow. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is created and mapped to a dynamic <em>hash</em> and a code address where the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is being used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">caddr</td><td>is the code address where the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is being used </td></tr>
    <tr><td class="paramname">hash</td><td>is the dynamic hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </dd></dl>

<p>References <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, and <a class="el" href="classSymbol.html#a5188e6395f982732c218279809b92a8e">Symbol::Symbol()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aa15db3d569027578de69c065fc607c63">Funcdata::buildDynamicSymbol()</a>.</p>

</div>
</div>
<a class="anchor" id="a648715fd4a06419df21ecdc060ff2911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> * Scope::addExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>refaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <em>external</em> <em>reference</em> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a></p>
<p>An <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location. ">ExternRefSymbol</a> is created and mapped to the given address and stores a reference address to the actual function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address to map the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to </td></tr>
    <tr><td class="paramname">refaddr</td><td>is the reference address </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the symbol/function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location. ">ExternRefSymbol</a> </dd></dl>

<p>References <a class="el" href="classExternRefSymbol.html#ac9c052df8c2ee617cdc3d1bd985121be">ExternRefSymbol::ExternRefSymbol()</a>, <a class="el" href="classSymbol.html#ae27fc3f664b0edbd5cedf859acfb0707">Symbol::flags</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>, and <a class="el" href="classSymbolEntry.html#ab23a87a324831b27ff4d5030175a08c7">SymbolEntry::symbol</a>.</p>

</div>
</div>
<a class="anchor" id="a8f7f8bc9f073a957d43298394cac0678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionSymbol.html">FunctionSymbol</a> * Scope::addFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at the given address in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>The <a class="el" href="classFunctionSymbol.html" title="A Symbol representing an executable function. ">FunctionSymbol</a> is created and mapped to the given address. A <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object is only created once <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb" title="Get the underlying Funcdata object. ">FunctionSymbol::getFunction()</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the entry address of the function </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the function, within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classFunctionSymbol.html" title="A Symbol representing an executable function. ">FunctionSymbol</a> object </dd></dl>

<p>References <a class="el" href="classSymbol.html#aee9da22d9d9f511694bb1eb95f5033e9">Symbol::getName()</a>, <a class="el" href="classSymbolEntry.html#a287e40890058a4847f4f1ae95f1c189b">SymbolEntry::getSymbol()</a>, and <a class="el" href="classSymbol.html#a0254b578a75d2bd6f7e145fe081cb6dd">Symbol::name</a>.</p>

<p>Referenced by <a class="el" href="classArchitecture.html#a58b90d2e89c742bf23c71ba53c57b7a1">Architecture::readLoaderSymbols()</a>.</p>

</div>
</div>
<a class="anchor" id="a7885d1c31a74185504f2ec8647fe170e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::addMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> into the range maps. </p>
<p>The mapping is given as an unintegrated <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> object. Memory may be specified in terms of join addresses, which this method must unravel. The <b>offset</b>, <b>size</b>, and <b>extraflags</b> fields of the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> are not used. In particular, the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> is assumed to map the entire <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> which has been fully integrated </dd></dl>

<p>References <a class="el" href="classSymbolEntry.html#aa07b2446b764db960d44aa352405154d">SymbolEntry::addr</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classRangeList.html#afab3e451530bb1f7c8c1bd66a7df32a5">RangeList::clear()</a>, <a class="el" href="classRangeList.html#a530269f4071fe49aa13dd97f7128bc4a">RangeList::empty()</a>, <a class="el" href="classSymbol.html#ae27fc3f664b0edbd5cedf859acfb0707">Symbol::flags</a>, <a class="el" href="classSymbol.html#a943f979aba58c4b08fcd2d3ab219f538">Symbol::getBytesConsumed()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classJoinRecord.html#af371494cd9c83437c4096cfc6e10b759">JoinRecord::getPiece()</a>, <a class="el" href="classSymbolEntry.html#ae4b71d5e19b9cdf9466a44141a80b9b5">SymbolEntry::hash</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, <a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">Address::isBigEndian()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, <a class="el" href="classAddress.html#af320224a1a004a7bc94d2fa8ac474835">Address::isJoin()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, <a class="el" href="classJoinRecord.html#a50960a501a7d9cee771e541f634ae725">JoinRecord::numPieces()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8caeb173e0f2c992f3b7a15fbede0805629">Varnode::precishi</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca2e26b7277dd6b11db8498c07974935d1">Varnode::precislo</a>, <a class="el" href="classSymbolEntry.html#ab23a87a324831b27ff4d5030175a08c7">SymbolEntry::symbol</a>, and <a class="el" href="classSymbolEntry.html#a1d0818cc564a52f4a06cd49042f1ebd0">SymbolEntry::uselimit</a>.</p>

</div>
</div>
<a class="anchor" id="aec0451f131ea214a174e00a434be36e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::addMapInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>exfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td>
          <td class="paramname"><em>uselim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> given a memory range. </p>
<p>The <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> is specified in terms of a memory range and <b>usepoint</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> being mapped </td></tr>
    <tr><td class="paramname">exfl</td><td>are any boolean <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties specific to the memory range </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">off</td><td>is the byte offset of the new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> (relative to the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>) </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">uselim</td><td>is the given <b>usepoint</b> (which may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a3b6e20fcb0624056020f2fc20d0a06ee">ScopeInternal</a>, <a class="el" href="classScopeGhidraNamespace.html#aa172c9a51885ac46f20967d68ca2a24c">ScopeGhidraNamespace</a>, and <a class="el" href="classScopeGhidra.html#addc5b238357161e4661c8616312cef12">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a03a0309ce54c25e56871edbfdfe25675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::addMapPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a specific address. </p>
<p>Create a new <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> that maps the whole <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to the given address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address to map to </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is accessed at that address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> representing the new mapping </dd></dl>

<p>References <a class="el" href="classSymbolEntry.html#aa07b2446b764db960d44aa352405154d">SymbolEntry::addr</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classRangeList.html#ab0ab4e29f9f3b6b096e985d99daac763">RangeList::insertRange()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, and <a class="el" href="classSymbolEntry.html#a1d0818cc564a52f4a06cd49042f1ebd0">SymbolEntry::uselimit</a>.</p>

<p>Referenced by <a class="el" href="classScopeInternal.html#a9711a8084e1ac5c4417a4452c96a36b7">ScopeInternal::retypeSymbol()</a>.</p>

</div>
</div>
<a class="anchor" id="a421f1b66be24bd5a20c77761e7a51268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Scope::addMapSym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a mapped <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> from a &lt;mapsym&gt; XML tag. </p>
<p>A tag describing the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is parsed first, followed by sequences of &lt;addr&gt; or &lt;hash&gt; and &lt;rangelist&gt; which define 1 or more mappings of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> The new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> and <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> mappings are integrated into <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the &lt;mapsym&gt; XML element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </dd></dl>

<p>References <a class="el" href="classExternRefSymbol.html#ac9c052df8c2ee617cdc3d1bd985121be">ExternRefSymbol::ExternRefSymbol()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classSymbolEntry.html#aa3652a818aa90f3704c5dccad5ece260">SymbolEntry::isInvalid()</a>, <a class="el" href="classSymbolEntry.html#a6117b39bc8d1a12e3cba724dab6dff3f">SymbolEntry::restoreXml()</a>, <a class="el" href="classSymbol.html#a3266a5752c208bdfa5a28e792de67604">Symbol::restoreXml()</a>, and <a class="el" href="classSymbol.html#a5188e6395f982732c218279809b92a8e">Symbol::Symbol()</a>.</p>

<p>Referenced by <a class="el" href="classScopeGhidra.html#a2ffc2304352c385e9abab05885d1e96c">ScopeGhidra::dump2Cache()</a>, and <a class="el" href="classScopeInternal.html#ad79bd78299b2bea6c0f4221682e81b07">ScopeInternal::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a33adf8d24b5e22aa420b840b817131e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::addRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory range to the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#ac5fb1f31ee095f0bb37b5181ab3af192">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScopeGhidra.html#ac5fb1f31ee095f0bb37b5181ab3af192">ScopeGhidra::addRange()</a>, and <a class="el" href="classDatabase.html#a3ad165aa6ec64f417376669625d31c69">Database::addRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c79f7f535ba4e819fcf95185896a019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::addSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, given a name, data-type, and a single mapping. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> object will be created with the given name and data-type. A single mapping (<a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>) will be created for the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> based on a given storage address for the symbol and an address for code that accesses the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at that storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the new name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type of the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> storage </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point accessing that storage (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> matching the new mapping </dd></dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#abb80f5f1b2391d5865f3c75ec1e03644">ScopeGhidra</a>.</p>

<p>References <a class="el" href="classSymbol.html#a5188e6395f982732c218279809b92a8e">Symbol::Symbol()</a>.</p>

<p>Referenced by <a class="el" href="classScopeGhidra.html#abb80f5f1b2391d5865f3c75ec1e03644">ScopeGhidra::addSymbol()</a>, <a class="el" href="classFuncdata.html#a819b7ff38483292c7020320daa8bfdc0">Funcdata::coverVarnodes()</a>, <a class="el" href="classScopeLocal.html#a9776a5769d4422c1e9b9d2dd7c6dfd06">ScopeLocal::createEntry()</a>, <a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">Funcdata::linkSymbol()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, and <a class="el" href="classScopeInternal.html#a07b67a407984707a01a2228b347d9fed">ScopeInternal::processCollision()</a>.</p>

</div>
</div>
<a class="anchor" id="a96e7adcd07f0dbd9cf1777e2b3be9fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Scope::addSymbol </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> <em>without</em> mapping it to an address. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is created and added to any name map, but no <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> objects are created for it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name of the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type to assign to the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> object </dd></dl>

<p>References <a class="el" href="classSymbol.html#a5188e6395f982732c218279809b92a8e">Symbol::Symbol()</a>.</p>

</div>
</div>
<a class="anchor" id="a66d3198f4bd28cf9e8a2a6bc00d065d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::addSymbolInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> into the name map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the preconstructed <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#af252bcb614abeea3af1750442087304a">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#add7a72e8defe6b25f13fc4ab81781a36">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a6654289ce3a02ab373eb96e78818d3ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::adjustCaches </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let scopes internally adjust any caches. </p>
<p>This is called once after <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> configuration is complete. </p>

<p>Implemented in <a class="el" href="classScopeInternal.html#a97acebc4cfd2fc9aa3c87f8b63fd07c2">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a214a1a04acaa9ef9ee58b8a3b9ef7875">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a267c957503a77a651230beedbc9f27ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::attachScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach a new child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to <b>this</b>. </p>
<p>Attach the child as an immediate sub-scope of <b>this</b>. Take responsibility of the child's memory: the child will be freed when this is freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>is the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to make a child </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>, and <a class="el" href="classScope.html#a9f1b6a027bf415a1f821a33844301188">uniqueId</a>.</p>

<p>Referenced by <a class="el" href="classDatabase.html#a1bc096166a8cfde3d77229c9e38bfabf">Database::attachScope()</a>, <a class="el" href="classDatabase.html#a24aa88e61bc432e347b28539e97c88a2">Database::findCreateScope()</a>, and <a class="el" href="classDatabase.html#a2988a943d95dd1b3f6f157543f765970">Database::restoreXmlScope()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7676c111d5ff3bd5a41643fae42e400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Scope::buildDefaultName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a default name for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. </p>
<p>Create default name given information in the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> and possibly a representative <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. This method extracts the crucial properties and then uses the buildVariableName method to construct the actual name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to name </td></tr>
    <tr><td class="paramname">base</td><td>is an index (which may get updated) used to uniquify the name </td></tr>
    <tr><td class="paramname">vn</td><td>is an optional (may be null) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> representative of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the default name </dd></dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classSymbol.html#ae27fc3f664b0edbd5cedf859acfb0707">Symbol::flags</a>, <a class="el" href="classSymbolEntry.html#a4f4f35e0eec50876be955b6f9198d68d">SymbolEntry::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classSymbol.html#acaff3459194561c00da268fcce51d3a6">Symbol::getCategory()</a>, <a class="el" href="classSymbol.html#a56484cff600a40e73878cbdf8b1bfc32">Symbol::getCategoryIndex()</a>, <a class="el" href="classSymbolEntry.html#aa30077363e5701d11b7b4a28cfbd676a">SymbolEntry::getFirstUseAddress()</a>, <a class="el" href="classVarnode.html#a436419e5a1ee0e2b2467e5b543a65596">Varnode::getFlags()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classSymbol.html#a66ff3b28898c5c12067f99fc2752585a">Symbol::getMapEntry()</a>, <a class="el" href="classSymbol.html#ad3bc7110cbcbeebbd642ba8e3342a59d">Symbol::getType()</a>, <a class="el" href="classVarnode.html#af8346f0585613d1b688fad8b8e7e3ac2">Varnode::getUsePoint()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca9c9363556459d8828a5ab58c370ccd2e">Varnode::input</a>, <a class="el" href="classVarnode.html#a6af4eb0fdeaeb2711401e8d6afc1d92f">Varnode::isAddrTied()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classHighVariable.html#a45dfe07c55cc3f046ca6b93dfdc2f36a">HighVariable::isInput()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, and <a class="el" href="classSymbol.html#a3de44fc6775fdf626f871546785b5996">Symbol::numEntries()</a>.</p>

<p>Referenced by <a class="el" href="classActionNameVars.html#aac0b5f8eea942d73f9fcdb4fca44f1bd">ActionNameVars::apply()</a>, and <a class="el" href="classScopeInternal.html#ab78d1338500ed2ef280cdf4580e8f7dc">ScopeInternal::assignDefaultNames()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c255b9739cb57e0ecf8a9ee3220f15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classScope.html">Scope</a>* Scope::buildSubScope </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build an unattached <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to be associated as a sub-scope of <b>this</b>. </p>
<p>This is a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object <em>factory</em>, intended to be called off of the global scope for building global namespace scopes. Function scopes are handled differently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the globally unique id associated with the scope </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the new scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a92ae6f2e9145b34b7e6049b7149d8431">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#af835c791921eec75cc671fa54d5370dc">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classDatabase.html#a24aa88e61bc432e347b28539e97c88a2">Database::findCreateScope()</a>.</p>

</div>
</div>
<a class="anchor" id="ac47d5c1c949be84a27a138be0febacb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Scope::buildUndefinedName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a formal <b>undefined</b> name, used internally when a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is not given a name. </p>
<dl class="section return"><dt>Returns</dt><dd>a special internal name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a4b4b4a8500764b35f8fcc6ddc98a4996">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a4de3d15aa09153a55b74281afb4608e1">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a925baecb33b6f0d9212e42c1b48a64ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Scope::buildVariableName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an address and data-type, build a suitable generic symbol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">pc</td><td>is the address at which the name is getting used </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type used to inform the name </td></tr>
    <tr><td class="paramname">index</td><td>is a reference to an index used to make the name unique, which will be updated </td></tr>
    <tr><td class="paramname">flags</td><td>are boolean properties of the variable we need the name for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new variable name </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a9eb9abe62dde9e6e729264dd3e1d88be">ScopeInternal</a>, <a class="el" href="classScopeLocal.html#aa1841cc759b77e8c1f3c1ec303b16062">ScopeLocal</a>, and <a class="el" href="classScopeGhidra.html#a2d684ce1f2d8d2e2ba66f8ecb706f444">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a0b94bbfa2b7a8391f8be410547cc67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::detachScope </td>
          <td>(</td>
          <td class="paramtype">ScopeMap::iterator&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detach a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> from <b>this</b>. </p>
<p>The indicated child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> is deleted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>points to the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to delete </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classDatabase.html#aa7b4011d64dc04148fbf342819f38da5">Database::deleteScope()</a>, and <a class="el" href="classDatabase.html#a7fcfc328de0a3f2d4ec8abdd6428213a">Database::deleteSubScopes()</a>.</p>

</div>
</div>
<a class="anchor" id="aaef5f179b42a9696fd077dbc7144ecc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * Scope::discoverScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the owning <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of a given memory range. </p>
<p>Discover a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>, that <em>owns</em> the given memory range at a specific <b>usepoint</b>. Note that ownership does not necessarily mean there is a known symbol there. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the memory range </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the memory is getting accesses </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>.</p>

</div>
</div>
<a class="anchor" id="aae4ea61f9a55ddfc9defd8548654c8e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at a given address and <b>usepoint</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a18b9e10660507653697fc9822f119293">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#ac96e9d7b372896ae4bc07db5cc60c722">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a979222d28577e6e8d07e35f12d38bff7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::findByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> by name within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>If there are multiple Symbols with the same name, all are passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
    <tr><td class="paramname">res</td><td>will contain any matching Symbols </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#aa7e3f52c398a2502d4d6dd6bb38041f9">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a9ba9493649969e2ac5520744aeae752b">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="ab679fe786be2fb949af78054cb2041a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findClosestFit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> which is the closest fit to the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a54c01264f59b3e3060ca740619b07fe3">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a5e1a61c8ea8a6524cf3dc66f6d660c56">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit()</a>.</p>

</div>
</div>
<a class="anchor" id="af4bac52b9d64974b87432c0379cc38c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLabSymbol.html">LabSymbol</a>* Scope::findCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function. ">LabSymbol</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a21403322f8f63e3c9d10a04b1ceadf03">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#add0b4446a2a4d381709055717830ed99">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel()</a>.</p>

</div>
</div>
<a class="anchor" id="a609fc1ef47d047717da65827e025cfdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> containing the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a6d320589472365d8462b9f85e752e471">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a0db95907f52049218e5d612ff337aac8">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a819b7ff38483292c7020320daa8bfdc0">Funcdata::coverVarnodes()</a>, and <a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="abc4f46e51996466b9768e0f5e0fb1b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::findDistinguishingScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first ancestor of <b>this</b> not shared by given scope. </p>
<p>Any two scopes share at least the <em>global</em> scope as a common ancestor. We find the first scope that is <em>not</em> in common. The scope returned will always be an ancestor of <b>this</b>. If <b>this</b> is an ancestor of the other given scope, then null is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the other given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first ancestor <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> that is not in common or null </dd></dl>

<p>References <a class="el" href="classScope.html#a491e95f677b001f9592269da20ee8c49">getScopePath()</a>, and <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

<p>Referenced by <a class="el" href="classSymbol.html#a641059deda7219766ba15a7d2a9a5147">Symbol::getResolutionDepth()</a>.</p>

</div>
</div>
<a class="anchor" id="af69e0f77b621a3ba6436f8a1c0010d1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a>* Scope::findExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an <em>external</em> <em>reference</em> at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location. ">ExternRefSymbol</a> or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a9d5c7815a95b2e68c4f777d051703ad3">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a81f4e7175c897d745fd5402383a054c5">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a44898a2294de74a77dd21583ca6254e2">stackExternalRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c621196f6fdb4b8ce4ee1f3dc953107"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFuncdata.html">Funcdata</a>* Scope::findFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the function starting at the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given starting address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object or NULL </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#aa9e7e81db0094cae8987fea56356af52">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a8cf9ceb7b3148cc941b883ed1ce7787f">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a3395b6194a59515caa1ede92fd6ac511"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbolEntry.html">SymbolEntry</a>* Scope::findOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> overlapping the given memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an overlapping <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> or NULL if none exists </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a46047e9ff93303ae939532c088b450e2">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a157b421f855795ac062c0df80aa3e592">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a909e15a7a96c9b402855b56b6bfdbd9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int4 Scope::getCategorySize </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Symbols in the given category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cat</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> <em>category</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number in that <em>category</em> </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#ac9df3f27386c83f30356d0dd07d45581">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#aaf9b4b65b9ce711b0b007d3f26e61da1">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classPrintC.html#af3fcfeca02664799789cf4042956ee26">PrintC::emitScopeVarDecls()</a>.</p>

</div>
</div>
<a class="anchor" id="a491a168d7ea71f00da419dd864901ccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymbol.html">Symbol</a>* Scope::getCategorySymbol </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> by index within a specific <em>category</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cat</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> <em>category</em> </td></tr>
    <tr><td class="paramname">ind</td><td>is the index (within the category) of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indicated <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> or NULL if no <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> with that index exists </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a69a2cd7a2ff77662dc94ab713ecc6b21">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a7b1c97b62666e21cb09d8fa721a0790e">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classPrintC.html#af3fcfeca02664799789cf4042956ee26">PrintC::emitScopeVarDecls()</a>.</p>

</div>
</div>
<a class="anchor" id="a491e95f677b001f9592269da20ee8c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::getScopePath </td>
          <td>(</td>
          <td class="paramtype">vector&lt; const <a class="el" href="classScope.html">Scope</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ordered list of scopes up to <b>this</b>. </p>
<p>Put the parent scopes of <b>this</b> into an array in order, starting with the global scope. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>is storage for the array of scopes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#abc4f46e51996466b9768e0f5e0fb1b86">findDistinguishingScope()</a>.</p>

</div>
</div>
<a class="anchor" id="a1457346b2f6c9e7196032a21917dd42c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8 Scope::hashScopeName </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>baseId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> id based on the scope's name and its parent's id. </p>
<p>Create a globally unique id for a scope simply from its name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseId</td><td>is the scope id of the parent scope </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the parent id and name </dd></dl>

<p>References <a class="el" href="crc32_8hh.html#a2f8ef4e0e22c330442924367a838a87c">crc_update()</a>.</p>

<p>Referenced by <a class="el" href="classDatabase.html#abb6f5f17933e01d86223321520bf5f73">Database::findCreateScopeFromSymbolName()</a>.</p>

</div>
</div>
<a class="anchor" id="a2012d7b340b2b06e2f96a103da3654bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Scope::inScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if the given range is owned by <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>All bytes in the range must be owned, and ownership can be informed by particular code that is accessing the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the code address at which the given range is being accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owns the memory range </dd></dl>

<p>References <a class="el" href="classRangeList.html#a83ace846d1d6faedd894e5756e1f7cf8">RangeList::inRange()</a>, <a class="el" href="classSymbolEntry.html#a6117b39bc8d1a12e3cba724dab6dff3f">SymbolEntry::restoreXml()</a>, <a class="el" href="classSymbolEntry.html#a37c572338ca37d0d4a2b1156aa1287b5">SymbolEntry::saveXml()</a>, <a class="el" href="classSymbolEntry.html#ae499fe31688913efaf17aed85c9de801">SymbolEntry::size</a>, and <a class="el" href="classSymbolEntry_1_1EntryInitData.html#a7ba7167497d001e8193bf33ed5f10530">SymbolEntry::EntryInitData::symbol</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a7885d1c31a74185504f2ec8647fe170e">addMap()</a>, <a class="el" href="classScope.html#aaef5f179b42a9696fd077dbc7144ecc2">discoverScope()</a>, <a class="el" href="classScope.html#a598536926659c304d35346aba6d79fa2">stackAddr()</a>, <a class="el" href="classScope.html#a4de9b51d8c57e33e9394512489539664">stackClosestFit()</a>, <a class="el" href="classScope.html#a26992d3bf69e5c2c02e57943b1355f0d">stackCodeLabel()</a>, <a class="el" href="classScope.html#a63e00dad81427a8595cf7bf13d8e1e0d">stackContainer()</a>, <a class="el" href="classScope.html#a1e0d2e90ee5d4bc7e3dc761390be5e47">stackFunction()</a>, and <a class="el" href="classFuncdata.html#aca583e76acc0a61bc30bd32461d25aee">Funcdata::syncVarnodesWithSymbols()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bc7f2e38bb4a16ad059bd1edd844dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Scope::isNameUsed </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given name is occurs within the given scope path. </p>
<p>Test for the presence of a symbol with the given name in either <b>this</b> scope or an ancestor scope up to but not including the given terminating scope. If the name is used <b>true</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the given name to test </td></tr>
    <tr><td class="paramname">op2</td><td>is the terminating ancestor scope (or null) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a53520d24168771e77df634fe3482aa4e">ScopeInternal</a>, <a class="el" href="classScopeGhidraNamespace.html#a14f9a640fa773e7448e187db76e391bb">ScopeGhidraNamespace</a>, and <a class="el" href="classScopeGhidra.html#a66cf5e91aab3a30fd856d99033022ab6">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classSymbol.html#a641059deda7219766ba15a7d2a9a5147">Symbol::getResolutionDepth()</a>, and <a class="el" href="classScopeInternal.html#a53520d24168771e77df634fe3482aa4e">ScopeInternal::isNameUsed()</a>.</p>

</div>
</div>
<a class="anchor" id="a792b7d35442a4f7b476c13bcd54f7d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scope::isReadOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given memory range marked as <em>read-only</em>. </p>
<p>Check for Symbols relative to <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> that are marked as <em>read-only</em>, and look-up properties of the memory in general. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point where the range is getting accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the memory is marked as <em>read-only</em> </dd></dl>

<p>References <a class="el" href="classSymbol.html#ae27fc3f664b0edbd5cedf859acfb0707">Symbol::flags</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca0d7f659884b50f2fa71a3d700a729258">Varnode::readonly</a>.</p>

<p>Referenced by <a class="el" href="classRulePtrsubCharConstant.html#ab5a326704b8090e54f8afc9db135fd79">RulePtrsubCharConstant::applyOp()</a>, and <a class="el" href="classPrintC.html#ac3096b61ae4a7d0e78200fa946c54a95">PrintC::pushPtrCharConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a9efed6f12d75ad6508a09a83bd990afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scope::isSubScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this a sub-scope of the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>Does the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> contain <b>this</b> as a sub-scope. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scp</td><td>is the given <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>this</b> is a sub-scope </dd></dl>

<p>References <a class="el" href="classScope.html#a2df68cab954d40b15c9e45bca324fcbc">parent</a>.</p>

</div>
</div>
<a class="anchor" id="a2e0d945c44f4874743496b2814fbb631"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Scope::makeNameUnique </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce a version of the given symbol name that won't collide with other names in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the given name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return a unique version of the name </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a3e06b7920439ca6f748f4532b43e6bed">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a28b6257504106e110db8a2a45e2f4ab8">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a0a05df4f8df1764859bec8372d64b1ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::overrideSizeLockType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> that is <em>sizelocked</em>. </p>
<p>Change (override) the data-type of a <em>sizelocked</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, while preserving the lock. An exception is thrown if the new data-type doesn't fit the size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the locked <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type to change the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classSymbol.html#a216c41864f62832227cf64f45d17bacc">Symbol::isSizeTypeLocked()</a>, and <a class="el" href="classSymbol.html#ab760cde69e8bb98988ba37871cb6fd63">Symbol::type</a>.</p>

<p>Referenced by <a class="el" href="classActionNameVars.html#a53a91b4664d417c962c55a34515d60a7">ActionNameVars::linkSymbols()</a>.</p>

</div>
</div>
<a class="anchor" id="a42106908373c17acd69e390252c041a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::queryByAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> with matching address. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>, find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> that is mapped to the given address, where the mapping is valid at a specific <b>usepoint</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which code accesses that address (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04a2a9e084183e6ec689e1ac5ca6d119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::queryByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classSymbol.html">Symbol</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up symbols by name. </p>
<p>Starting from <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, look for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> with the given name. If there are no Symbols in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, recurse into the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. If there are 1 (or more) Symbols matching in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, add them to the result list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
    <tr><td class="paramname">res</td><td>is the result list </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classScopeGhidra.html#a2ffc2304352c385e9abab05885d1e96c">ScopeGhidra::dump2Cache()</a>, and <a class="el" href="classFuncdata.html#a769d82ef92ae5cf03ebdf053f48b1871">Funcdata::findHigh()</a>.</p>

</div>
</div>
<a class="anchor" id="a83dc6d9ed629d4630a58b0a66e911f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLabSymbol.html">LabSymbol</a> * Scope::queryCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a code label by address. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>, find a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function. ">LabSymbol</a> object, or NULL if it doesn't exist </dd></dl>

<p>Referenced by <a class="el" href="classPrintC.html#ac8dc5f836c6c487956b03a55a9d8241f">PrintC::emitLabel()</a>.</p>

</div>
</div>
<a class="anchor" id="a658cdbd473ad897981a48f4b41584aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::queryContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>, find the smallest <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> that contains a given memory range and can be accessed at a given <b>usepoint</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given starting address of the memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is accessed (may be <em>invalid</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> or NULL </dd></dl>

<p>Referenced by <a class="el" href="classActionConstantPtr.html#a0b39b58be593c8416f202c6cb23868b3">ActionConstantPtr::isPointer()</a>, <a class="el" href="classFuncdata.html#a736351e8eb6c044fe00deb0cf7e6b5c5">Funcdata::linkSymbolReference()</a>, and <a class="el" href="classPrintC.html#a234b95d9f3fdb8a79eeff02eb4acbca3">PrintC::pushAnnotation()</a>.</p>

</div>
</div>
<a class="anchor" id="a865abee846f171d39b39d36474b96fae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * Scope::queryExternalRefFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a function thru an <em>external</em> <em>reference</em>. </p>
<p>Given an address, search for an <em>external</em> <em>reference</em>. If no <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is found and <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> does not own the address, recurse searching in the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. If an <em>external</em> <em>reference</em> is found, try to resolve the function it refers to and return it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address where an <em>external</em> <em>reference</em> might be </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the referred to <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object or NULL if not found </dd></dl>

<p>References <a class="el" href="classScope.html#af4c45025894f1996ef0f3556752cd997">resolveExternalRefFunction()</a>.</p>

<p>Referenced by <a class="el" href="classActionDeindirect.html#a4f54f89989ab5700bdac440960ed6fcf">ActionDeindirect::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a05c603b8ca02ead72b4aa6ea7ad1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * Scope::queryFunction </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a function by name. </p>
<p>Starting with <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, find a function with the given name. If there are no Symbols with that name in <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> at all, recurse into the parent <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>if the name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object of the matching function, or NULL if it doesn't exist </dd></dl>

<p>References <a class="el" href="classFunctionSymbol.html#ab54ed780e0dd1abdc9447c2e772114fb">FunctionSymbol::getFunction()</a>.</p>

<p>Referenced by <a class="el" href="classOptionExtraPop.html#ac80a9f1baa45d744d34e1d43e9e43a04">OptionExtraPop::apply()</a>, <a class="el" href="classOptionInline.html#a497ab996c7c25c719860d4e3f558096d">OptionInline::apply()</a>, <a class="el" href="classOptionNoReturn.html#a60586eaa31158c4be083997d425dfc8a">OptionNoReturn::apply()</a>, <a class="el" href="classActionDeindirect.html#a4f54f89989ab5700bdac440960ed6fcf">ActionDeindirect::apply()</a>, <a class="el" href="classPrintC.html#a60411f32d6cb0b986eb1f1f39296a529">PrintC::pushPtrCodeConstant()</a>, <a class="el" href="classFlowInfo.html#ad0c27096bf668d914d95033fb9971e8e">FlowInfo::queryCall()</a>, <a class="el" href="classDecompileAt.html#ae5dfee8a7e5fd8343f7cf59e53d4f78c">DecompileAt::rawAction()</a>, <a class="el" href="classScopeInternal.html#af28d7bc47d4faf0771e15028724b4d16">ScopeInternal::resolveExternalRefFunction()</a>, and <a class="el" href="classArchitecture.html#a10d78ec7be0df339288b7b3adc4c38e7">Architecture::setPrototype()</a>.</p>

</div>
</div>
<a class="anchor" id="acc6e7756d027c21483e2dea62e3e8e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncdata.html">Funcdata</a> * Scope::queryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up a function by address. </p>
<p>Within a sub-scope or containing <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>, find a function starting at the given address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object of the matching function, or NULL if it doesn't exist </dd></dl>

</div>
</div>
<a class="anchor" id="a81a607e1ba8c2cc85a14b84a1c86944e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> * Scope::queryProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> or properties at the given address. </p>
<p>Similarly to <a class="el" href="classScope.html#a658cdbd473ad897981a48f4b41584aaf" title="Find the smallest containing Symbol. ">queryContainer()</a>, this searches for the smallest containing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, but whether a known <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is found or not, boolean properties associated with the memory range are also search for and passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is a point at which the memory range is accessed (may be <em>invalid</em>) </td></tr>
    <tr><td class="paramname">flags</td><td>is a reference used to pass back the boolean properties of the memory range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> containing the range, or NULL </dd></dl>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca7d4bde53093050741edab33ff1b80b0a">Varnode::addrtied</a>, <a class="el" href="classSymbolEntry.html#ac517c7893243db29758dff59f7615542">SymbolEntry::getAllFlags()</a>, <a class="el" href="classScope.html#aa66098c4a665995b7fa4335028b6e8d8">isGlobal()</a>, <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca6512f0039b21ce7e6586f14d3b1bd9a2">Varnode::mapped</a>, and <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca952005b91ba1b04e4d431eecb1309112">Varnode::persist</a>.</p>

<p>Referenced by <a class="el" href="classTypeOpCallother.html#afa51f75fed3afaa255cf7a2ce7accdec">TypeOpCallother::getInputLocal()</a>, <a class="el" href="classTypeOpCallother.html#a298242b127388e1ae50e2882d80da826">TypeOpCallother::getOutputLocal()</a>, <a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">Funcdata::linkSymbol()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, and <a class="el" href="classFuncdata.html#af7412778106b02b163e6d685deb826db">Funcdata::setVarnodeProperties()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1b4a9faa5d12ef3b0be55810dac6d35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::removeRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a memory range from the ownership of <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space of the range </td></tr>
    <tr><td class="paramname">first</td><td>is the offset of the first byte in the range </td></tr>
    <tr><td class="paramname">last</td><td>is the offset of the last byte in the range </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#a6a418b9b4ee25fbda17df511c61bebb8">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classDatabase.html#a4db50bb44cfc56d4102f102c0ddbf423">Database::removeRange()</a>.</p>

</div>
</div>
<a class="anchor" id="a4af52229967e3a507a5367e14a298142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::resetSizeLockType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>'s <em>size-locked</em> data-type. </p>
<p>Replace any overriding data-type type with the locked UNKNOWN type of the correct size. The data-type is <em>cleared</em>, but the lock is preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to clear </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classSymbol.html#ab760cde69e8bb98988ba37871cb6fd63">Symbol::type</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="classScopeInternal.html#ab95e3712f0b536e014bfb3c8d3d2287a">ScopeInternal::clearUnlocked()</a>, and <a class="el" href="classScopeInternal.html#ac73cc9a432d1e7a383c9758486ffe58d">ScopeInternal::clearUnlockedCategory()</a>.</p>

</div>
</div>
<a class="anchor" id="af4c45025894f1996ef0f3556752cd997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFuncdata.html">Funcdata</a>* Scope::resolveExternalRefFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an <em>external</em> <em>reference</em> to the referenced function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> marking the external reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object or NULL if none exists </dd></dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#af28d7bc47d4faf0771e15028724b4d16">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#afe0351fe5556eb530f9d8b564d0b5105">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScope.html#a865abee846f171d39b39d36474b96fae">queryExternalRefFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a26deba0c14204470aa92b6f131aaccb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScope.html">Scope</a> * Scope::resolveScope </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> of <b>this</b>. </p>
<p>Look for the immediate child of <b>this</b> with a given name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the child's name </td></tr>
    <tr><td class="paramname">strategy</td><td>is <b>true</b> if hash of the name determines id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> or NULL if there is no child with that name </dd></dl>

<p>References <a class="el" href="classScope.html#abb4900f6409e8a82c1b1cea827e4e2c5">name</a>, and <a class="el" href="classSymbol.html#a25a177c969ab3aa6b2bbd6e817deb0f4">Symbol::scope</a>.</p>

<p>Referenced by <a class="el" href="classDatabase.html#a24aa88e61bc432e347b28539e97c88a2">Database::findCreateScope()</a>, <a class="el" href="classDatabase.html#a4ed3874c371ff67e8c89781494ad96a6">Database::parseParentTag()</a>, and <a class="el" href="classDatabase.html#aa40620b00c826326ce2304b8f37b9c04">Database::resolveScopeFromSymbolName()</a>.</p>

</div>
</div>
<a class="anchor" id="a21556c257fbea888f9004c654599dfe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::restrictScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <b>this</b> to a local <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>Attach <b>this</b> to the given function, which makes <b>this</b> the local scope for the function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>is the given function to attach to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classScopeGhidra.html#a0de93cdd506ae1490d939b957738f656">ScopeGhidra</a>.</p>

<p>Referenced by <a class="el" href="classScopeLocal.html#a549766191cb3b272c7c5c05d1f6a9ff9">ScopeLocal::ScopeLocal()</a>.</p>

</div>
</div>
<a class="anchor" id="afeef6a133b07fa176c08b67c44064e69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::retypeSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the data-type of a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> within <b>this</b> <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>. </p>
<p>If the size of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> changes, any mapping (<a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>) is adjusted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is the new data-type </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#a9711a8084e1ac5c4417a4452c96a36b7">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#a086054a08a1916c410fa10b3e8afca76">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="aaa986065e802ab19dd807b76ea1a835b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scope::saveXmlRecursive </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyGlobal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save all contained scopes as an XML stream. </p>
<p>This <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> and all of its sub-scopes are saved as a sequence of &lt;scope&gt; tags in post order. For each <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, the <a class="el" href="classScope.html#a2583da1be37d68197dfbb0445fa1f3e0" title="Write out this as a &lt;scope&gt; XML tag. ">saveXml()</a> method is invoked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
    <tr><td class="paramname">onlyGlobal</td><td>is <b>true</b> if only non-local Scopes should be saved </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classExternRefSymbol.html#a0c0dc8fde73e989e595c77986eebc63f">ExternRefSymbol::saveXml()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ad23142354572370c67625649f5119c8a">Funcdata::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="ac807e11df36854d2f7983bdd6779e83a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Scope::setCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>cat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <em>category</em> and index for the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym</td><td>is the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">cat</td><td>is the <em>category</em> to set for the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
    <tr><td class="paramname">ind</td><td>is the index position to set (within the category) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classScopeInternal.html#aee7ec7a7253a5cdcfa61b88f01e9918d">ScopeInternal</a>, and <a class="el" href="classScopeGhidra.html#aafecf1b8615812bdbd8efeca910594a2">ScopeGhidra</a>.</p>

</div>
</div>
<a class="anchor" id="a598536926659c304d35346aba6d79fa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackAddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query for Symbols starting at a given address, which match a given <b>usepoint</b>. </p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> <em>controls</em> the memory at that address, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object is returned. Additionally, if a symbol matching the criterion is found, the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address to search for </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the given point at which the memory is being accessed (can be an invalid address) </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owning the address or NULL if none found </dd></dl>

<p>References <a class="el" href="classScope.html#aae4ea61f9a55ddfc9defd8548654c8e5">findAddr()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a4de9b51d8c57e33e9394512489539664"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackClosestFit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> which most closely matches a given range and <b>usepoint</b> </p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object is returned. Among symbols that overlap the given range, the <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> which most closely matches the starting address and size is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the memory is being accessed (can be an invalid address) </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owning the address or NULL if none found </dd></dl>

<p>References <a class="el" href="classScope.html#ab679fe786be2fb949af78054cb2041a8">findClosestFit()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a26992d3bf69e5c2c02e57943b1355f0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackCodeLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLabSymbol.html">LabSymbol</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a label <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> for a given address.</p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object is returned. If there is a label at that address, pass back the corresponding <a class="el" href="classLabSymbol.html" title="A Symbol that labels code internal to a function. ">LabSymbol</a> object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owning the address or NULL if none found </dd></dl>

<p>References <a class="el" href="classScope.html#af4bac52b9d64974b87432c0379cc38c6">findCodeLabel()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a63e00dad81427a8595cf7bf13d8e1e0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> containing a given range which is accessed at a given <b>usepoint</b> </p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object is returned. If a known <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> contains the range, the matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the point at which the memory is being accessed (can be an invalid address) </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owning the address or NULL if none found </dd></dl>

<p>References <a class="el" href="classScope.html#a609fc1ef47d047717da65827e025cfdd">findContainer()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a44898a2294de74a77dd21583ca6254e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackExternalRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classExternRefSymbol.html">ExternRefSymbol</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for an <em>external</em> <em>reference</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> starting at the given address</p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object is returned. If an <em>external</em> <em>reference</em> is found at the address, pass back the matching <a class="el" href="classExternRefSymbol.html" title="A function Symbol referring to an external location. ">ExternRefSymbol</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owning the address or NULL if none found </dd></dl>

<p>References <a class="el" href="classScope.html#af69e0f77b621a3ba6436f8a1c0010d1c">findExternalRef()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e0d2e90ee5d4bc7e3dc761390be5e47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classScope.html">Scope</a> * Scope::stackFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> **&#160;</td>
          <td class="paramname"><em>addrmatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query for a function <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> starting at the given address</p>
<p>Searching starts at a first scope, continuing thru parents up to a second scope, which is not queried. If a <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> <em>controls</em> the memory in the given range, the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> object is returned. If a <a class="el" href="classFunctionSymbol.html" title="A Symbol representing an executable function. ">FunctionSymbol</a> is found at the given address, the corresponding <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope1</td><td>is the first <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching starts </td></tr>
    <tr><td class="paramname">scope2</td><td>is the second <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> where searching ends </td></tr>
    <tr><td class="paramname">addr</td><td>is the given address where the function should start </td></tr>
    <tr><td class="paramname">addrmatch</td><td>is used to pass-back any matching function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> owning the address or NULL if none found </dd></dl>

<p>References <a class="el" href="classScope.html#a2c621196f6fdb4b8ce4ee1f3dc953107">findFunction()</a>, <a class="el" href="classScope.html#af40c99093bd5fc683aa63b9e4bf7daa2">getParent()</a>, <a class="el" href="classScope.html#a2012d7b340b2b06e2f96a103da3654bd">inScope()</a>, and <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>.</p>

<p>Referenced by <a class="el" href="classScopeGhidra.html#afe0351fe5556eb530f9d8b564d0b5105">ScopeGhidra::resolveExternalRefFunction()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="database_8hh.html">database.hh</a></li>
<li>database.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
