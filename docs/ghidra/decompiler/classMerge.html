<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: Merge Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMerge-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Merge Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for merging low-level Varnodes into high-level HighVariables.  
 <a href="classMerge.html#details">More...</a></p>

<p><code>#include &lt;merge.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad96bd04ca6c3bd22347ef0cf01f027c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96bd04ca6c3bd22347ef0cf01f027c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ad96bd04ca6c3bd22347ef0cf01f027c2">Merge</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;fd)</td></tr>
<tr class="memdesc:ad96bd04ca6c3bd22347ef0cf01f027c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct given a specific function. <br /></td></tr>
<tr class="separator:ad96bd04ca6c3bd22347ef0cf01f027c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0c74b3892b9724fd4091a126631089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#abc0c74b3892b9724fd4091a126631089">intersection</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *a, <a class="el" href="classHighVariable.html">HighVariable</a> *b)</td></tr>
<tr class="memdesc:abc0c74b3892b9724fd4091a126631089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the intersection of two HighVariables and cache the result.  <a href="#abc0c74b3892b9724fd4091a126631089">More...</a><br /></td></tr>
<tr class="separator:abc0c74b3892b9724fd4091a126631089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682cf4cedcb80161fa47a1f0c7382a77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a682cf4cedcb80161fa47a1f0c7382a77">inflateTest</a> (<a class="el" href="classVarnode.html">Varnode</a> *a, <a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:a682cf4cedcb80161fa47a1f0c7382a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if we can inflate the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> without incurring intersections.  <a href="#a682cf4cedcb80161fa47a1f0c7382a77">More...</a><br /></td></tr>
<tr class="separator:a682cf4cedcb80161fa47a1f0c7382a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157b6a6d44e6aec22f1bb77201f3e402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a157b6a6d44e6aec22f1bb77201f3e402">inflate</a> (<a class="el" href="classVarnode.html">Varnode</a> *a, <a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:a157b6a6d44e6aec22f1bb77201f3e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inflate the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> of a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#a157b6a6d44e6aec22f1bb77201f3e402">More...</a><br /></td></tr>
<tr class="separator:a157b6a6d44e6aec22f1bb77201f3e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819c900aaa428a745faa59335bf0b69e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a819c900aaa428a745faa59335bf0b69e">mergeTest</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high, vector&lt; <a class="el" href="classHighVariable.html">HighVariable</a> * &gt; &amp;tmplist)</td></tr>
<tr class="memdesc:a819c900aaa428a745faa59335bf0b69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for intersections between a given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> and a list of other HighVariables.  <a href="#a819c900aaa428a745faa59335bf0b69e">More...</a><br /></td></tr>
<tr class="separator:a819c900aaa428a745faa59335bf0b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55762a93af96a7e8abab70b169302b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a55762a93af96a7e8abab70b169302b59">mergeOpcode</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc)</td></tr>
<tr class="memdesc:a55762a93af96a7e8abab70b169302b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to force merges of input to output for all p-code ops of a given type.  <a href="#a55762a93af96a7e8abab70b169302b59">More...</a><br /></td></tr>
<tr class="separator:a55762a93af96a7e8abab70b169302b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319ac2d65a6dff86cbfda772d047b2e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a319ac2d65a6dff86cbfda772d047b2e1">mergeByDatatype</a> (VarnodeLocSet::const_iterator startiter, VarnodeLocSet::const_iterator enditer)</td></tr>
<tr class="memdesc:a319ac2d65a6dff86cbfda772d047b2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to merge all HighVariables in the given range that have the same data-type.  <a href="#a319ac2d65a6dff86cbfda772d047b2e1">More...</a><br /></td></tr>
<tr class="separator:a319ac2d65a6dff86cbfda772d047b2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8045c24ce73080b02d4506f2047a414e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a8045c24ce73080b02d4506f2047a414e">mergeAddrTied</a> (void)</td></tr>
<tr class="memdesc:a8045c24ce73080b02d4506f2047a414e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the merge of <em>address</em> <em>tried</em> Varnodes.  <a href="#a8045c24ce73080b02d4506f2047a414e">More...</a><br /></td></tr>
<tr class="separator:a8045c24ce73080b02d4506f2047a414e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf63d8d5400410d06ef4aa250275a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#aedcf63d8d5400410d06ef4aa250275a1">mergeMarker</a> (void)</td></tr>
<tr class="memdesc:aedcf63d8d5400410d06ef4aa250275a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the merge of input and output Varnodes to MULTIEQUAL and INDIRECT ops.  <a href="#aedcf63d8d5400410d06ef4aa250275a1">More...</a><br /></td></tr>
<tr class="separator:aedcf63d8d5400410d06ef4aa250275a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f377000da91c9e50b89307fa88d268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a79f377000da91c9e50b89307fa88d268">mergeAdjacent</a> (void)</td></tr>
<tr class="memdesc:a79f377000da91c9e50b89307fa88d268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speculatively merge Varnodes that are input/output to the same p-code op.  <a href="#a79f377000da91c9e50b89307fa88d268">More...</a><br /></td></tr>
<tr class="separator:a79f377000da91c9e50b89307fa88d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07666baf4d4fb03ee2243d22f15c25d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ab07666baf4d4fb03ee2243d22f15c25d">mergeMultiEntry</a> (void)</td></tr>
<tr class="memdesc:ab07666baf4d4fb03ee2243d22f15c25d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> together Varnodes mapped to SymbolEntrys from the same <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.  <a href="#ab07666baf4d4fb03ee2243d22f15c25d">More...</a><br /></td></tr>
<tr class="separator:ab07666baf4d4fb03ee2243d22f15c25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1f01b80297db3a5c37c9860af56162"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#abb1f01b80297db3a5c37c9860af56162">hideShadows</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:abb1f01b80297db3a5c37c9860af56162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide <em>shadow</em> Varnodes related to the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> by consolidating COPY chains.  <a href="#abb1f01b80297db3a5c37c9860af56162">More...</a><br /></td></tr>
<tr class="separator:abb1f01b80297db3a5c37c9860af56162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af9c332a00eee4f51242239e05bc916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a0af9c332a00eee4f51242239e05bc916">processCopyTrims</a> (void)</td></tr>
<tr class="memdesc:a0af9c332a00eee4f51242239e05bc916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reduce/eliminate COPYs produced by the merge trimming process.  <a href="#a0af9c332a00eee4f51242239e05bc916">More...</a><br /></td></tr>
<tr class="separator:a0af9c332a00eee4f51242239e05bc916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49b387659a09e702cb70cacb050ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a6f49b387659a09e702cb70cacb050ec1">markInternalCopies</a> (void)</td></tr>
<tr class="memdesc:a6f49b387659a09e702cb70cacb050ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark redundant/internal COPY PcodeOps.  <a href="#a6f49b387659a09e702cb70cacb050ec1">More...</a><br /></td></tr>
<tr class="separator:a6f49b387659a09e702cb70cacb050ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4681c941b4008d37b923d3e93de9d8c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a4681c941b4008d37b923d3e93de9d8c6">updateHigh</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *a)</td></tr>
<tr class="memdesc:a4681c941b4008d37b923d3e93de9d8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>'s <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is up-to-date.  <a href="#a4681c941b4008d37b923d3e93de9d8c6">More...</a><br /></td></tr>
<tr class="separator:a4681c941b4008d37b923d3e93de9d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafc0f8f2f67d2f8ca22a2825689fa04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#adafc0f8f2f67d2f8ca22a2825689fa04">purgeHigh</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:adafc0f8f2f67d2f8ca22a2825689fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove cached intersection tests for a given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#adafc0f8f2f67d2f8ca22a2825689fa04">More...</a><br /></td></tr>
<tr class="separator:adafc0f8f2f67d2f8ca22a2825689fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122a1fdc40ffaa63021fa7e4c2d3098b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a122a1fdc40ffaa63021fa7e4c2d3098b">blockIntersection</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *a, <a class="el" href="classHighVariable.html">HighVariable</a> *b, int4 blk)</td></tr>
<tr class="memdesc:a122a1fdc40ffaa63021fa7e4c2d3098b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two HighVariables intersect on a given <a class="el" href="classBlockBasic.html" title="A basic block for p-code operations. ">BlockBasic</a>.  <a href="#a122a1fdc40ffaa63021fa7e4c2d3098b">More...</a><br /></td></tr>
<tr class="separator:a122a1fdc40ffaa63021fa7e4c2d3098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdb5ed89b9fb452c6db424ae0950643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a4bdb5ed89b9fb452c6db424ae0950643">collectCovering</a> (vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;vlist, <a class="el" href="classHighVariable.html">HighVariable</a> *high, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a4bdb5ed89b9fb452c6db424ae0950643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all instances of the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> whose <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersects a p-code op.  <a href="#a4bdb5ed89b9fb452c6db424ae0950643">More...</a><br /></td></tr>
<tr class="separator:a4bdb5ed89b9fb452c6db424ae0950643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4138fed84af36a22f910a25f19ea8388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a4138fed84af36a22f910a25f19ea8388">collectCorrectable</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;vlist, list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;oplist, vector&lt; int4 &gt; &amp;slotlist, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a4138fed84af36a22f910a25f19ea8388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for for p-code op intersections that are correctable.  <a href="#a4138fed84af36a22f910a25f19ea8388">More...</a><br /></td></tr>
<tr class="separator:a4138fed84af36a22f910a25f19ea8388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab56bf8d09596f82011706d0d4fe0e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#adab56bf8d09596f82011706d0d4fe0e2">allocateCopyTrim</a> (<a class="el" href="classVarnode.html">Varnode</a> *inVn, <a class="el" href="classDatatype.html">Datatype</a> *ct, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:adab56bf8d09596f82011706d0d4fe0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate COPY <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> designed to trim an overextended <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a>.  <a href="#adab56bf8d09596f82011706d0d4fe0e2">More...</a><br /></td></tr>
<tr class="separator:adab56bf8d09596f82011706d0d4fe0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4bf8ba9957e00395cc4bffd1ce7be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#abd4bf8ba9957e00395cc4bffd1ce7be9">snipReads</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;markedop)</td></tr>
<tr class="memdesc:abd4bf8ba9957e00395cc4bffd1ce7be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snip off set of <em>read</em> p-code ops for a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#abd4bf8ba9957e00395cc4bffd1ce7be9">More...</a><br /></td></tr>
<tr class="separator:abd4bf8ba9957e00395cc4bffd1ce7be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9f8217c0d75e97ca3b72d3318cb56c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#abd9f8217c0d75e97ca3b72d3318cb56c">snipIndirect</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indop)</td></tr>
<tr class="memdesc:abd9f8217c0d75e97ca3b72d3318cb56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snip instances of the input of an INDIRECT op that interfere with its output.  <a href="#abd9f8217c0d75e97ca3b72d3318cb56c">More...</a><br /></td></tr>
<tr class="separator:abd9f8217c0d75e97ca3b72d3318cb56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b1de9ce31619d3268dbaa3e5145d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ac6b1de9ce31619d3268dbaa3e5145d67">eliminateIntersect</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const vector&lt; <a class="el" href="classBlockVarnode.html">BlockVarnode</a> &gt; &amp;blocksort)</td></tr>
<tr class="memdesc:ac6b1de9ce31619d3268dbaa3e5145d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate intersections of given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with other Varnodes in a list.  <a href="#ac6b1de9ce31619d3268dbaa3e5145d67">More...</a><br /></td></tr>
<tr class="separator:ac6b1de9ce31619d3268dbaa3e5145d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35e529686073ce77f319755cfd868c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ae35e529686073ce77f319755cfd868c7">unifyAddress</a> (VarnodeLocSet::const_iterator startiter, VarnodeLocSet::const_iterator enditer)</td></tr>
<tr class="memdesc:ae35e529686073ce77f319755cfd868c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure all Varnodes with the same storage address and size can be merged.  <a href="#ae35e529686073ce77f319755cfd868c7">More...</a><br /></td></tr>
<tr class="separator:ae35e529686073ce77f319755cfd868c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d548f10858bf63371a5073b21ee4d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a8d548f10858bf63371a5073b21ee4d22">trimOpOutput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a8d548f10858bf63371a5073b21ee4d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim the output <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> of the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> so that its <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is tiny.  <a href="#a8d548f10858bf63371a5073b21ee4d22">More...</a><br /></td></tr>
<tr class="separator:a8d548f10858bf63371a5073b21ee4d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e038739e621d6028f4b08823e74a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#af3e038739e621d6028f4b08823e74a80">trimOpInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot)</td></tr>
<tr class="memdesc:af3e038739e621d6028f4b08823e74a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim the input <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> of the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> so that its <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is tiny.  <a href="#af3e038739e621d6028f4b08823e74a80">More...</a><br /></td></tr>
<tr class="separator:af3e038739e621d6028f4b08823e74a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1be534bc0d2ed6824c0c909d627dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a6b1be534bc0d2ed6824c0c909d627dcd">mergeRangeMust</a> (VarnodeLocSet::const_iterator startiter, VarnodeLocSet::const_iterator enditer)</td></tr>
<tr class="memdesc:a6b1be534bc0d2ed6824c0c909d627dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the merge of a ranges of Varnodes with the same size and storage address.  <a href="#a6b1be534bc0d2ed6824c0c909d627dcd">More...</a><br /></td></tr>
<tr class="separator:a6b1be534bc0d2ed6824c0c909d627dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98788700ee91acef7ffc470bc1fad79a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a98788700ee91acef7ffc470bc1fad79a">mergeOp</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a98788700ee91acef7ffc470bc1fad79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the merge of all input and output Varnodes for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a98788700ee91acef7ffc470bc1fad79a">More...</a><br /></td></tr>
<tr class="separator:a98788700ee91acef7ffc470bc1fad79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957608caea903bbc3864bd0307ccd8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a957608caea903bbc3864bd0307ccd8e4">mergeIndirect</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indop)</td></tr>
<tr class="memdesc:a957608caea903bbc3864bd0307ccd8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the merge of all input and output Varnodes to a given INDIRECT op.  <a href="#a957608caea903bbc3864bd0307ccd8e4">More...</a><br /></td></tr>
<tr class="separator:a957608caea903bbc3864bd0307ccd8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bb73c63d9c91f9c53cc513e51eb29a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a20bb73c63d9c91f9c53cc513e51eb29a">mergeLinear</a> (vector&lt; <a class="el" href="classHighVariable.html">HighVariable</a> * &gt; &amp;highvec)</td></tr>
<tr class="memdesc:a20bb73c63d9c91f9c53cc513e51eb29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speculatively merge all HighVariables in the given list as well as possible.  <a href="#a20bb73c63d9c91f9c53cc513e51eb29a">More...</a><br /></td></tr>
<tr class="separator:a20bb73c63d9c91f9c53cc513e51eb29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ed07599f26d398f26ac38e02dc30a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ac7ed07599f26d398f26ac38e02dc30a7">merge</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high1, <a class="el" href="classHighVariable.html">HighVariable</a> *high2, bool isspeculative)</td></tr>
<tr class="memdesc:ac7ed07599f26d398f26ac38e02dc30a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform low-level details of merging two HighVariables if possible.  <a href="#ac7ed07599f26d398f26ac38e02dc30a7">More...</a><br /></td></tr>
<tr class="separator:ac7ed07599f26d398f26ac38e02dc30a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4495a61b82b7e8c45c3fffb6a8e1740"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ab4495a61b82b7e8c45c3fffb6a8e1740">checkCopyPair</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high, <a class="el" href="classPcodeOp.html">PcodeOp</a> *domOp, <a class="el" href="classPcodeOp.html">PcodeOp</a> *subOp)</td></tr>
<tr class="memdesc:ab4495a61b82b7e8c45c3fffb6a8e1740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> COPYs are redundant.  <a href="#ab4495a61b82b7e8c45c3fffb6a8e1740">More...</a><br /></td></tr>
<tr class="separator:ab4495a61b82b7e8c45c3fffb6a8e1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac031361f4255e9cab211aef939ffbea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ac031361f4255e9cab211aef939ffbea8">buildDominantCopy</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;copy, int4 pos, int4 size)</td></tr>
<tr class="memdesc:ac031361f4255e9cab211aef939ffbea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to replace a set of COPYs from the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a single dominant COPY.  <a href="#ac031361f4255e9cab211aef939ffbea8">More...</a><br /></td></tr>
<tr class="separator:ac031361f4255e9cab211aef939ffbea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c58ad9d6ab54d086e0f3a656ae5d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a72c58ad9d6ab54d086e0f3a656ae5d50">markRedundantCopies</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;copy, int4 pos, int4 size)</td></tr>
<tr class="memdesc:a72c58ad9d6ab54d086e0f3a656ae5d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for and mark redundant COPY ops into the given high as <em>non-printing</em>.  <a href="#a72c58ad9d6ab54d086e0f3a656ae5d50">More...</a><br /></td></tr>
<tr class="separator:a72c58ad9d6ab54d086e0f3a656ae5d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc05b843ebb1a5cc15c0791b8d7c87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#afbcc05b843ebb1a5cc15c0791b8d7c87">processHighDominantCopy</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:afbcc05b843ebb1a5cc15c0791b8d7c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to replace COPYs into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> with a single dominant COPY.  <a href="#afbcc05b843ebb1a5cc15c0791b8d7c87">More...</a><br /></td></tr>
<tr class="separator:afbcc05b843ebb1a5cc15c0791b8d7c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dca8700a975a7a43af2bc4c27cd3fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a20dca8700a975a7a43af2bc4c27cd3fc">processHighRedundantCopy</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:a20dca8700a975a7a43af2bc4c27cd3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark COPY ops into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> that are redundant.  <a href="#a20dca8700a975a7a43af2bc4c27cd3fc">More...</a><br /></td></tr>
<tr class="separator:a20dca8700a975a7a43af2bc4c27cd3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ae7bd7bdda4f0fb983c5b075fdd9cbb5f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ae7bd7bdda4f0fb983c5b075fdd9cbb5f">mergeTestRequired</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high_out, <a class="el" href="classHighVariable.html">HighVariable</a> *high_in)</td></tr>
<tr class="memdesc:ae7bd7bdda4f0fb983c5b075fdd9cbb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required tests to merge HighVariables that are not <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> related.  <a href="#ae7bd7bdda4f0fb983c5b075fdd9cbb5f">More...</a><br /></td></tr>
<tr class="separator:ae7bd7bdda4f0fb983c5b075fdd9cbb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ab9571ded34aa3a5c2a8b80ce7597"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#add5ab9571ded34aa3a5c2a8b80ce7597">mergeTestAdjacent</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high_out, <a class="el" href="classHighVariable.html">HighVariable</a> *high_in)</td></tr>
<tr class="memdesc:add5ab9571ded34aa3a5c2a8b80ce7597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacency tests for merging Varnodes that are input or output to the same p-code op.  <a href="#add5ab9571ded34aa3a5c2a8b80ce7597">More...</a><br /></td></tr>
<tr class="separator:add5ab9571ded34aa3a5c2a8b80ce7597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7f2a861e227445d10225d86c29249a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#add7f2a861e227445d10225d86c29249a">mergeTestSpeculative</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high_out, <a class="el" href="classHighVariable.html">HighVariable</a> *high_in)</td></tr>
<tr class="memdesc:add7f2a861e227445d10225d86c29249a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speculative tests for merging HighVariables that are not <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> related.  <a href="#add7f2a861e227445d10225d86c29249a">More...</a><br /></td></tr>
<tr class="separator:add7f2a861e227445d10225d86c29249a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e5aec8b0f32a02e0895b34401d7ac8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a69e5aec8b0f32a02e0895b34401d7ac8">mergeTestBasic</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a69e5aec8b0f32a02e0895b34401d7ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can ever be merged.  <a href="#a69e5aec8b0f32a02e0895b34401d7ac8">More...</a><br /></td></tr>
<tr class="separator:a69e5aec8b0f32a02e0895b34401d7ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6b87696a64ca6adea5541c5b649bf5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#adb6b87696a64ca6adea5541c5b649bf5">findSingleCopy</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;singlelist)</td></tr>
<tr class="memdesc:adb6b87696a64ca6adea5541c5b649bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find instance Varnodes that copied to from outside the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#adb6b87696a64ca6adea5541c5b649bf5">More...</a><br /></td></tr>
<tr class="separator:adb6b87696a64ca6adea5541c5b649bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb111381fd927283987f2ff6768bfbef"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#acb111381fd927283987f2ff6768bfbef">compareHighByBlock</a> (const <a class="el" href="classHighVariable.html">HighVariable</a> *a, const <a class="el" href="classHighVariable.html">HighVariable</a> *b)</td></tr>
<tr class="memdesc:acb111381fd927283987f2ff6768bfbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare HighVariables by the blocks they cover.  <a href="#acb111381fd927283987f2ff6768bfbef">More...</a><br /></td></tr>
<tr class="separator:acb111381fd927283987f2ff6768bfbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab564defb6f5595eaa31e4e16e0230069"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ab564defb6f5595eaa31e4e16e0230069">compareCopyByInVarnode</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op1, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op2)</td></tr>
<tr class="memdesc:ab564defb6f5595eaa31e4e16e0230069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare COPY ops first by <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> input, then by block containing the op.  <a href="#ab564defb6f5595eaa31e4e16e0230069">More...</a><br /></td></tr>
<tr class="separator:ab564defb6f5595eaa31e4e16e0230069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fcbb0d0d742417197d2c416e3b728a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ad1fcbb0d0d742417197d2c416e3b728a">shadowedVarnode</a> (const <a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:ad1fcbb0d0d742417197d2c416e3b728a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is shadowed by another <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the same <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#ad1fcbb0d0d742417197d2c416e3b728a">More...</a><br /></td></tr>
<tr class="separator:ad1fcbb0d0d742417197d2c416e3b728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b5dc92d1a9b9dd84bece1c4cf8e7d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#ad0b5dc92d1a9b9dd84bece1c4cf8e7d9">findAllIntoCopies</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high, vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;copyIns, bool filterTemps)</td></tr>
<tr class="memdesc:ad0b5dc92d1a9b9dd84bece1c4cf8e7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the COPY ops into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#ad0b5dc92d1a9b9dd84bece1c4cf8e7d9">More...</a><br /></td></tr>
<tr class="separator:ad0b5dc92d1a9b9dd84bece1c4cf8e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a267d4b45c36ffe4629a47ee0f4a862ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a267d4b45c36ffe4629a47ee0f4a862ac"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a267d4b45c36ffe4629a47ee0f4a862ac">data</a></td></tr>
<tr class="memdesc:a267d4b45c36ffe4629a47ee0f4a862ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function containing the Varnodes to be merged. <br /></td></tr>
<tr class="separator:a267d4b45c36ffe4629a47ee0f4a862ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905d644dbd4bf1b3f18d90bd1e266f77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a905d644dbd4bf1b3f18d90bd1e266f77"></a>
map&lt; <a class="el" href="classHighEdge.html">HighEdge</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a905d644dbd4bf1b3f18d90bd1e266f77">highedgemap</a></td></tr>
<tr class="memdesc:a905d644dbd4bf1b3f18d90bd1e266f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cache of intersection tests, sorted by <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> pair. <br /></td></tr>
<tr class="separator:a905d644dbd4bf1b3f18d90bd1e266f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1da8c96bd43a08d1e32558ad055778"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b1da8c96bd43a08d1e32558ad055778"></a>
vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMerge.html#a5b1da8c96bd43a08d1e32558ad055778">copyTrims</a></td></tr>
<tr class="memdesc:a5b1da8c96bd43a08d1e32558ad055778"><td class="mdescLeft">&#160;</td><td class="mdescRight">COPY ops inserted to facilitate merges. <br /></td></tr>
<tr class="separator:a5b1da8c96bd43a08d1e32558ad055778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for merging low-level Varnodes into high-level HighVariables. </p>
<p>As a node in Single Static Assignment (SSA) form, a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has at most one defining operation. To get a suitable notion of a single high-level variable (<a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>) that may be reassigned at multiple places in a single function, individual <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> objects can be <em>merged</em> into a <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> object. <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> objects may be merged in this way if there is no pairwise intersection between each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>'s <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a>, the ranges of code where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holds its value.</p>
<p>For a given function, this class attempts to merge Varnodes using various strategies and keeps track of <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections to facilitate the process. <a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> strategies break up into two general categories: <b>forced</b> merges, and <b>speculative</b> merges. Forced merges <em>must</em> happen, and extra Varnodes may be added to split up problematic covers to enforce it. Forced merges include:</p><ul>
<li>Merging inputs and outputs of MULTIEQUAL and INDIRECT operations</li>
<li>Merging Varnodes at global (persistent) storage locations</li>
<li>Merging Varnodes at mapped stack locations</li>
</ul>
<p>Speculative merges are attempted to reduce the overall number of variables defined by a function, but any given merge attempt is abandoned if there are <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections. No modification is made to the data-flow to force the merge. Speculative merges include:</p><ul>
<li>Merging an input and output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of a single p-code op</li>
<li>Merging Varnodes that hold the same data-type </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adab56bf8d09596f82011706d0d4fe0e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Merge::allocateCopyTrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>inVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate COPY <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> designed to trim an overextended <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a>. </p>
<p>A COPY is allocated with the given input and data-type. A <em>unique</em> space output is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVn</td><td>is the given input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for the new COPY </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type to assign to the new unique output </td></tr>
    <tr><td class="paramname">addr</td><td>is the address associated with the new COPY </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated COPY </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, and <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a122a1fdc40ffaa63021fa7e4c2d3098b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::blockIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>blk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if two HighVariables intersect on a given <a class="el" href="classBlockBasic.html" title="A basic block for p-code operations. ">BlockBasic</a>. </p>
<p>Intersections are checked only on the specified block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">b</td><td>is the second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">blk</td><td>is the index of the <a class="el" href="classBlockBasic.html" title="A basic block for p-code operations. ">BlockBasic</a> on which to test intersection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if an intersection occurs in the specified block </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab7c2177c35f97bf23055432ce128e303">Varnode::copyShadow()</a>, <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classCover.html#a8216a79fe56a09ddd66ce0ae5e90dda1">Cover::intersectByBlock()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>, and <a class="el" href="classHighVariable.html#a469a89c413cd961dd23ceabf9f827c07">HighVariable::wholecover</a>.</p>

</div>
</div>
<a class="anchor" id="ac031361f4255e9cab211aef939ffbea8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::buildDominantCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to replace a set of COPYs from the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a single dominant COPY. </p>
<p>All the COPY outputs must be instances of the same <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> (not the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>). Either an existing COPY dominates all the others, or a new dominating COPY is constructed. The read locations of all other COPY outputs are replaced with the output of the dominating COPY, if it does not cause intersections in the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>'s <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a>. Because of intersections, replacement may fail or partially succeed. Replacement only happens with COPY outputs that are temporary registers. The cover of the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> may be extended because of a new COPY output instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> being copied to </td></tr>
    <tr><td class="paramname">copy</td><td>is the list of COPY ops into the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">pos</td><td>is the index of the first COPY from the specific input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">size</td><td>is the number of COPYs (in sequence) from the same specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classCover.html#a462cc65e034e09963b612d1d3b1faa31">Cover::addDefPoint()</a>, <a class="el" href="classCover.html#ab456608e95995c8005aeac877fdac731">Cover::addRefPoint()</a>, <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classPcodeOp.html#aaf4ba146f90fc4550f8e5809617afae3">PcodeOp::clearMark()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classVarnode.html#ab7c2177c35f97bf23055432ce128e303">Varnode::copyShadow()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classFlowBlock.html#a5c7762af431a7897d31d51f6391926c2">FlowBlock::findCommonBlock()</a>, <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classBlockBasic.html#abe46dc1666049c458d6374b10f94f798">BlockBasic::getStop()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classCover.html#aca27fe50969812071ad84d60c7fb046f">Cover::intersect()</a>, <a class="el" href="classPcodeOp.html#af03aefce85152f7f638a5d87ceccc495">PcodeOp::isMark()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classHighVariable.html#a891fb98039d17be9ad7b5b618300fef2">HighVariable::merge()</a>, <a class="el" href="classCover.html#a222e454f0fbb979032978828e97fc8ef">Cover::merge()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, <a class="el" href="classHighVariable.html#a707f342c2072c5b7f52d24e64751d31a">HighVariable::remove()</a>, <a class="el" href="classPcodeOp.html#ab2ba9f66448cd77b6f274de6fae433e2">PcodeOp::setMark()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="ab4495a61b82b7e8c45c3fffb6a8e1740"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::checkCopyPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>domOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>subOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> COPYs are redundant. </p>
<p>Both the given COPYs assign to the same <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. One is redundant if there is no other assignment to the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> between the first COPY and the second COPY. The first COPY must come from a block with a smaller or equal index to the second COPY. If the indices are equal, the first COPY must come before the second within the block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> being assigned to </td></tr>
    <tr><td class="paramname">domOp</td><td>is the first COPY </td></tr>
    <tr><td class="paramname">subOp</td><td>is the second COPY </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the second COPY is redundant </dd></dl>

<p>References <a class="el" href="classCover.html#a462cc65e034e09963b612d1d3b1faa31">Cover::addDefPoint()</a>, <a class="el" href="classCover.html#ab456608e95995c8005aeac877fdac731">Cover::addRefPoint()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classCover.html#a7d0e03667cc2590975f7d8916731906f">Cover::contain()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classFlowBlock.html#adabf7e905a42c63f2b88cb9ba88368be">FlowBlock::dominates()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a4138fed84af36a22f910a25f19ea8388"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::collectCorrectable </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>oplist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>slotlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for for p-code op intersections that are correctable. </p>
<p>Given a list of Varnodes that intersect a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>, check that each intersection is on the boundary, and if so, pass back the <em>read</em> op(s) that cause the intersection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vlist</td><td>is the given list of intersecting Varnodes </td></tr>
    <tr><td class="paramname">oplist</td><td>will hold the boundary intersecting <em>read</em> ops </td></tr>
    <tr><td class="paramname">slotlist</td><td>will hold the corresponding input slots of the instance </td></tr>
    <tr><td class="paramname">op</td><td>is the specific intersecting <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> if any instance in the list intersects the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> on the interior </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classCoverBlock.html#a1871107549100bccb9690d079e255694">CoverBlock::boundary()</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, <a class="el" href="classCover.html#a8b77da7824c800db2adf9d746bba4a6d">Cover::getCoverBlock()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeOp.html#ab619fa6beed8f4ea40a6ea1f05c81d49">PcodeOp::getSlot()</a>, <a class="el" href="classCoverBlock.html#ad0e8085aae35a181fd4c1666f53429ee">CoverBlock::getUIndex()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a4bdb5ed89b9fb452c6db424ae0950643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::collectCovering </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all instances of the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> whose <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersects a p-code op. </p>
<p>Efficiently test if each instance Varnodes contains the specific p-code op in its <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> and return a list of the instances that do. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vlist</td><td>will hold the resulting list of intersecting instances </td></tr>
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to test intersection with </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classCoverBlock.html#ac30d7037598a5da939d08552293f9989">CoverBlock::contain()</a>, <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, <a class="el" href="classCover.html#a8b77da7824c800db2adf9d746bba4a6d">Cover::getCoverBlock()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="ab564defb6f5595eaa31e4e16e0230069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::compareCopyByInVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare COPY ops first by <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> input, then by block containing the op. </p>
<p>A sort designed to group COPY ops from the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> together. Then within a group, COPYs are sorted by their containing basic block (so that dominating ops come first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>is the first <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> being compared </td></tr>
    <tr><td class="paramname">op2</td><td>is the second <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> being compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> should be ordered before the second </dd></dl>

<p>References <a class="el" href="classVarnode.html#aa50f207201d2e01ec7036aeed162ad68">Varnode::getCreateIndex()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFlowBlock.html#abf74a321910dceccd678581df593ce85">FlowBlock::getIndex()</a>, <a class="el" href="classSeqNum.html#a5ec715bfab5b56bdcf3b21cf57c0da22">SeqNum::getOrder()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, and <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>.</p>

</div>
</div>
<a class="anchor" id="acb111381fd927283987f2ff6768bfbef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::compareHighByBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare HighVariables by the blocks they cover. </p>
<p>This comparator sorts, based on:</p><ul>
<li>Index of the first block containing cover for the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a></li>
<li><a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the first instance</li>
<li><a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the defining p-code op</li>
<li>Storage address</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td>is the second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> should be ordered before the second </dd></dl>

<p>References <a class="el" href="classCover.html#af1efce40d08440d87acff809af61b629">Cover::compareTo()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, and <a class="el" href="classHighVariable.html#a469a89c413cd961dd23ceabf9f827c07">HighVariable::wholecover</a>.</p>

</div>
</div>
<a class="anchor" id="ac6b1de9ce31619d3268dbaa3e5145d67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::eliminateIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classBlockVarnode.html">BlockVarnode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blocksort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminate intersections of given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with other Varnodes in a list. </p>
<p>Both the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and those in the list are assumed to be at the same storage address. For any intersection, identify the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> reading the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> which causes the intersection and <em>snip</em> the read by inserting additional COPY ops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">blocksort</td><td>is the list of other Varnodes sorted by their defining basic block </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classCover.html#a462cc65e034e09963b612d1d3b1faa31">Cover::addDefPoint()</a>, <a class="el" href="classCover.html#ab456608e95995c8005aeac877fdac731">Cover::addRefPoint()</a>, <a class="el" href="classCover.html#a3d4323b20995f80016aa095b2e23d45d">Cover::begin()</a>, <a class="el" href="classVarnode.html#ab07e1eb4590b762427942ee057c39121">Varnode::beginDescend()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classCover.html#a0254e195c33c556595d1b0ac13af5c3c">Cover::containVarnodeDef()</a>, <a class="el" href="classVarnode.html#ab7c2177c35f97bf23055432ce128e303">Varnode::copyShadow()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classCover.html#a3dccada4aa6e1baa64bcdb66621b2304">Cover::end()</a>, <a class="el" href="classVarnode.html#ac871a2f8ac68859212488a5cb94b0aa6">Varnode::endDescend()</a>, <a class="el" href="classBlockVarnode.html#a944320adf17c44b207d095cca216ee63">BlockVarnode::findFront()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classBlockVarnode.html#a07bd9563c7456a3e96557840a5826e82">BlockVarnode::getIndex()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classSeqNum.html#a5ec715bfab5b56bdcf3b21cf57c0da22">SeqNum::getOrder()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, <a class="el" href="classVarnode.html#a254f805a8eceaabd170b3e4c24b08987">Varnode::isAddrForce()</a>, and <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b5dc92d1a9b9dd84bece1c4cf8e7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::findAllIntoCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copyIns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filterTemps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the COPY ops into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<p>Collect all the COPYs whose output is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> but the input is from a different <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. Returned COPYs are sorted first by the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> then by block order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">copyIns</td><td>will hold the list of COPYs </td></tr>
    <tr><td class="paramname">filterTemps</td><td>is <b>true</b> if COPYs must have a temporary output </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a1eef2cfc279c246cc7ea0387d8c0aa66">IPTR_INTERNAL</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="adb6b87696a64ca6adea5541c5b649bf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::findSingleCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>singlelist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find instance Varnodes that copied to from outside the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<p>Find all Varnodes in the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> which are defined by a COPY from another <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> which is <em>not</em> part of the same <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">singlelist</td><td>will hold the resulting list of copied instances </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="abb1f01b80297db3a5c37c9860af56162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::hideShadows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hide <em>shadow</em> Varnodes related to the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> by consolidating COPY chains. </p>
<p>If two Varnodes are copied from the same common ancestor then they will always contain the same value and can be considered <b>shadows</b> of the same variable. If the paths from the ancestor to the two Varnodes aren't properly nested, the two Varnodes will still look like distinct variables. This routine searches for this situation, relative to a single <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>, and alters data-flow so that copying from ancestor to first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> becomes a single path. Both Varnodes then ultimately become instances of the same <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to search near </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made to data-flow </dd></dl>

<p>References <a class="el" href="classCover.html#a0254e195c33c556595d1b0ac13af5c3c">Cover::containVarnodeDef()</a>, <a class="el" href="classVarnode.html#ab7c2177c35f97bf23055432ce128e303">Varnode::copyShadow()</a>, <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, and <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>.</p>

<p>Referenced by <a class="el" href="classActionHideShadow.html#a2f3d4cba003d9e55f07c2754280caf22">ActionHideShadow::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a157b6a6d44e6aec22f1bb77201f3e402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::inflate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inflate the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> of a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<p>An expression involving a <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> can be propagated to all the read sites of the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the expression if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> can be <b>inflated</b> to include the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> of the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>, even though the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not part of the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. This routine performs the inflation, assuming an intersection test is already performed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to inflate </td></tr>
    <tr><td class="paramname">high</td><td>is the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to inflate with </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#ab48054cb643a9f44fa980c4c3259f87a">Varnode::cover</a>, <a class="el" href="classHighVariable.html#a88a2fcc928412b4169aa51752ea20304">HighVariable::coverDirty()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classCover.html#a222e454f0fbb979032978828e97fc8ef">Cover::merge()</a>, and <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>.</p>

<p>Referenced by <a class="el" href="classActionMarkImplied.html#a775f99086570c42e2bc89de67bbc9867">ActionMarkImplied::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a682cf4cedcb80161fa47a1f0c7382a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::inflateTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if we can inflate the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> without incurring intersections. </p>
<p>This routine tests whether an expression involving a <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> can be propagated to all the read sites of the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of the expression. This is possible only if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> can be <b>inflated</b> to include the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> of the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>, even though the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not part of the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to inflate </td></tr>
    <tr><td class="paramname">high</td><td>is the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> being propagated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be inflated without intersection </dd></dl>

<p>References <a class="el" href="classVarnode.html#ab7c2177c35f97bf23055432ce128e303">Varnode::copyShadow()</a>, <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classCover.html#aca27fe50969812071ad84d60c7fb046f">Cover::intersect()</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, and <a class="el" href="classHighVariable.html#a469a89c413cd961dd23ceabf9f827c07">HighVariable::wholecover</a>.</p>

<p>Referenced by <a class="el" href="classActionMarkImplied.html#a01bea6f90ccc8fe6169d34c49da454b5">ActionMarkImplied::checkImpliedCover()</a>.</p>

</div>
</div>
<a class="anchor" id="abc0c74b3892b9724fd4091a126631089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the intersection of two HighVariables and cache the result. </p>
<p>If the Covers of the two variables intersect, this routine returns <b>true</b>. To avoid expensive computation on the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> objects themselves, the test result associated with the pair of HighVariables is cached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">b</td><td>is the second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the variables intersect </dd></dl>

<p>References <a class="el" href="classCover.html#a7cf8b013d49858fed34a5ba5bb5ac89b">Cover::intersectList()</a>, and <a class="el" href="classHighVariable.html#a469a89c413cd961dd23ceabf9f827c07">HighVariable::wholecover</a>.</p>

</div>
</div>
<a class="anchor" id="a6f49b387659a09e702cb70cacb050ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::markInternalCopies </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark redundant/internal COPY PcodeOps. </p>
<p>Run through all COPY, SUBPIECE, and PIECE operations (PcodeOps that copy data) and characterize those that are <em>internal</em> (copy data between storage locations representing the same variable) or <em>redundant</em> (perform the same copy as an earlier operation). These, as a result, are not printed in the final source code representation. </p>

<p>References <a class="el" href="classHighVariable.html#a2b11564fdcfe35a455ae0e25054d2b4c">HighVariable::clearCopyIns()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classHighVariable.html#a591e2c8e1c0c5d5c2d997108fa734906">HighVariable::getTiedVarnode()</a>, <a class="el" href="classHighVariable.html#a99132d8ccd17f807ca83f91e83978595">HighVariable::hasCopyIn1()</a>, <a class="el" href="classHighVariable.html#a650d5c32fe6449fffc12aacac132f498">HighVariable::hasCopyIn2()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classHighVariable.html#a8eb6b5d3b8e0686cc34d7c8f9ab678ec">HighVariable::isAddrTied()</a>, <a class="el" href="classVarnode.html#a7fb3376269b6c8585afb3ecc877a7cab">Varnode::overlap()</a>, <a class="el" href="classHighVariable.html#ad117d9996dba003d2a232565e835a536">HighVariable::setCopyIn1()</a>, and <a class="el" href="classHighVariable.html#a126beae369413f5909a38c3faa1fe35e">HighVariable::setCopyIn2()</a>.</p>

<p>Referenced by <a class="el" href="classActionCopyMarker.html#a98effc8531139d4f7a958a67d4811f40">ActionCopyMarker::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a72c58ad9d6ab54d086e0f3a656ae5d50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::markRedundantCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for and mark redundant COPY ops into the given high as <em>non-printing</em>. </p>
<p>Trimming during the merge process can insert multiple COPYs from the same source. In some cases, one or more COPYs may be redundant and shouldn't be printed. This method searches for redundancy among COPY ops that assign to the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">copy</td><td>is the list of COPYs coming from the same source <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">pos</td><td>is the starting index of a set of COPYs coming from the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">size</td><td>is the number of Varnodes in the set coming from the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7ed07599f26d398f26ac38e02dc30a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isspeculative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform low-level details of merging two HighVariables if possible. </p>
<p>This routine only fails (returning <b>false</b>) if there is a <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersection between the two variables. Otherwise, all the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> instances from the second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> are merged into the first and its <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is updated. The cached intersection tests are also updated to reflect the merge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high1</td><td>is the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> being merged </td></tr>
    <tr><td class="paramname">high2</td><td>is the second </td></tr>
    <tr><td class="paramname">isspeculative</td><td>is <b>true</b> if the desired merge is speculative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the merge was successful </dd></dl>

<p>References <a class="el" href="classHighVariable.html#a891fb98039d17be9ad7b5b618300fef2">HighVariable::merge()</a>, <a class="el" href="classHighVariable.html#a9aca22722220828e753925df3cb86604">HighVariable::setMark()</a>, and <a class="el" href="classHighVariable.html#ad0b405a53c5466e35f08cd1b2d45b752">HighVariable::updateCover()</a>.</p>

</div>
</div>
<a class="anchor" id="a8045c24ce73080b02d4506f2047a414e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeAddrTied </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the merge of <em>address</em> <em>tried</em> Varnodes. </p>
<p>For each set of address tied Varnodes with the same size and storage address, merge them into a single <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. The merges are <em>forced</em>, so any <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections must be resolved by altering data-flow, which involves inserting additional COPY ops and <em>unique</em> Varnodes. </p>

<p>References <a class="el" href="classVarnode.html#ad367c0ac3c08b6f41e7334e90a138e8ca16c6748ecb7542c2f79d81be83098dd5">Varnode::written</a>.</p>

<p>Referenced by <a class="el" href="classActionMergeRequired.html#a2cee2e5fc759fbf5ba680f08bfb4d0e3">ActionMergeRequired::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a79f377000da91c9e50b89307fa88d268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeAdjacent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Speculatively merge Varnodes that are input/output to the same p-code op. </p>
<p>If a single p-code op has an input and output <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> that share the same data-type, attempt to merge them. Each merge is speculative and is skipped if it would introduce <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections. </p>

<p>References <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classPcodeOp.html#a3001e944d6e40358d86cf00b21436dc4">PcodeOp::inputTypeLocal()</a>, <a class="el" href="classPcodeOp.html#a091539b02c09c885351f789b24afba7b">PcodeOp::isCall()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, and <a class="el" href="classPcodeOp.html#a6d6757156786ad5708d4c6b7fc05fece">PcodeOp::outputTypeLocal()</a>.</p>

<p>Referenced by <a class="el" href="classActionMergeAdjacent.html#aa6319f917bac228ae065205c84efb5e1">ActionMergeAdjacent::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a319ac2d65a6dff86cbfda772d047b2e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeByDatatype </td>
          <td>(</td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>startiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>enditer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to merge all HighVariables in the given range that have the same data-type. </p>
<p>HighVariables that have an instance within the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> range are sorted into groups based on their data-type. Then an attempt is made to merge all the HighVariables within a group. If a particular merge causes <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersection, it is skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startiter</td><td>is the start of the given range of Varnodes </td></tr>
    <tr><td class="paramname">enditer</td><td>is the end of the given range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classHighVariable.html#a63afa99edb788d34b85bb3944457c653">HighVariable::isMark()</a>, <a class="el" href="classHighVariable.html#a9aca22722220828e753925df3cb86604">HighVariable::setMark()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

<p>Referenced by <a class="el" href="classActionMergeType.html#a512152b02f4dedd4d83fb0ddb4f9a990">ActionMergeType::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a957608caea903bbc3864bd0307ccd8e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the merge of all input and output Varnodes to a given INDIRECT op. </p>
<p>Merging INDIRECTs take a little care if their output is address forced because by convention the value must be present at the address BEFORE the indirect effect operation takes place. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indop</td><td>is the given INDIRECT </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, and <a class="el" href="classVarnode.html#a254f805a8eceaabd170b3e4c24b08987">Varnode::isAddrForce()</a>.</p>

</div>
</div>
<a class="anchor" id="a20bb73c63d9c91f9c53cc513e51eb29a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeLinear </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classHighVariable.html">HighVariable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>highvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Speculatively merge all HighVariables in the given list as well as possible. </p>
<p>The variables are first sorted by the index of the earliest block in their range. Then proceeding in order, an attempt is made to merge each variable with the first. The attempt fails if the <em>speculative</em> test doesn't pass or if there are <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections, in which case that particular merge is skipped. </p>

</div>
</div>
<a class="anchor" id="aedcf63d8d5400410d06ef4aa250275a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeMarker </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the merge of input and output Varnodes to MULTIEQUAL and INDIRECT ops. </p>
<p>Run through all MULTIEQUAL and INDIRECT ops in the function. Force the merge of each input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, doing data-flow modification if necessary to resolve <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections. </p>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classPcodeOp.html#a94eede902decfd58b5443fbfe7c1560a">PcodeOp::isIndirectCreation()</a>, and <a class="el" href="classPcodeOp.html#a598f7ea82d32e8fcaf984c0fbdf4c704">PcodeOp::isMarker()</a>.</p>

<p>Referenced by <a class="el" href="classActionMergeRequired.html#a2cee2e5fc759fbf5ba680f08bfb4d0e3">ActionMergeRequired::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ab07666baf4d4fb03ee2243d22f15c25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeMultiEntry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> together Varnodes mapped to SymbolEntrys from the same <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. </p>
<p>Symbols that have more than one <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> may attach to more than one <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. These Varnodes need to be merged to properly represent a single variable. </p>

<p>References <a class="el" href="classSymbol.html#a66ff3b28898c5c12067f99fc2752585a">Symbol::getMapEntry()</a>, <a class="el" href="classSymbol.html#aee9da22d9d9f511694bb1eb95f5033e9">Symbol::getName()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classSymbolEntry.html#ae944ebb384bc9fac97c57dfb430a9f8e">SymbolEntry::getSize()</a>, <a class="el" href="classSymbol.html#ad3bc7110cbcbeebbd642ba8e3342a59d">Symbol::getType()</a>, <a class="el" href="classSymbol.html#a3de44fc6775fdf626f871546785b5996">Symbol::numEntries()</a>, <a class="el" href="classSymbol.html#ab3fcfe30a27f81358d60131fd793b8cd">Symbol::setMergeProblems()</a>, and <a class="el" href="classHighVariable.html#a314c33d4293e5df2335dc2de6289ae22">HighVariable::setUnmerged()</a>.</p>

<p>Referenced by <a class="el" href="classActionMergeMultiEntry.html#ac2a894d794a2416d8a0e4935c8874635">ActionMergeMultiEntry::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a98788700ee91acef7ffc470bc1fad79a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the merge of all input and output Varnodes for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>Data-flow for specific input and output Varnodes are <em>snipped</em> until everything can be merged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a355b4e853526d717fa96ea375443be8e">PcodeOp::getSeqNum()</a>, and <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a55762a93af96a7e8abab70b169302b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to force merges of input to output for all p-code ops of a given type. </p>
<p>For a given opcode, run through all ops in the function in block/address order and try to merge each input <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> with the output <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. If this would introduce <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersections, the merge is skipped. This is generally used to try to merge the input and output of COPY ops if possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opc</td><td>is the op-code type to merge </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockBasic.html#a3ddd779a5af8cb12e6fc069bd49ddb6c">BlockBasic::beginOp()</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="classBlockBasic.html#abd3fc70635403ddb5c85c07b19c6f6b3">BlockBasic::endOp()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, and <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>.</p>

<p>Referenced by <a class="el" href="classActionMergeCopy.html#a363eedc3ead59931897e73fb55a31a0e">ActionMergeCopy::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b1be534bc0d2ed6824c0c909d627dcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::mergeRangeMust </td>
          <td>(</td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>startiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>enditer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the merge of a ranges of Varnodes with the same size and storage address. </p>
<p>The list of Varnodes to be merged is provided as a range in the main location sorted container. Any <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersection is assumed to already be <b>snipped</b>, so any problems with merging cause an exception to be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startiter</td><td>is the beginning of the range of Varnodes with the same storage address </td></tr>
    <tr><td class="paramname">enditer</td><td>is the end of the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae">Varnode::isSpacebase()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a819c900aaa428a745faa59335bf0b69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::mergeTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classHighVariable.html">HighVariable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmplist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for intersections between a given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> and a list of other HighVariables. </p>
<p>If there is any <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> intersection between the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> and one in the list, this routine returns <b>false</b>. Otherwise, the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> is added to the end of the list and <b>true</b> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
    <tr><td class="paramname">tmplist</td><td>is the list of HighVariables to test against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there are no pairwise intersections. </dd></dl>

<p>References <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classHighVariable.html#a99132d8ccd17f807ca83f91e83978595">HighVariable::hasCopyIn1()</a>, <a class="el" href="classHighVariable.html#ad8b10de589eec1214947857b45fe4eb8">HighVariable::hasCover()</a>, <a class="el" href="classVarnode.html#a049582bef1b75183ec9e358aad951484">Varnode::hasCover()</a>, <a class="el" href="classHighVariable.html#ad117d9996dba003d2a232565e835a536">HighVariable::setCopyIn1()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="add5ab9571ded34aa3a5c2a8b80ce7597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::mergeTestAdjacent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjacency tests for merging Varnodes that are input or output to the same p-code op. </p>
<p>All the required tests (<a class="el" href="classMerge.html#ae7bd7bdda4f0fb983c5b075fdd9cbb5f" title="Required tests to merge HighVariables that are not Cover related. ">mergeTestRequired()</a>) are performed, and then some additional tests are performed. This does not perform any <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> tests. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high_out</td><td>is the <em>output</em> <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to test </td></tr>
    <tr><td class="paramname">high_in</td><td>is the <em>input</em> <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if tests pass and the HighVariables are not forbidden to merge </dd></dl>

<p>References <a class="el" href="classHighVariable.html#a8ef6f146fb07092fb2f5e87a8eeaca72">HighVariable::getInputVarnode()</a>, <a class="el" href="classHighVariable.html#a9e561faf1953008ca9278e77ab6d4ca1">HighVariable::getSymbol()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classVarnode.html#a6b910e0f81ed517912e7cf9b1b61d782">Varnode::isIllegalInput()</a>, <a class="el" href="classVarnode.html#a6d7cdbc9922b0565266f1b273b7117c7">Varnode::isIndirectOnly()</a>, <a class="el" href="classHighVariable.html#a45dfe07c55cc3f046ca6b93dfdc2f36a">HighVariable::isInput()</a>, <a class="el" href="classSymbol.html#a8fa18b0fe69a1c5070e0d0e3f4d41ec9">Symbol::isIsolated()</a>, <a class="el" href="classHighVariable.html#a2a69aa671d8303ff2a3766e69b25926b">HighVariable::isNameLock()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a69e5aec8b0f32a02e0895b34401d7ac8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::mergeTestBasic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A test if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can ever be merged. </p>
<p>Some Varnodes (constants, annotations, implied, spacebase) are never merged with another <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not forbidden from ever merging </dd></dl>

<p>References <a class="el" href="classVarnode.html#a049582bef1b75183ec9e358aad951484">Varnode::hasCover()</a>, <a class="el" href="classVarnode.html#a71980f26f2bca5a4901d2781a8917d7c">Varnode::isImplied()</a>, and <a class="el" href="classVarnode.html#aab9bdab0a8f01ee2e3f39ed91a37f7ae">Varnode::isSpacebase()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7bd7bdda4f0fb983c5b075fdd9cbb5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::mergeTestRequired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Required tests to merge HighVariables that are not <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> related. </p>
<p>This is designed to short circuit merge tests, when we know properties of the two HighVariables preclude merging. For example, you can't merge HighVariables if:</p><ul>
<li>They are locked to different data-types</li>
<li>They are both mapped to different address ranges</li>
<li>One is a parameter one is a global</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high_out</td><td>is the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to test </td></tr>
    <tr><td class="paramname">high_in</td><td>is the second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if tests pass and the HighVariables are not forbidden to merge </dd></dl>

<p>References <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classHighVariable.html#a9e561faf1953008ca9278e77ab6d4ca1">HighVariable::getSymbol()</a>, <a class="el" href="classHighVariable.html#a5e755367fb99efe1bacc72cb9de41124">HighVariable::getSymbolOffset()</a>, <a class="el" href="classHighVariable.html#a591e2c8e1c0c5d5c2d997108fa734906">HighVariable::getTiedVarnode()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classHighVariable.html#a8eb6b5d3b8e0686cc34d7c8f9ab678ec">HighVariable::isAddrTied()</a>, <a class="el" href="classHighVariable.html#ae7c3c7553aad08b636ccf7f9b6a9de17">HighVariable::isExtraOut()</a>, <a class="el" href="classHighVariable.html#a45dfe07c55cc3f046ca6b93dfdc2f36a">HighVariable::isInput()</a>, <a class="el" href="classHighVariable.html#aa9b272571b5199a53532aafee033efda">HighVariable::isPersist()</a>, and <a class="el" href="classHighVariable.html#adc8fe8c48919fcbe095ac3114975ef07">HighVariable::isTypeLock()</a>.</p>

</div>
</div>
<a class="anchor" id="add7f2a861e227445d10225d86c29249a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::mergeTestSpeculative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Speculative tests for merging HighVariables that are not <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> related. </p>
<p>This does all the <em>required</em> and <em>adjacency</em> merge tests and then performs additional tests required for <em>speculative</em> merges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high_out</td><td>is the first <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to test </td></tr>
    <tr><td class="paramname">high_in</td><td>is the second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if tests pass and the HighVariables are not forbidden to merge </dd></dl>

<p>References <a class="el" href="classHighVariable.html#a8eb6b5d3b8e0686cc34d7c8f9ab678ec">HighVariable::isAddrTied()</a>, <a class="el" href="classHighVariable.html#a45dfe07c55cc3f046ca6b93dfdc2f36a">HighVariable::isInput()</a>, and <a class="el" href="classHighVariable.html#aa9b272571b5199a53532aafee033efda">HighVariable::isPersist()</a>.</p>

</div>
</div>
<a class="anchor" id="a0af9c332a00eee4f51242239e05bc916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::processCopyTrims </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to reduce/eliminate COPYs produced by the merge trimming process. </p>
<p>In order to force merging of certain Varnodes, extra COPY operations may be inserted to reduce their <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> ranges, and multiple COPYs from the same <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be created this way. This method collects sets of COPYs generated in this way that have the same input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and then tries to replace the COPYs with fewer or a single COPY. </p>

<p>References <a class="el" href="classHighVariable.html#a2b11564fdcfe35a455ae0e25054d2b4c">HighVariable::clearCopyIns()</a>, <a class="el" href="classHighVariable.html#a99132d8ccd17f807ca83f91e83978595">HighVariable::hasCopyIn1()</a>, <a class="el" href="classHighVariable.html#a650d5c32fe6449fffc12aacac132f498">HighVariable::hasCopyIn2()</a>, <a class="el" href="classHighVariable.html#ad117d9996dba003d2a232565e835a536">HighVariable::setCopyIn1()</a>, and <a class="el" href="classHighVariable.html#a126beae369413f5909a38c3faa1fe35e">HighVariable::setCopyIn2()</a>.</p>

<p>Referenced by <a class="el" href="classActionDominantCopy.html#a6a310d1678ee8ca269cdb5a196336d05">ActionDominantCopy::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="afbcc05b843ebb1a5cc15c0791b8d7c87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::processHighDominantCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to replace COPYs into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> with a single dominant COPY. </p>
<p>Find groups of COPYs into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> that come from a single source <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, then try to replace them with a COPY. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20dca8700a975a7a43af2bc4c27cd3fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::processHighRedundantCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark COPY ops into the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> that are redundant. </p>
<p>A COPY is redundant if another COPY performs the same action and has dominant control flow. The redundant COPY is not removed but is marked so that it doesn't print in the final source output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adafc0f8f2f67d2f8ca22a2825689fa04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::purgeHigh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove cached intersection tests for a given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<p>All tests for pairs where either the first or second <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> matches the given one are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to purge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1fcbb0d0d742417197d2c416e3b728a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::shadowedVarnode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is shadowed by another <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the same <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to check for shadowing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>vn</b> is shadowed by another <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in its high-level variable </dd></dl>

<p>References <a class="el" href="classVarnode.html#aa7292115029259fe351ecae5bad5fb76">Varnode::getCover()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classCover.html#aca27fe50969812071ad84d60c7fb046f">Cover::intersect()</a>, and <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>.</p>

</div>
</div>
<a class="anchor" id="abd9f8217c0d75e97ca3b72d3318cb56c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::snipIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Snip instances of the input of an INDIRECT op that interfere with its output. </p>
<p>Examine the input and output <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> for the given INDIRECT op. <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> instances of the input that intersect the output <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> are snipped by creating a new COPY op from the input to a new temporary and then replacing the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> reads with the temporary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indop</td><td>is the given INDIRECT op </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, and <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>.</p>

</div>
</div>
<a class="anchor" id="abd4bf8ba9957e00395cc4bffd1ce7be9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::snipReads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>markedop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Snip off set of <em>read</em> p-code ops for a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>The data-flow for the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is truncated by creating a COPY p-code from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into a new temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, then replacing the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> reads for a specific set of p-code ops with the temporary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">markedop</td><td>is the specific set of PcodeOps reading the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classBlockBasic.html#a6e4cef2dc444acdf84fa622aaa0e4492">BlockBasic::getStart()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="af3e038739e621d6028f4b08823e74a80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::trimOpInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim the input <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> of the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> so that its <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is tiny. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is assumed to force merging so that input and output Covers shouldn't intersect. A new COPY is inserted right before the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with a new <em>unique</em> output that replaces the specified input, disassociating it from the other original inputs and output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the specified slot of the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to be trimmed </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a108d223da48e77fa181637fc3e75d9e8">CPUI_MULTIEQUAL</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFlowBlock.html#acbb1f895710c8339bd21d9c7a3200322">FlowBlock::getIn()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classBlockBasic.html#abe46dc1666049c458d6374b10f94f798">BlockBasic::getStop()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a8d548f10858bf63371a5073b21ee4d22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::trimOpOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim the output <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> of the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> so that its <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is tiny. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is assumed to force merging so that input and output Covers shouldn't intersect. The original <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> output is <em>moved</em> so that it becomes the output of a new COPY, disassociating the original output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from the inputs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classPcodeOp.html#a41be82b850ff5185e51268aead2c2802">PcodeOp::getOpFromConst()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classVarnode.html#ac91e77cd057edb96719fbc9339140985">Varnode::getType()</a>, and <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="ae35e529686073ce77f319755cfd868c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Merge::unifyAddress </td>
          <td>(</td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>startiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarnodeLocSet::const_iterator&#160;</td>
          <td class="paramname"><em>enditer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure all Varnodes with the same storage address and size can be merged. </p>
<p>The list of Varnodes to be merged is provided as a range in the main location sorted container. Any discovered intersection is <b>snipped</b> by splitting data-flow for one of the Varnodes into two or more flows, which involves insert new COPY ops and temporaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startiter</td><td>is the beginning of the range of Varnodes with the same storage address </td></tr>
    <tr><td class="paramname">enditer</td><td>is the end of the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classBlockVarnode.html#a95383ba734e4f962bf2083d5f842eaf2">BlockVarnode::vn</a>.</p>

</div>
</div>
<a class="anchor" id="a4681c941b4008d37b923d3e93de9d8c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Merge::updateHigh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>'s <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is up-to-date. </p>
<p>As manipulations are made, <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> information gets out of date. A <em>dirty</em> flag is used to indicate a particular <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> is out-of-date. This routine checks the <em>dirty</em> flag and updates the <a class="el" href="classCover.html" title="A description of the topological scope of a single variable object. ">Cover</a> information if it is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> was not originally dirty </dd></dl>

<p>References <a class="el" href="classHighVariable.html#a5f60ca7d7429ef6a998c2fee2a29690fa0fcd0f7d35521e76a5ae0b950e965891">HighVariable::coverdirty</a>, <a class="el" href="classHighVariable.html#a3924041a4162ad8605c96093facb59f8">HighVariable::getInstance()</a>, <a class="el" href="classHighVariable.html#ab55629b89ee58651edb7d9e297c3a550">HighVariable::highflags</a>, <a class="el" href="classHighVariable.html#a31264f7f1e20293ccd7493f20ff1d0e0">HighVariable::numInstances()</a>, <a class="el" href="classHighVariable.html#ad0b405a53c5466e35f08cd1b2d45b752">HighVariable::updateCover()</a>, and <a class="el" href="classVarnode.html#a291bbee0feb02247ecb81c80f124f538">Varnode::updateCover()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="merge_8hh.html">merge.hh</a></li>
<li>merge.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
