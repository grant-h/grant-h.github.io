<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: FuncCallSpecs Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFuncCallSpecs-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FuncCallSpecs Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for analyzing parameters to a sub-function call.  
 <a href="classFuncCallSpecs.html#details">More...</a></p>

<p><code>#include &lt;fspec.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FuncCallSpecs:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFuncCallSpecs.png" usemap="#FuncCallSpecs_map" alt=""/>
  <map id="FuncCallSpecs_map" name="FuncCallSpecs_map">
<area href="classFuncProto.html" title="A function prototype. " alt="FuncProto" shape="rect" coords="0,0,98,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abbbb64f2e2d7f1af62d3226e110079c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classFuncCallSpecs.html#abbbb64f2e2d7f1af62d3226e110079c3a584ec7401809588c22798803bff5b796">offset_unknown</a> = 0xBADBEEF
 }</td></tr>
<tr class="separator:abbbb64f2e2d7f1af62d3226e110079c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *call_op)</td></tr>
<tr class="memdesc:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct based on CALL or CALLIND.  <a href="#a96cbd6a1b0311883aeb840f47e4a0ec7">More...</a><br /></td></tr>
<tr class="separator:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbc2ae7d43e62971751d96cbddf1b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dbc2ae7d43e62971751d96cbddf1b32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9dbc2ae7d43e62971751d96cbddf1b32">setAddress</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a9dbc2ae7d43e62971751d96cbddf1b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (override) the callee's entry address. <br /></td></tr>
<tr class="separator:a9dbc2ae7d43e62971751d96cbddf1b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b3a2d5f5b918348806e20d18cd0529"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b3a2d5f5b918348806e20d18cd0529"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a82b3a2d5f5b918348806e20d18cd0529">getOp</a> (void) const </td></tr>
<tr class="memdesc:a82b3a2d5f5b918348806e20d18cd0529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CALL or CALLIND corresponding to <b>this</b>. <br /></td></tr>
<tr class="separator:a82b3a2d5f5b918348806e20d18cd0529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c9b7b561b806f7b1b998ba3dbb2105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6c9b7b561b806f7b1b998ba3dbb2105"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae6c9b7b561b806f7b1b998ba3dbb2105">getFuncdata</a> (void) const </td></tr>
<tr class="memdesc:ae6c9b7b561b806f7b1b998ba3dbb2105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object associated with the called function. <br /></td></tr>
<tr class="separator:ae6c9b7b561b806f7b1b998ba3dbb2105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f63fcf31daa5cc5663df227a813f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2f63fcf31daa5cc5663df227a813f0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae2f63fcf31daa5cc5663df227a813f0a">setFuncdata</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:ae2f63fcf31daa5cc5663df227a813f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object associated with the called function. <br /></td></tr>
<tr class="separator:ae2f63fcf31daa5cc5663df227a813f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24c733f6fbfbb4288d231869f69455d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae24c733f6fbfbb4288d231869f69455d">clone</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *newop) const </td></tr>
<tr class="memdesc:ae24c733f6fbfbb4288d231869f69455d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone <b>this</b> given the mirrored p-code CALL.  <a href="#ae24c733f6fbfbb4288d231869f69455d">More...</a><br /></td></tr>
<tr class="separator:ae24c733f6fbfbb4288d231869f69455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51926cb3edd4d20204d081c6cb09ba4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab51926cb3edd4d20204d081c6cb09ba4"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab51926cb3edd4d20204d081c6cb09ba4">getName</a> (void) const </td></tr>
<tr class="memdesc:ab51926cb3edd4d20204d081c6cb09ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function name associated with the callee. <br /></td></tr>
<tr class="separator:ab51926cb3edd4d20204d081c6cb09ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cfa83e02add7d25f8c426e0403b308"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48cfa83e02add7d25f8c426e0403b308"></a>
const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a48cfa83e02add7d25f8c426e0403b308">getEntryAddress</a> (void) const </td></tr>
<tr class="memdesc:a48cfa83e02add7d25f8c426e0403b308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entry address of the callee. <br /></td></tr>
<tr class="separator:a48cfa83e02add7d25f8c426e0403b308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d9cc82055fdcbc01f0a37ae3a56a01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d9cc82055fdcbc01f0a37ae3a56a01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a41d9cc82055fdcbc01f0a37ae3a56a01">setEffectiveExtraPop</a> (int4 epop)</td></tr>
<tr class="memdesc:a41d9cc82055fdcbc01f0a37ae3a56a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specific <em>extrapop</em> associate with <b>this</b> call site. <br /></td></tr>
<tr class="separator:a41d9cc82055fdcbc01f0a37ae3a56a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d1151dddb3c6c6f40e389040c8c1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62d1151dddb3c6c6f40e389040c8c1e9"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a62d1151dddb3c6c6f40e389040c8c1e9">getEffectiveExtraPop</a> (void) const </td></tr>
<tr class="memdesc:a62d1151dddb3c6c6f40e389040c8c1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specific <em>extrapop</em> associate with <b>this</b> call site. <br /></td></tr>
<tr class="separator:a62d1151dddb3c6c6f40e389040c8c1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb8dcbd6e0efb15a933cc9ded517f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacb8dcbd6e0efb15a933cc9ded517f28"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aacb8dcbd6e0efb15a933cc9ded517f28">getSpacebaseOffset</a> (void) const </td></tr>
<tr class="memdesc:aacb8dcbd6e0efb15a933cc9ded517f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack-pointer relative offset at the point of <b>this</b> call site. <br /></td></tr>
<tr class="separator:aacb8dcbd6e0efb15a933cc9ded517f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c86fdb931fd085ca45ff39a091552a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1c86fdb931fd085ca45ff39a091552a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ac1c86fdb931fd085ca45ff39a091552a">setParamshift</a> (int4 val)</td></tr>
<tr class="memdesc:ac1c86fdb931fd085ca45ff39a091552a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a parameter shift for this call site. <br /></td></tr>
<tr class="separator:ac1c86fdb931fd085ca45ff39a091552a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c96d4e166e55b628fa1de26e68e3cc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c96d4e166e55b628fa1de26e68e3cc7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a1c96d4e166e55b628fa1de26e68e3cc7">getParamshift</a> (void) const </td></tr>
<tr class="memdesc:a1c96d4e166e55b628fa1de26e68e3cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter shift for this call site. <br /></td></tr>
<tr class="separator:a1c96d4e166e55b628fa1de26e68e3cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7ad597600012a53051998fad9bac36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7ad597600012a53051998fad9bac36"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a3f7ad597600012a53051998fad9bac36">getMatchCallCount</a> (void) const </td></tr>
<tr class="memdesc:a3f7ad597600012a53051998fad9bac36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of calls the caller makes to <b>this</b> sub-function. <br /></td></tr>
<tr class="separator:a3f7ad597600012a53051998fad9bac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529e03f3574558d54ccb08a8262d37a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a529e03f3574558d54ccb08a8262d37a7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a529e03f3574558d54ccb08a8262d37a7">getStackPlaceholderSlot</a> (void) const </td></tr>
<tr class="memdesc:a529e03f3574558d54ccb08a8262d37a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the slot of the stack-pointer placeholder. <br /></td></tr>
<tr class="separator:a529e03f3574558d54ccb08a8262d37a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab398038b75b6f13b865384da3fd143b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab398038b75b6f13b865384da3fd143b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab398038b75b6f13b865384da3fd143b9">setStackPlaceholderSlot</a> (int4 slot)</td></tr>
<tr class="memdesc:ab398038b75b6f13b865384da3fd143b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the slot of the stack-pointer placeholder. <br /></td></tr>
<tr class="separator:ab398038b75b6f13b865384da3fd143b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571062bec4389e2602577b6eed10cbf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a571062bec4389e2602577b6eed10cbf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a571062bec4389e2602577b6eed10cbf5">clearStackPlaceholderSlot</a> (void)</td></tr>
<tr class="memdesc:a571062bec4389e2602577b6eed10cbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the stack-pointer placeholder. <br /></td></tr>
<tr class="separator:a571062bec4389e2602577b6eed10cbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b481b6be0cc41e4f1b35089fc5f192b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0b481b6be0cc41e4f1b35089fc5f192b">initActiveInput</a> (void)</td></tr>
<tr class="memdesc:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on analysis recovering input parameters. <br /></td></tr>
<tr class="separator:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24a93644abe9ee56a9aa86ba4cb0c9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af24a93644abe9ee56a9aa86ba4cb0c9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#af24a93644abe9ee56a9aa86ba4cb0c9f">clearActiveInput</a> (void)</td></tr>
<tr class="memdesc:af24a93644abe9ee56a9aa86ba4cb0c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off analysis recovering input parameters. <br /></td></tr>
<tr class="separator:af24a93644abe9ee56a9aa86ba4cb0c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87904aacb6678c8bde4c0c2c781db830"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87904aacb6678c8bde4c0c2c781db830"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a87904aacb6678c8bde4c0c2c781db830">initActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a87904aacb6678c8bde4c0c2c781db830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on analysis recovering the return value. <br /></td></tr>
<tr class="separator:a87904aacb6678c8bde4c0c2c781db830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c13854db24718357b5ce7de7802b4ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c13854db24718357b5ce7de7802b4ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a5c13854db24718357b5ce7de7802b4ed">clearActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a5c13854db24718357b5ce7de7802b4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off analysis recovering the return value. <br /></td></tr>
<tr class="separator:a5c13854db24718357b5ce7de7802b4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535463c18ea83b3ede30b02c701d0b09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535463c18ea83b3ede30b02c701d0b09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a535463c18ea83b3ede30b02c701d0b09">isInputActive</a> (void) const </td></tr>
<tr class="memdesc:a535463c18ea83b3ede30b02c701d0b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if input parameter recovery analysis is active. <br /></td></tr>
<tr class="separator:a535463c18ea83b3ede30b02c701d0b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8ce3364e76b8350b02a663dc2282fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c8ce3364e76b8350b02a663dc2282fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a3c8ce3364e76b8350b02a663dc2282fc">isOutputActive</a> (void) const </td></tr>
<tr class="memdesc:a3c8ce3364e76b8350b02a663dc2282fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if return value recovery analysis is active. <br /></td></tr>
<tr class="separator:a3c8ce3364e76b8350b02a663dc2282fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe07c5f01eaa2171a4d8c4c832910022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe07c5f01eaa2171a4d8c4c832910022"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#abe07c5f01eaa2171a4d8c4c832910022">setBadJumpTable</a> (bool val)</td></tr>
<tr class="memdesc:abe07c5f01eaa2171a4d8c4c832910022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>call</b> site looked like an indirect jump. <br /></td></tr>
<tr class="separator:abe07c5f01eaa2171a4d8c4c832910022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa347076fe7a846b764f5d6e8293cfb87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa347076fe7a846b764f5d6e8293cfb87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aa347076fe7a846b764f5d6e8293cfb87">isBadJumpTable</a> (void) const </td></tr>
<tr class="memdesc:aa347076fe7a846b764f5d6e8293cfb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> call site looked like an indirect jump. <br /></td></tr>
<tr class="separator:aa347076fe7a846b764f5d6e8293cfb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32432a6c7b201dc160ae0b2480a1b8b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32432a6c7b201dc160ae0b2480a1b8b9"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a32432a6c7b201dc160ae0b2480a1b8b9">getActiveInput</a> (void)</td></tr>
<tr class="memdesc:a32432a6c7b201dc160ae0b2480a1b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the analysis object for input parameter recovery. <br /></td></tr>
<tr class="separator:a32432a6c7b201dc160ae0b2480a1b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e9a9406614829224612035f28d311"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a866e9a9406614829224612035f28d311"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a866e9a9406614829224612035f28d311">getActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a866e9a9406614829224612035f28d311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the analysis object for return value recovery. <br /></td></tr>
<tr class="separator:a866e9a9406614829224612035f28d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb251c17c1f0a352c73930383dea6c8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#acb251c17c1f0a352c73930383dea6c8f">checkInputJoin</a> (int4 slot1, bool ishislot, <a class="el" href="classVarnode.html">Varnode</a> *vn1, <a class="el" href="classVarnode.html">Varnode</a> *vn2) const </td></tr>
<tr class="memdesc:acb251c17c1f0a352c73930383dea6c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if adjacent parameter trials can be combined into a single logical parameter.  <a href="#acb251c17c1f0a352c73930383dea6c8f">More...</a><br /></td></tr>
<tr class="separator:acb251c17c1f0a352c73930383dea6c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489441d9d77d08bdf87eff937e8ef5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a489441d9d77d08bdf87eff937e8ef5b8">doInputJoin</a> (int4 slot1, bool ishislot)</td></tr>
<tr class="memdesc:a489441d9d77d08bdf87eff937e8ef5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two parameter trials.  <a href="#a489441d9d77d08bdf87eff937e8ef5b8">More...</a><br /></td></tr>
<tr class="separator:a489441d9d77d08bdf87eff937e8ef5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b52b70e4def9167d06709746635e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;restrictedProto, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newinput, <a class="el" href="classVarnode.html">Varnode</a> *&amp;newoutput)</td></tr>
<tr class="memdesc:ab55b52b70e4def9167d06709746635e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <b>this</b> prototype to match a given (more specialized) prototype.  <a href="#ab55b52b70e4def9167d06709746635e9">More...</a><br /></td></tr>
<tr class="separator:ab55b52b70e4def9167d06709746635e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64d557811baf4602afcefb2746f7be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classFuncdata.html">Funcdata</a> *newfd)</td></tr>
<tr class="memdesc:aad64d557811baf4602afcefb2746f7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <b>this</b> call site from an indirect to a direct function call.  <a href="#aad64d557811baf4602afcefb2746f7be">More...</a><br /></td></tr>
<tr class="separator:aad64d557811baf4602afcefb2746f7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc0ef657c876530f21a6ae60458eb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;fp)</td></tr>
<tr class="memdesc:a8bc0ef657c876530f21a6ae60458eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a more restrictive prototype on <b>this</b> call site.  <a href="#a8bc0ef657c876530f21a6ae60458eb35">More...</a><br /></td></tr>
<tr class="separator:a8bc0ef657c876530f21a6ae60458eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6a890aaa82deca59ec7c57c92629aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aae6a890aaa82deca59ec7c57c92629aa">insertPcode</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:aae6a890aaa82deca59ec7c57c92629aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject any <em>upon-return</em> p-code at <b>this</b> call site.  <a href="#aae6a890aaa82deca59ec7c57c92629aa">More...</a><br /></td></tr>
<tr class="separator:aae6a890aaa82deca59ec7c57c92629aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2a3f374049dec6fdf0f9d20295305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a5ad2a3f374049dec6fdf0f9d20295305">resolveSpacebaseRelative</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *phvn)</td></tr>
<tr class="memdesc:a5ad2a3f374049dec6fdf0f9d20295305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the stack offset of <b>this</b> call site.  <a href="#a5ad2a3f374049dec6fdf0f9d20295305">More...</a><br /></td></tr>
<tr class="separator:a5ad2a3f374049dec6fdf0f9d20295305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c3231b5c523e491d65f31ddb688cc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad3c3231b5c523e491d65f31ddb688cc1">abortSpacebaseRelative</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:ad3c3231b5c523e491d65f31ddb688cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the attempt to recover the relative stack offset for <b>this</b> function.  <a href="#ad3c3231b5c523e491d65f31ddb688cc1">More...</a><br /></td></tr>
<tr class="separator:ad3c3231b5c523e491d65f31ddb688cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48998cb808c1feedcad257f0984317ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a48998cb808c1feedcad257f0984317ed">finalInputCheck</a> (void)</td></tr>
<tr class="memdesc:a48998cb808c1feedcad257f0984317ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make final activity check on trials that might have been affected by conditional execution.  <a href="#a48998cb808c1feedcad257f0984317ed">More...</a><br /></td></tr>
<tr class="separator:a48998cb808c1feedcad257f0984317ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49917128896eb002c816e361f875943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">checkInputTrialUse</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classAliasChecker.html">AliasChecker</a> &amp;aliascheck)</td></tr>
<tr class="memdesc:ab49917128896eb002c816e361f875943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if input trials are being actively used.  <a href="#ab49917128896eb002c816e361f875943">More...</a><br /></td></tr>
<tr class="separator:ab49917128896eb002c816e361f875943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c50f8299ce305411880fc61b8b1907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a82c50f8299ce305411880fc61b8b1907">checkOutputTrialUse</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;trialvn)</td></tr>
<tr class="memdesc:a82c50f8299ce305411880fc61b8b1907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if output trials are being actively used.  <a href="#a82c50f8299ce305411880fc61b8b1907">More...</a><br /></td></tr>
<tr class="separator:a82c50f8299ce305411880fc61b8b1907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">buildInputFromTrials</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final input Varnodes to <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis.  <a href="#a1bb49b65cf036e8bc8b398e549b26a9c">More...</a><br /></td></tr>
<tr class="separator:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f172165e29fbabfbb02be245ee1c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">buildOutputFromTrials</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;trialvn)</td></tr>
<tr class="memdesc:a15f172165e29fbabfbb02be245ee1c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis of trials.  <a href="#a15f172165e29fbabfbb02be245ee1c98">More...</a><br /></td></tr>
<tr class="separator:a15f172165e29fbabfbb02be245ee1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7e27183972392fae6a23127d8302ec"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a8f7e27183972392fae6a23127d8302ec">getInputBytesConsumed</a> (int4 slot) const </td></tr>
<tr class="memdesc:a8f7e27183972392fae6a23127d8302ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the estimated number of bytes within the given parameter that are consumed.  <a href="#a8f7e27183972392fae6a23127d8302ec">More...</a><br /></td></tr>
<tr class="separator:a8f7e27183972392fae6a23127d8302ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216c014e3072c48a36fbea0be650349e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a216c014e3072c48a36fbea0be650349e">setInputBytesConsumed</a> (int4 slot, int4 val) const </td></tr>
<tr class="memdesc:a216c014e3072c48a36fbea0be650349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the estimated number of bytes within the given parameter that are consumed.  <a href="#a216c014e3072c48a36fbea0be650349e">More...</a><br /></td></tr>
<tr class="separator:a216c014e3072c48a36fbea0be650349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac7bcd5ea5ed14adbe74b4ca4c7e0814"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aac7bcd5ea5ed14adbe74b4ca4c7e0814">paramshiftModifyStart</a> (void)</td></tr>
<tr class="memdesc:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend any extra parameters if a paramshift is required. <br /></td></tr>
<tr class="separator:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a01e16ebebb71bdc63fb884c8d0e3b7e3">paramshiftModifyStop</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw out any paramshift parameters.  <a href="#a01e16ebebb71bdc63fb884c8d0e3b7e3">More...</a><br /></td></tr>
<tr class="separator:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f782d0e91a83336fa722483c79d42aa"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a2f782d0e91a83336fa722483c79d42aa">hasEffectTranslate</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:a2f782d0e91a83336fa722483c79d42aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate type of side-effect for a given storage location (with caller translation)  <a href="#a2f782d0e91a83336fa722483c79d42aa">More...</a><br /></td></tr>
<tr class="separator:a2f782d0e91a83336fa722483c79d42aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFuncProto"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFuncProto')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFuncProto.html">FuncProto</a></td></tr>
<tr class="memitem:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c7db7dec63a18a9de97b0ba9f6f42bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9c7db7dec63a18a9de97b0ba9f6f42bd">FuncProto</a> (void)</td></tr>
<tr class="memdesc:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142706f5f3c9086635f812501521f3b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a142706f5f3c9086635f812501521f3b4">~FuncProto</a> (void)</td></tr>
<tr class="memdesc:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00b0b2e61b845d3fd66c6e3ad7e028b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af00b0b2e61b845d3fd66c6e3ad7e028b"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af00b0b2e61b845d3fd66c6e3ad7e028b">getArch</a> (void) const </td></tr>
<tr class="memdesc:af00b0b2e61b845d3fd66c6e3ad7e028b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> owning <b>this</b>. <br /></td></tr>
<tr class="separator:af00b0b2e61b845d3fd66c6e3ad7e028b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">copy</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another function prototype.  <a href="#a9bd4f3bc764b11b57f4e71b9d19df27d">More...</a><br /></td></tr>
<tr class="separator:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace26c345cdf567de704b24cd99e8a254"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace26c345cdf567de704b24cd99e8a254">copyFlowEffects</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy properties that affect data-flow. <br /></td></tr>
<tr class="separator:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b8d7ee2d89654f589f62ed7f02af8 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6b2b8d7ee2d89654f589f62ed7f02af8">getPieces</a> (<a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces) const </td></tr>
<tr class="memdesc:a6b2b8d7ee2d89654f589f62ed7f02af8 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw pieces of the prototype.  <a href="#a6b2b8d7ee2d89654f589f62ed7f02af8">More...</a><br /></td></tr>
<tr class="separator:a6b2b8d7ee2d89654f589f62ed7f02af8 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8e6f53c7733c8aa58d9138a8f3add2ce">setPieces</a> (const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces)</td></tr>
<tr class="memdesc:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> prototype based on raw pieces.  <a href="#a8e6f53c7733c8aa58d9138a8f3add2ce">More...</a><br /></td></tr>
<tr class="separator:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">setScope</a> (<a class="el" href="classScope.html">Scope</a> *s, const <a class="el" href="classAddress.html">Address</a> &amp;startpoint)</td></tr>
<tr class="memdesc:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a backing symbol <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> for <b>this</b>.  <a href="#adc83eddece4cb123d198ad288dfa89bd">More...</a><br /></td></tr>
<tr class="separator:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699">setInternal</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m, <a class="el" href="classDatatype.html">Datatype</a> *vt)</td></tr>
<tr class="memdesc:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set internal backing storage for <b>this</b>.  <a href="#af69f89b0b3c5165e521d33b658599699">More...</a><br /></td></tr>
<tr class="separator:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae8c14d15c7296c47deae3433687b1b15">setModel</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m)</td></tr>
<tr class="memdesc:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the prototype model for <b>this</b>.  <a href="#ae8c14d15c7296c47deae3433687b1b15">More...</a><br /></td></tr>
<tr class="separator:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13789408c17e4ae93280f6043ea051a8 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13789408c17e4ae93280f6043ea051a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a13789408c17e4ae93280f6043ea051a8">hasModel</a> (void) const </td></tr>
<tr class="memdesc:a13789408c17e4ae93280f6043ea051a8 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> prototype have a model. <br /></td></tr>
<tr class="separator:a13789408c17e4ae93280f6043ea051a8 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb7a86abc4cdae2aad0f5104f374c7 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7fb7a86abc4cdae2aad0f5104f374c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad7fb7a86abc4cdae2aad0f5104f374c7">hasMatchingModel</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> *op2) const </td></tr>
<tr class="memdesc:ad7fb7a86abc4cdae2aad0f5104f374c7 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> have a matching model. <br /></td></tr>
<tr class="separator:ad7fb7a86abc4cdae2aad0f5104f374c7 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac5ccbadf105478e51f8f7773cf369e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeac5ccbadf105478e51f8f7773cf369e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aeac5ccbadf105478e51f8f7773cf369e">hasMatchingModel</a> (const <a class="el" href="classProtoModel.html">ProtoModel</a> *op2) const </td></tr>
<tr class="memdesc:aeac5ccbadf105478e51f8f7773cf369e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> use the given model. <br /></td></tr>
<tr class="separator:aeac5ccbadf105478e51f8f7773cf369e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ab2e02f3915ee505485c186d5c5d93 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11ab2e02f3915ee505485c186d5c5d93"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a11ab2e02f3915ee505485c186d5c5d93">getModelName</a> (void) const </td></tr>
<tr class="memdesc:a11ab2e02f3915ee505485c186d5c5d93 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the prototype model name. <br /></td></tr>
<tr class="separator:a11ab2e02f3915ee505485c186d5c5d93 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7b20667b3db5b4855ffab044f346e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5b7b20667b3db5b4855ffab044f346e"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac5b7b20667b3db5b4855ffab044f346e">getModelExtraPop</a> (void) const </td></tr>
<tr class="memdesc:ac5b7b20667b3db5b4855ffab044f346e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>extrapop</em> of the prototype model. <br /></td></tr>
<tr class="separator:ac5b7b20667b3db5b4855ffab044f346e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea485adaba5702435dc089d2648e1d49 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea485adaba5702435dc089d2648e1d49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aea485adaba5702435dc089d2648e1d49">isInputLocked</a> (void) const </td></tr>
<tr class="memdesc:aea485adaba5702435dc089d2648e1d49 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are input data-types locked. <br /></td></tr>
<tr class="separator:aea485adaba5702435dc089d2648e1d49 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1f88b093e5171128ab22918523fe24 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd1f88b093e5171128ab22918523fe24"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afd1f88b093e5171128ab22918523fe24">isOutputLocked</a> (void) const </td></tr>
<tr class="memdesc:afd1f88b093e5171128ab22918523fe24 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the output data-type locked. <br /></td></tr>
<tr class="separator:afd1f88b093e5171128ab22918523fe24 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bb700410ebb96b7c61f78727f00297 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28bb700410ebb96b7c61f78727f00297"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a28bb700410ebb96b7c61f78727f00297">isModelLocked</a> (void) const </td></tr>
<tr class="memdesc:a28bb700410ebb96b7c61f78727f00297 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the prototype model for <b>this</b> locked. <br /></td></tr>
<tr class="separator:a28bb700410ebb96b7c61f78727f00297 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456b9cdb2e397d44ff6df1a4093d6e87 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a456b9cdb2e397d44ff6df1a4093d6e87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a456b9cdb2e397d44ff6df1a4093d6e87">isUnknownModel</a> (void) const </td></tr>
<tr class="memdesc:a456b9cdb2e397d44ff6df1a4093d6e87 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is prototype model officially "unknown". <br /></td></tr>
<tr class="separator:a456b9cdb2e397d44ff6df1a4093d6e87 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651695b4cf7caa3a6af56b2a6126592 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8651695b4cf7caa3a6af56b2a6126592"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8651695b4cf7caa3a6af56b2a6126592">hasCustomStorage</a> (void) const </td></tr>
<tr class="memdesc:a8651695b4cf7caa3a6af56b2a6126592 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a "custom" function prototype. <br /></td></tr>
<tr class="separator:a8651695b4cf7caa3a6af56b2a6126592 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">setInputLock</a> (bool val)</td></tr>
<tr class="memdesc:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on input parameters.  <a href="#a4afe216709633a3b075111d6f1b7148f">More...</a><br /></td></tr>
<tr class="separator:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a7593a0880a632bce714a376244ef4f9a">setOutputLock</a> (bool val)</td></tr>
<tr class="memdesc:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on the return value.  <a href="#a7593a0880a632bce714a376244ef4f9a">More...</a><br /></td></tr>
<tr class="separator:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acc303c449c418dd875319c6f6cd9436f">setModelLock</a> (bool val)</td></tr>
<tr class="memdesc:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the lock on the prototype model for <b>this</b>.  <a href="#acc303c449c418dd875319c6f6cd9436f">More...</a><br /></td></tr>
<tr class="separator:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ef8c7a2b09476fcfbdf21cd8a01fbf inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ef8c7a2b09476fcfbdf21cd8a01fbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a93ef8c7a2b09476fcfbdf21cd8a01fbf">isInline</a> (void) const </td></tr>
<tr class="memdesc:a93ef8c7a2b09476fcfbdf21cd8a01fbf inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function get <em>in-lined</em> during decompilation. <br /></td></tr>
<tr class="separator:a93ef8c7a2b09476fcfbdf21cd8a01fbf inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a843bc3ca11536028c5cb00ce5479182d">setInline</a> (bool val)</td></tr>
<tr class="memdesc:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>in-line</em> setting for functions with <b>this</b> prototype.  <a href="#a843bc3ca11536028c5cb00ce5479182d">More...</a><br /></td></tr>
<tr class="separator:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a76cc76c0db3fbb3a195497b0e5d6b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad9a76cc76c0db3fbb3a195497b0e5d6b">getInjectId</a> (void) const </td></tr>
<tr class="memdesc:ad9a76cc76c0db3fbb3a195497b0e5d6b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the injection id associated with <b>this</b>.  <a href="#ad9a76cc76c0db3fbb3a195497b0e5d6b">More...</a><br /></td></tr>
<tr class="separator:ad9a76cc76c0db3fbb3a195497b0e5d6b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b68b5cd7ac131ac02b0761ae5e9ff2 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a30b68b5cd7ac131ac02b0761ae5e9ff2">getReturnBytesConsumed</a> (void) const </td></tr>
<tr class="memdesc:a30b68b5cd7ac131ac02b0761ae5e9ff2 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an estimate of the number of bytes consumed by callers of <b>this</b> prototype.  <a href="#a30b68b5cd7ac131ac02b0761ae5e9ff2">More...</a><br /></td></tr>
<tr class="separator:a30b68b5cd7ac131ac02b0761ae5e9ff2 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abd05102695a39cdad0170eeb92884b3a">setReturnBytesConsumed</a> (int4 val)</td></tr>
<tr class="memdesc:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of bytes consumed by callers of <b>this</b>.  <a href="#abd05102695a39cdad0170eeb92884b3a">More...</a><br /></td></tr>
<tr class="separator:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f6374aa63909ba29c707218977a6a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9f6374aa63909ba29c707218977a6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8b9f6374aa63909ba29c707218977a6a">isNoReturn</a> (void) const </td></tr>
<tr class="memdesc:a8b9f6374aa63909ba29c707218977a6a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a function with <b>this</b> prototype never return. <br /></td></tr>
<tr class="separator:a8b9f6374aa63909ba29c707218977a6a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aacaf0bda9b424dfd5c6a28d3a45fb100">setNoReturn</a> (bool val)</td></tr>
<tr class="memdesc:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>no-return</em> setting for functions with <b>this</b> prototype.  <a href="#aacaf0bda9b424dfd5c6a28d3a45fb100">More...</a><br /></td></tr>
<tr class="separator:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542e5292caab46acd79baeefbbf1dd9e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a542e5292caab46acd79baeefbbf1dd9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a542e5292caab46acd79baeefbbf1dd9e">hasThisPointer</a> (void) const </td></tr>
<tr class="memdesc:a542e5292caab46acd79baeefbbf1dd9e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a prototype for a class method, taking a <em>this</em> pointer. <br /></td></tr>
<tr class="separator:a542e5292caab46acd79baeefbbf1dd9e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa63d717686011c29949077e426d50 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2aa63d717686011c29949077e426d50"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad2aa63d717686011c29949077e426d50">isConstructor</a> (void) const </td></tr>
<tr class="memdesc:ad2aa63d717686011c29949077e426d50 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class constructor method. <br /></td></tr>
<tr class="separator:ad2aa63d717686011c29949077e426d50 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1ff2f80e5cf4043147ccd83a863ee83f">setConstructor</a> (bool val)</td></tr>
<tr class="memdesc:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>constructor</em> method.  <a href="#a1ff2f80e5cf4043147ccd83a863ee83f">More...</a><br /></td></tr>
<tr class="separator:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd47f48645a6c80e1a66443b360958e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdd47f48645a6c80e1a66443b360958e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abdd47f48645a6c80e1a66443b360958e">isDestructor</a> (void) const </td></tr>
<tr class="memdesc:abdd47f48645a6c80e1a66443b360958e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class destructor method. <br /></td></tr>
<tr class="separator:abdd47f48645a6c80e1a66443b360958e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa191f5c52ce98ba14ef14f63a763a7da">setDestructor</a> (bool val)</td></tr>
<tr class="memdesc:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>destructor</em> method.  <a href="#aa191f5c52ce98ba14ef14f63a763a7da">More...</a><br /></td></tr>
<tr class="separator:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9da3b32d9b55d944ee659087fbd2ed inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9da3b32d9b55d944ee659087fbd2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9c9da3b32d9b55d944ee659087fbd2ed">hasInputErrors</a> (void) const </td></tr>
<tr class="memdesc:a9c9da3b32d9b55d944ee659087fbd2ed inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect input parameter descriptions. <br /></td></tr>
<tr class="separator:a9c9da3b32d9b55d944ee659087fbd2ed inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed327cece6d30cbb03de61c7472b4d63 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed327cece6d30cbb03de61c7472b4d63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aed327cece6d30cbb03de61c7472b4d63">hasOutputErrors</a> (void) const </td></tr>
<tr class="memdesc:aed327cece6d30cbb03de61c7472b4d63 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect return value description. <br /></td></tr>
<tr class="separator:aed327cece6d30cbb03de61c7472b4d63 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">setInputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the input error setting for <b>this</b> prototype.  <a href="#ad5f36aaa3e2d1d7cdc90d101065abbc0">More...</a><br /></td></tr>
<tr class="separator:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">setOutputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the output error setting for <b>this</b> prototype.  <a href="#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">More...</a><br /></td></tr>
<tr class="separator:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ce1430cfc4d82aea46aa0fdc4ca7a7 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92ce1430cfc4d82aea46aa0fdc4ca7a7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a92ce1430cfc4d82aea46aa0fdc4ca7a7">getExtraPop</a> (void) const </td></tr>
<tr class="memdesc:a92ce1430cfc4d82aea46aa0fdc4ca7a7 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the general <em>extrapop</em> setting for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:a92ce1430cfc4d82aea46aa0fdc4ca7a7 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32fa24642ff5423ec167e6f8bca065a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af32fa24642ff5423ec167e6f8bca065a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af32fa24642ff5423ec167e6f8bca065a">setExtraPop</a> (int4 ep)</td></tr>
<tr class="memdesc:af32fa24642ff5423ec167e6f8bca065a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the general <em>extrapop</em> for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:af32fa24642ff5423ec167e6f8bca065a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf11c169a30501c86c760933c22b276 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaf11c169a30501c86c760933c22b276"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aaaf11c169a30501c86c760933c22b276">getInjectUponEntry</a> (void) const </td></tr>
<tr class="memdesc:aaaf11c169a30501c86c760933c22b276 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any <em>upon-entry</em> injection id (or -1) <br /></td></tr>
<tr class="separator:aaaf11c169a30501c86c760933c22b276 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3928162e5f03fe83a86be8d499fb3705 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3928162e5f03fe83a86be8d499fb3705"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3928162e5f03fe83a86be8d499fb3705">getInjectUponReturn</a> (void) const </td></tr>
<tr class="memdesc:a3928162e5f03fe83a86be8d499fb3705 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any <em>upon-return</em> injection id (or -1) <br /></td></tr>
<tr class="separator:a3928162e5f03fe83a86be8d499fb3705 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a22889d3a526dce245368b8de9c889529">resolveExtraPop</a> (void)</td></tr>
<tr class="memdesc:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <b>this</b> prototype is locked, calculate the <em>extrapop</em>.  <a href="#a22889d3a526dce245368b8de9c889529">More...</a><br /></td></tr>
<tr class="separator:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91eb49088323b42bdb38b83586eea6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae91eb49088323b42bdb38b83586eea6f">clearUnlockedInput</a> (void)</td></tr>
<tr class="memdesc:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input parameters that have not been locked. <br /></td></tr>
<tr class="separator:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c7428f70c6c7e040b4d090f3efeee08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3c7428f70c6c7e040b4d090f3efeee08">clearUnlockedOutput</a> (void)</td></tr>
<tr class="memdesc:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the return value if it has not been locked. <br /></td></tr>
<tr class="separator:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8059930e66577c8906ade2f36f65cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af8059930e66577c8906ade2f36f65cce">clearInput</a> (void)</td></tr>
<tr class="memdesc:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all input parameters regardless of lock. <br /></td></tr>
<tr class="separator:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bb585835251e43a5c9f644519e69dc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0bb585835251e43a5c9f644519e69dc0">cancelInjectId</a> (void)</td></tr>
<tr class="memdesc:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn-off any in-lining for this function. <br /></td></tr>
<tr class="separator:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afd3b71963b55dd19755eeaccd016c4bf">resolveModel</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active)</td></tr>
<tr class="memdesc:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>this</b> has a <em>merged</em> model, pick the most likely model (from the merged set)  <a href="#afd3b71963b55dd19755eeaccd016c4bf">More...</a><br /></td></tr>
<tr class="separator:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaba4c71323374c0c056922ff1bb7b2 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aacaba4c71323374c0c056922ff1bb7b2">deriveInputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const </td></tr>
<tr class="memdesc:aacaba4c71323374c0c056922ff1bb7b2 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of input <em>trials</em>, derive the most likely inputs for <b>this</b> prototype.  <a href="#aacaba4c71323374c0c056922ff1bb7b2">More...</a><br /></td></tr>
<tr class="separator:aacaba4c71323374c0c056922ff1bb7b2 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629ceb32fa6bd296038fa56347570789 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a629ceb32fa6bd296038fa56347570789">deriveOutputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const </td></tr>
<tr class="memdesc:a629ceb32fa6bd296038fa56347570789 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of output <em>trials</em>, derive the most likely return value for <b>this</b> prototype.  <a href="#a629ceb32fa6bd296038fa56347570789">More...</a><br /></td></tr>
<tr class="separator:a629ceb32fa6bd296038fa56347570789 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2b22892816eb75517aa5f84a3aada1 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afc2b22892816eb75517aa5f84a3aada1">checkInputJoin</a> (const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz) const </td></tr>
<tr class="memdesc:afc2b22892816eb75517aa5f84a3aada1 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given two input storage locations can represent a single logical parameter.  <a href="#afc2b22892816eb75517aa5f84a3aada1">More...</a><br /></td></tr>
<tr class="separator:afc2b22892816eb75517aa5f84a3aada1 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee79f9d371fb681fb91bf6761138dade inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aee79f9d371fb681fb91bf6761138dade">checkInputSplit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 splitpoint) const </td></tr>
<tr class="memdesc:aee79f9d371fb681fb91bf6761138dade inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if it makes sense to split a single storage location into two input parameters.  <a href="#aee79f9d371fb681fb91bf6761138dade">More...</a><br /></td></tr>
<tr class="separator:aee79f9d371fb681fb91bf6761138dade inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89afc199ba2c4c8261dac381c5e426b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae89afc199ba2c4c8261dac381c5e426b">updateInputTypes</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput)</td></tr>
<tr class="memdesc:ae89afc199ba2c4c8261dac381c5e426b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials.  <a href="#ae89afc199ba2c4c8261dac381c5e426b">More...</a><br /></td></tr>
<tr class="separator:ae89afc199ba2c4c8261dac381c5e426b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33463f351b0ebc8c8f6065eff896dbc3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a33463f351b0ebc8c8f6065eff896dbc3">updateInputNoTypes</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput)</td></tr>
<tr class="memdesc:a33463f351b0ebc8c8f6065eff896dbc3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but do not store the data-type.  <a href="#a33463f351b0ebc8c8f6065eff896dbc3">More...</a><br /></td></tr>
<tr class="separator:a33463f351b0ebc8c8f6065eff896dbc3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cbde2e23cdcf41ddb870721e02be6b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a56cbde2e23cdcf41ddb870721e02be6b">updateOutputTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist)</td></tr>
<tr class="memdesc:a56cbde2e23cdcf41ddb870721e02be6b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials.  <a href="#a56cbde2e23cdcf41ddb870721e02be6b">More...</a><br /></td></tr>
<tr class="separator:a56cbde2e23cdcf41ddb870721e02be6b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e34d08f3e4e44ba5aa25b87c84bfe inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a882e34d08f3e4e44ba5aa25b87c84bfe">updateOutputNoTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classTypeFactory.html">TypeFactory</a> *factory)</td></tr>
<tr class="memdesc:a882e34d08f3e4e44ba5aa25b87c84bfe inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but don't store the data-type.  <a href="#a882e34d08f3e4e44ba5aa25b87c84bfe">More...</a><br /></td></tr>
<tr class="separator:a882e34d08f3e4e44ba5aa25b87c84bfe inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad6aba5f6731281a4c16fdfac76de2c inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9ad6aba5f6731281a4c16fdfac76de2c">updateAllTypes</a> (const vector&lt; string &gt; &amp;namelist, const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;typelist, bool dtdtdt)</td></tr>
<tr class="memdesc:a9ad6aba5f6731281a4c16fdfac76de2c inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> entire function prototype based on a list of names and data-types.  <a href="#a9ad6aba5f6731281a4c16fdfac76de2c">More...</a><br /></td></tr>
<tr class="separator:a9ad6aba5f6731281a4c16fdfac76de2c inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2e2a05a468048ecefb2b18b81f37a6 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2e2a05a468048ecefb2b18b81f37a6"></a>
<a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6c2e2a05a468048ecefb2b18b81f37a6">getParam</a> (int4 i) const </td></tr>
<tr class="memdesc:a6c2e2a05a468048ecefb2b18b81f37a6 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th input parameter. <br /></td></tr>
<tr class="separator:a6c2e2a05a468048ecefb2b18b81f37a6 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9a8f192846b36ba99ed0464bb10862 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc9a8f192846b36ba99ed0464bb10862"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abc9a8f192846b36ba99ed0464bb10862">removeParam</a> (int4 i)</td></tr>
<tr class="memdesc:abc9a8f192846b36ba99ed0464bb10862 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the i-th input parameter. <br /></td></tr>
<tr class="separator:abc9a8f192846b36ba99ed0464bb10862 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a078e76c55eacf3f979ba0fc61d2e7 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a078e76c55eacf3f979ba0fc61d2e7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae6a078e76c55eacf3f979ba0fc61d2e7">numParams</a> (void) const </td></tr>
<tr class="memdesc:ae6a078e76c55eacf3f979ba0fc61d2e7 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of input parameters. <br /></td></tr>
<tr class="separator:ae6a078e76c55eacf3f979ba0fc61d2e7 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c788810868e06307d9c324c824e1d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a007c788810868e06307d9c324c824e1d"></a>
<a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a007c788810868e06307d9c324c824e1d">getOutput</a> (void) const </td></tr>
<tr class="memdesc:a007c788810868e06307d9c324c824e1d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return value. <br /></td></tr>
<tr class="separator:a007c788810868e06307d9c324c824e1d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fdfce821c12a33707447c88ca6e4bf inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99fdfce821c12a33707447c88ca6e4bf"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a99fdfce821c12a33707447c88ca6e4bf">getOutputType</a> (void) const </td></tr>
<tr class="memdesc:a99fdfce821c12a33707447c88ca6e4bf inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return value data-type. <br /></td></tr>
<tr class="separator:a99fdfce821c12a33707447c88ca6e4bf inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae30180888dcceaaa650b6f209ccb77 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae30180888dcceaaa650b6f209ccb77"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aaae30180888dcceaaa650b6f209ccb77">getLocalRange</a> (void) const </td></tr>
<tr class="memdesc:aaae30180888dcceaaa650b6f209ccb77 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of potential local stack variables. <br /></td></tr>
<tr class="separator:aaae30180888dcceaaa650b6f209ccb77 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4afb65306836b7e095666c6c08fc6d8 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4afb65306836b7e095666c6c08fc6d8"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae4afb65306836b7e095666c6c08fc6d8">getParamRange</a> (void) const </td></tr>
<tr class="memdesc:ae4afb65306836b7e095666c6c08fc6d8 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of potential stack parameters. <br /></td></tr>
<tr class="separator:ae4afb65306836b7e095666c6c08fc6d8 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d8b4daf3c381c86b3172987bca1360 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d8b4daf3c381c86b3172987bca1360"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a08d8b4daf3c381c86b3172987bca1360">isStackGrowsNegative</a> (void) const </td></tr>
<tr class="memdesc:a08d8b4daf3c381c86b3172987bca1360 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if the stack grows toward smaller addresses. <br /></td></tr>
<tr class="separator:a08d8b4daf3c381c86b3172987bca1360 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884776a324e2f548b8c9509b844aacb3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884776a324e2f548b8c9509b844aacb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a884776a324e2f548b8c9509b844aacb3">isDotdotdot</a> (void) const </td></tr>
<tr class="memdesc:a884776a324e2f548b8c9509b844aacb3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> takes a variable number of arguments. <br /></td></tr>
<tr class="separator:a884776a324e2f548b8c9509b844aacb3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d237b521223b740d5d052b68966b556 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d237b521223b740d5d052b68966b556"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6d237b521223b740d5d052b68966b556">setDotdotdot</a> (bool val)</td></tr>
<tr class="memdesc:a6d237b521223b740d5d052b68966b556 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> takes variable arguments. <br /></td></tr>
<tr class="separator:a6d237b521223b740d5d052b68966b556 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e7092572b8d514b6d74c953944080 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace8e7092572b8d514b6d74c953944080"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace8e7092572b8d514b6d74c953944080">isOverride</a> (void) const </td></tr>
<tr class="memdesc:ace8e7092572b8d514b6d74c953944080 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> is a call site override. <br /></td></tr>
<tr class="separator:ace8e7092572b8d514b6d74c953944080 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827a8f9335cbb8587a566d8e1765d5a2 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a827a8f9335cbb8587a566d8e1765d5a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a827a8f9335cbb8587a566d8e1765d5a2">setOverride</a> (bool val)</td></tr>
<tr class="memdesc:a827a8f9335cbb8587a566d8e1765d5a2 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> is a call site override. <br /></td></tr>
<tr class="separator:a827a8f9335cbb8587a566d8e1765d5a2 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116dd89589cc36e9c822426838658871 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a116dd89589cc36e9c822426838658871">hasEffect</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:a116dd89589cc36e9c822426838658871 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effect <b>this</b> has an a given storage location.  <a href="#a116dd89589cc36e9c822426838658871">More...</a><br /></td></tr>
<tr class="separator:a116dd89589cc36e9c822426838658871 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70399bdfec836ca56808f7e01a80a46a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70399bdfec836ca56808f7e01a80a46a"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a70399bdfec836ca56808f7e01a80a46a">effectBegin</a> (void) const </td></tr>
<tr class="memdesc:a70399bdfec836ca56808f7e01a80a46a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to front of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:a70399bdfec836ca56808f7e01a80a46a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade59fd4d6ada7abffefa727e918622c4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade59fd4d6ada7abffefa727e918622c4"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ade59fd4d6ada7abffefa727e918622c4">effectEnd</a> (void) const </td></tr>
<tr class="memdesc:ade59fd4d6ada7abffefa727e918622c4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to end of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:ade59fd4d6ada7abffefa727e918622c4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ba8eb1fe9b3a22a6db69492caa7ab6 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a31ba8eb1fe9b3a22a6db69492caa7ab6">numLikelyTrash</a> (void) const </td></tr>
<tr class="memdesc:a31ba8eb1fe9b3a22a6db69492caa7ab6 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <em>likely-trash</em> locations.  <a href="#a31ba8eb1fe9b3a22a6db69492caa7ab6">More...</a><br /></td></tr>
<tr class="separator:a31ba8eb1fe9b3a22a6db69492caa7ab6 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f5fae79b01744c1f192dc321e45208 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a44f5fae79b01744c1f192dc321e45208">getLikelyTrash</a> (int4 i) const </td></tr>
<tr class="memdesc:a44f5fae79b01744c1f192dc321e45208 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th <em>likely-trash</em> location.  <a href="#a44f5fae79b01744c1f192dc321e45208">More...</a><br /></td></tr>
<tr class="separator:a44f5fae79b01744c1f192dc321e45208 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7f34957c913ca07bae0c9547c7ecf9 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aea7f34957c913ca07bae0c9547c7ecf9">characterizeAsInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:aea7f34957c913ca07bae0c9547c7ecf9 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be, or could hold, an input parameter.  <a href="#aea7f34957c913ca07bae0c9547c7ecf9">More...</a><br /></td></tr>
<tr class="separator:aea7f34957c913ca07bae0c9547c7ecf9 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa391f4e68cb3e704ed02f09f492359b7 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa391f4e68cb3e704ed02f09f492359b7">possibleInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:aa391f4e68cb3e704ed02f09f492359b7 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be an input parameter.  <a href="#aa391f4e68cb3e704ed02f09f492359b7">More...</a><br /></td></tr>
<tr class="separator:aa391f4e68cb3e704ed02f09f492359b7 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d78264270ac627f7fb50bf582510861 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0d78264270ac627f7fb50bf582510861">possibleOutputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:a0d78264270ac627f7fb50bf582510861 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be a return value.  <a href="#a0d78264270ac627f7fb50bf582510861">More...</a><br /></td></tr>
<tr class="separator:a0d78264270ac627f7fb50bf582510861 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e48e3d5705fca6d20e3cb6091ff600 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af8e48e3d5705fca6d20e3cb6091ff600">getMaxInputDelay</a> (void) const </td></tr>
<tr class="memdesc:af8e48e3d5705fca6d20e3cb6091ff600 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible input parameters.  <a href="#af8e48e3d5705fca6d20e3cb6091ff600">More...</a><br /></td></tr>
<tr class="separator:af8e48e3d5705fca6d20e3cb6091ff600 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293543ad3d0de9d6f13489acb0f4cf5b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a293543ad3d0de9d6f13489acb0f4cf5b">getMaxOutputDelay</a> (void) const </td></tr>
<tr class="memdesc:a293543ad3d0de9d6f13489acb0f4cf5b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible return values.  <a href="#a293543ad3d0de9d6f13489acb0f4cf5b">More...</a><br /></td></tr>
<tr class="separator:a293543ad3d0de9d6f13489acb0f4cf5b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd0d3d5c6568b3102ac220afde1649d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3cd0d3d5c6568b3102ac220afde1649d">unjustifiedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:a3cd0d3d5c6568b3102ac220afde1649d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given storage location looks like an <em>unjustified</em> input parameter.  <a href="#a3cd0d3d5c6568b3102ac220afde1649d">More...</a><br /></td></tr>
<tr class="separator:a3cd0d3d5c6568b3102ac220afde1649d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b575b6e4e078a57f5050cf8669cd5 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afb3b575b6e4e078a57f5050cf8669cd5">assumedInputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:afb3b575b6e4e078a57f5050cf8669cd5 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing input parameter for the given storage.  <a href="#afb3b575b6e4e078a57f5050cf8669cd5">More...</a><br /></td></tr>
<tr class="separator:afb3b575b6e4e078a57f5050cf8669cd5 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125e6b494f6c1610b5cfde5cbeaf583b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a125e6b494f6c1610b5cfde5cbeaf583b">assumedOutputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:a125e6b494f6c1610b5cfde5cbeaf583b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing return value location for the given storage.  <a href="#a125e6b494f6c1610b5cfde5cbeaf583b">More...</a><br /></td></tr>
<tr class="separator:a125e6b494f6c1610b5cfde5cbeaf583b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0977d7bbeb3feb291f9bba86e127e3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1b0977d7bbeb3feb291f9bba86e127e3">getBiggestContainedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:a1b0977d7bbeb3feb291f9bba86e127e3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the biggest potential input parameter contained within the given range.  <a href="#a1b0977d7bbeb3feb291f9bba86e127e3">More...</a><br /></td></tr>
<tr class="separator:a1b0977d7bbeb3feb291f9bba86e127e3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5002ce3745f1bfcc63de287def37080 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af5002ce3745f1bfcc63de287def37080">isCompatible</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2) const </td></tr>
<tr class="memdesc:af5002ce3745f1bfcc63de287def37080 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if <b>this</b> can be safely restricted to match another prototype.  <a href="#af5002ce3745f1bfcc63de287def37080">More...</a><br /></td></tr>
<tr class="separator:af5002ce3745f1bfcc63de287def37080 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee77105cc94d27f7f23399f6b8d7485d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee77105cc94d27f7f23399f6b8d7485d"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aee77105cc94d27f7f23399f6b8d7485d">getSpacebase</a> (void) const </td></tr>
<tr class="memdesc:aee77105cc94d27f7f23399f6b8d7485d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>stack</em> address space. <br /></td></tr>
<tr class="separator:aee77105cc94d27f7f23399f6b8d7485d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa091ef811ff6637ada75d39238f1db89 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa091ef811ff6637ada75d39238f1db89">printRaw</a> (const string &amp;funcname, ostream &amp;s) const </td></tr>
<tr class="memdesc:aa091ef811ff6637ada75d39238f1db89 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <b>this</b> prototype as a single line of text.  <a href="#aa091ef811ff6637ada75d39238f1db89">More...</a><br /></td></tr>
<tr class="separator:aa091ef811ff6637ada75d39238f1db89 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af419fd1cdb7f73c724795c03a6e4463f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af419fd1cdb7f73c724795c03a6e4463f">getComparableFlags</a> (void) const </td></tr>
<tr class="memdesc:af419fd1cdb7f73c724795c03a6e4463f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comparable properties of <b>this</b> prototype.  <a href="#af419fd1cdb7f73c724795c03a6e4463f">More...</a><br /></td></tr>
<tr class="separator:af419fd1cdb7f73c724795c03a6e4463f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d423d90f94aaed9c6f943a9e3b0e7b8 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9d423d90f94aaed9c6f943a9e3b0e7b8">saveXml</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a9d423d90f94aaed9c6f943a9e3b0e7b8 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <b>this</b> to an XML stream as a &lt;prototype&gt; tag.  <a href="#a9d423d90f94aaed9c6f943a9e3b0e7b8">More...</a><br /></td></tr>
<tr class="separator:a9d423d90f94aaed9c6f943a9e3b0e7b8 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el, <a class="el" href="classArchitecture.html">Architecture</a> *glb)</td></tr>
<tr class="memdesc:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> from an XML stream.  <a href="#a4c4f9da74ee904e6abfa195bd843521e">More...</a><br /></td></tr>
<tr class="separator:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9a59b9321b66bc9f23e69d2ef729258c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9a59b9321b66bc9f23e69d2ef729258c">findPreexistingWhole</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn1, <a class="el" href="classVarnode.html">Varnode</a> *vn2)</td></tr>
<tr class="memdesc:a9a59b9321b66bc9f23e69d2ef729258c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given two Varnodes are merged into a whole.  <a href="#a9a59b9321b66bc9f23e69d2ef729258c">More...</a><br /></td></tr>
<tr class="separator:a9a59b9321b66bc9f23e69d2ef729258c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aa1d084c81a9ae8656d7ef79c84398dc8">getFspecFromConst</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classFspecSpace.html" title="A special space for encoding FuncCallSpecs. ">FspecSpace</a> addresses to the underlying <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> object.  <a href="#aa1d084c81a9ae8656d7ef79c84398dc8">More...</a><br /></td></tr>
<tr class="separator:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a57f3844d92136d3ab6b67ea9ea316aa7">compareByEntryAddress</a> (const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *a, const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *b)</td></tr>
<tr class="memdesc:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> by function entry address.  <a href="#a57f3844d92136d3ab6b67ea9ea316aa7">More...</a><br /></td></tr>
<tr class="separator:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6fc72a11289af288ec65f216d7a45b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aab6fc72a11289af288ec65f216d7a45b">countMatchingCalls</a> (const vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * &gt; &amp;qlst)</td></tr>
<tr class="memdesc:aab6fc72a11289af288ec65f216d7a45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of times an individual sub-function is called.  <a href="#aab6fc72a11289af288ec65f216d7a45b">More...</a><br /></td></tr>
<tr class="separator:aab6fc72a11289af288ec65f216d7a45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae97d6815ba495a094c2861bdcaeabdc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae97d6815ba495a094c2861bdcaeabdc5">getSpacebaseRelative</a> (void) const </td></tr>
<tr class="memdesc:ae97d6815ba495a094c2861bdcaeabdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> at <b>this</b> call site.  <a href="#ae97d6815ba495a094c2861bdcaeabdc5">More...</a><br /></td></tr>
<tr class="separator:ae97d6815ba495a094c2861bdcaeabdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5f37e4556f80f027ae502a60092ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">buildParam</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classProtoParameter.html">ProtoParameter</a> *param, <a class="el" href="classVarnode.html">Varnode</a> *stackref)</td></tr>
<tr class="memdesc:aadf5f37e4556f80f027ae502a60092ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> representing a specific parameter.  <a href="#aadf5f37e4556f80f027ae502a60092ba">More...</a><br /></td></tr>
<tr class="separator:aadf5f37e4556f80f027ae502a60092ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea6ae61949247b9e8c4643ce68860e3"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a3ea6ae61949247b9e8c4643ce68860e3">transferLockedInputParam</a> (<a class="el" href="classProtoParameter.html">ProtoParameter</a> *param)</td></tr>
<tr class="memdesc:a3ea6ae61949247b9e8c4643ce68860e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the CALL input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that matches the given parameter.  <a href="#a3ea6ae61949247b9e8c4643ce68860e3">More...</a><br /></td></tr>
<tr class="separator:a3ea6ae61949247b9e8c4643ce68860e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077b8ed8181bb5523e1be06583d3d588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a077b8ed8181bb5523e1be06583d3d588">transferLockedOutputParam</a> (<a class="el" href="classProtoParameter.html">ProtoParameter</a> *param)</td></tr>
<tr class="separator:a077b8ed8181bb5523e1be06583d3d588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c269dac5b3730ea0093d2bc6841b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput</a> (vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newinput)</td></tr>
<tr class="memdesc:a51c269dac5b3730ea0093d2bc6841b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">List and/or create a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for each input parameter of <b>this</b> prototype.  <a href="#a51c269dac5b3730ea0093d2bc6841b07">More...</a><br /></td></tr>
<tr class="separator:a51c269dac5b3730ea0093d2bc6841b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1cb380c5ca6bf3d02f441cf582c50e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">transferLockedOutput</a> (<a class="el" href="classVarnode.html">Varnode</a> *&amp;newoutput)</td></tr>
<tr class="memdesc:aed1cb380c5ca6bf3d02f441cf582c50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass back the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> needed to match the output parameter (return value)  <a href="#aed1cb380c5ca6bf3d02f441cf582c50e">More...</a><br /></td></tr>
<tr class="separator:aed1cb380c5ca6bf3d02f441cf582c50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98405e6447b4ada292a557920b828d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;newinput)</td></tr>
<tr class="memdesc:a98405e6447b4ada292a557920b828d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input Varnodes to <b>this</b> CALL to reflect the formal input parameters.  <a href="#a98405e6447b4ada292a557920b828d67">More...</a><br /></td></tr>
<tr class="separator:a98405e6447b4ada292a557920b828d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa357f1ecfa3c9bd2ab86d958bb0670b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">commitNewOutputs</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *newout)</td></tr>
<tr class="memdesc:aa357f1ecfa3c9bd2ab86d958bb0670b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to <b>this</b> CALL to reflect the formal return value.  <a href="#aa357f1ecfa3c9bd2ab86d958bb0670b4">More...</a><br /></td></tr>
<tr class="separator:aa357f1ecfa3c9bd2ab86d958bb0670b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad241f5566eb01acaa77327da464c7984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad241f5566eb01acaa77327da464c7984">collectOutputTrialVarnodes</a> (vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;trialvn)</td></tr>
<tr class="separator:ad241f5566eb01acaa77327da464c7984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a42e16ea23d22a20d4c343f33a50307eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42e16ea23d22a20d4c343f33a50307eb"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a></td></tr>
<tr class="memdesc:a42e16ea23d22a20d4c343f33a50307eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to CALL or CALLIND instruction. <br /></td></tr>
<tr class="separator:a42e16ea23d22a20d4c343f33a50307eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4c4b25b4eba36052e847f41f110816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee4c4b25b4eba36052e847f41f110816"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aee4c4b25b4eba36052e847f41f110816">name</a></td></tr>
<tr class="memdesc:aee4c4b25b4eba36052e847f41f110816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of function if present. <br /></td></tr>
<tr class="separator:aee4c4b25b4eba36052e847f41f110816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d10d1b705fb05f1ce581b7a6eeed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c5d10d1b705fb05f1ce581b7a6eeed6"></a>
<a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a></td></tr>
<tr class="memdesc:a1c5d10d1b705fb05f1ce581b7a6eeed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">First executing address of function. <br /></td></tr>
<tr class="separator:a1c5d10d1b705fb05f1ce581b7a6eeed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade06e0fcf372e92f2b62ac1e188439be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade06e0fcf372e92f2b62ac1e188439be"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a></td></tr>
<tr class="memdesc:ade06e0fcf372e92f2b62ac1e188439be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object for the called functon (if known) <br /></td></tr>
<tr class="separator:ade06e0fcf372e92f2b62ac1e188439be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7fe0e7b3d1486e41e528a1deec61f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0af7fe0e7b3d1486e41e528a1deec61f"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0af7fe0e7b3d1486e41e528a1deec61f">effective_extrapop</a></td></tr>
<tr class="memdesc:a0af7fe0e7b3d1486e41e528a1deec61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Working extrapop for the CALL. <br /></td></tr>
<tr class="separator:a0af7fe0e7b3d1486e41e528a1deec61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c685ecd38c4da586b8c7bddc2fd1983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c685ecd38c4da586b8c7bddc2fd1983"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a></td></tr>
<tr class="memdesc:a0c685ecd38c4da586b8c7bddc2fd1983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative offset of stack-pointer at time of this call. <br /></td></tr>
<tr class="separator:a0c685ecd38c4da586b8c7bddc2fd1983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af655410c6704377c0d260b06fd532e22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af655410c6704377c0d260b06fd532e22"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a></td></tr>
<tr class="memdesc:af655410c6704377c0d260b06fd532e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot containing temporary stack tracing placeholder (-1 means unused) <br /></td></tr>
<tr class="separator:af655410c6704377c0d260b06fd532e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303b8605ffd3e4432fb7ca3c70759f2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a303b8605ffd3e4432fb7ca3c70759f2d"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a></td></tr>
<tr class="memdesc:a303b8605ffd3e4432fb7ca3c70759f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of input parameters to ignore before prototype. <br /></td></tr>
<tr class="separator:a303b8605ffd3e4432fb7ca3c70759f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ee88ee6bc22078cb8f03dd71ea87d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33ee88ee6bc22078cb8f03dd71ea87d2"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a33ee88ee6bc22078cb8f03dd71ea87d2">matchCallCount</a></td></tr>
<tr class="memdesc:a33ee88ee6bc22078cb8f03dd71ea87d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of calls to this sub-function within the calling function. <br /></td></tr>
<tr class="separator:a33ee88ee6bc22078cb8f03dd71ea87d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356496b5aa7f2c01cdbf0e929aba55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae356496b5aa7f2c01cdbf0e929aba55d"></a>
<a class="el" href="classParamActive.html">ParamActive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a></td></tr>
<tr class="memdesc:ae356496b5aa7f2c01cdbf0e929aba55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Info for recovering input parameters. <br /></td></tr>
<tr class="separator:ae356496b5aa7f2c01cdbf0e929aba55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0d946a82d4f68de1e32333df36e1c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b0d946a82d4f68de1e32333df36e1c5"></a>
<a class="el" href="classParamActive.html">ParamActive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a></td></tr>
<tr class="memdesc:a9b0d946a82d4f68de1e32333df36e1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Info for recovering output parameters. <br /></td></tr>
<tr class="separator:a9b0d946a82d4f68de1e32333df36e1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0a35536be1d782a6ce613267b0400d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a0a35536be1d782a6ce613267b0400d"></a>
vector&lt; int4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9a0a35536be1d782a6ce613267b0400d">inputConsume</a></td></tr>
<tr class="memdesc:a9a0a35536be1d782a6ce613267b0400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes consumed by sub-function, for each input parameter. <br /></td></tr>
<tr class="separator:a9a0a35536be1d782a6ce613267b0400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a159dce6a7370b84dba2ff11637f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab19a159dce6a7370b84dba2ff11637f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab19a159dce6a7370b84dba2ff11637f7">isinputactive</a></td></tr>
<tr class="memdesc:ab19a159dce6a7370b84dba2ff11637f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we actively trying to recover input parameters. <br /></td></tr>
<tr class="separator:ab19a159dce6a7370b84dba2ff11637f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e150cc27ea477580875468dab13d5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08e150cc27ea477580875468dab13d5a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a08e150cc27ea477580875468dab13d5a">isoutputactive</a></td></tr>
<tr class="memdesc:a08e150cc27ea477580875468dab13d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we actively trying to recover output parameters. <br /></td></tr>
<tr class="separator:a08e150cc27ea477580875468dab13d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa7e05c56f2cad157d9e72095cb53bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaa7e05c56f2cad157d9e72095cb53bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aaaa7e05c56f2cad157d9e72095cb53bd">isbadjumptable</a></td></tr>
<tr class="memdesc:aaaa7e05c56f2cad157d9e72095cb53bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was the call originally a jump-table we couldn't recover. <br /></td></tr>
<tr class="separator:aaaa7e05c56f2cad157d9e72095cb53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classFuncProto"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFuncProto')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFuncProto.html">FuncProto</a></td></tr>
<tr class="memitem:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">paramShift</a> (int4 paramshift)</td></tr>
<tr class="memdesc:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add parameters to the front of the input parameter list.  <a href="#a75f9569f65cd6472f80d3e85d8453ced">More...</a><br /></td></tr>
<tr class="separator:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cb7670073defa354745e16bc3f998b inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa0cb7670073defa354745e16bc3f998b">isParamshiftApplied</a> (void) const </td></tr>
<tr class="separator:aa0cb7670073defa354745e16bc3f998b inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1a494d8691b68a76a56495907ab9f6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ab1a494d8691b68a76a56495907ab9f6d">setParamshiftApplied</a> (bool val)</td></tr>
<tr class="memdesc:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether a parameter shift has been applied. <br /></td></tr>
<tr class="separator:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for analyzing parameters to a sub-function call. </p>
<p>This can be viewed as a function prototype that evolves over the course of analysis. It derives off of <a class="el" href="classFuncProto.html" title="A function prototype. ">FuncProto</a> and includes facilities for analyzing data-flow for parameter information. This is the high-level object managing the examination of data-flow to recover a working prototype (<a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a>), holding a stack-pointer placeholder to facilitate stack analysis, and deciding on the working <em>extrapop</em> for the CALL.</p>
<p>A <b>stack-pointer</b> <b>placeholder</b> is a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the input operands of the CALL or CALLIND that is defined by a LOAD from the stack-pointer. By examining the pointer, the exact value of the stack-pointer (relative to its incoming value) can be computed at the point of the CALL. The temporary can arise naturally if stack parameters are a possibility, otherwise a placeholder temporary is artificially inserted into the CALL input. At the time heritage of the stack space is computed, the placeholder is examined to read off the active stack-pointer offset for the CALL and the placeholder is removed. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="abbbb64f2e2d7f1af62d3226e110079c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abbbb64f2e2d7f1af62d3226e110079c3a584ec7401809588c22798803bff5b796"></a>offset_unknown&#160;</td><td class="fielddoc">
<p>"Magic" stack offset indicating the offset is unknown </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a96cbd6a1b0311883aeb840f47e4a0ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncCallSpecs::FuncCallSpecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>call_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct based on CALL or CALLIND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_op</td><td>is the representative call site within the data-flow </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="classFuncCallSpecs.html#a0af7fe0e7b3d1486e41e528a1deec61f">effective_extrapop</a>, <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>, <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classFuncCallSpecs.html#aa1d084c81a9ae8656d7ef79c84398dc8">getFspecFromConst()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a01bf4d06e504bf92eabbfd633e5c74c0">IPTR_FSPEC</a>, <a class="el" href="classFuncCallSpecs.html#aaaa7e05c56f2cad157d9e72095cb53bd">isbadjumptable</a>, <a class="el" href="classFuncCallSpecs.html#ab19a159dce6a7370b84dba2ff11637f7">isinputactive</a>, <a class="el" href="classFuncCallSpecs.html#a08e150cc27ea477580875468dab13d5a">isoutputactive</a>, <a class="el" href="classFuncCallSpecs.html#abbbb64f2e2d7f1af62d3226e110079c3a584ec7401809588c22798803bff5b796">offset_unknown</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#ae24c733f6fbfbb4288d231869f69455d">clone()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad3c3231b5c523e491d65f31ddb688cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::abortSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the attempt to recover the relative stack offset for <b>this</b> function. </p>
<p>Any stack-pointer <em>placeholder</em> is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">Heritage::guardCalls()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bb49b65cf036e8bc8b398e549b26a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::buildInputFromTrials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final input Varnodes to <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis. </p>
<p>Varnodes that don't look like parameters are removed. Parameters that are unreferenced are filled in. Other <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs may be truncated or extended. This prototype itself is unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classParamActive.html#a23ffb29ecb4569901e136929a50ac6b2">ParamActive::deleteUnusedTrials()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">Funcdata::getArch()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classFuncdata.html#aaa28789a086c52edd04c41e265818bbb">Funcdata::getScopeLocal()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamTrial.html#a16873c9ae44b758456628caf4e522faa">ParamTrial::getSize()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classTranslate.html#a4650154d4ecaef0d282e24c50ca0208b">Translate::isBigEndian()</a>, <a class="el" href="classScopeLocal.html#a560ea5441b79ef3c17b890c7d37ccaf1">ScopeLocal::markNotMapped()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">Funcdata::opInsertBefore()</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">Funcdata::opSetAllInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">Architecture::translate</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a15f172165e29fbabfbb02be245ee1c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::buildOutputFromTrials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis of trials. </p>
<p>If it exists, the active output trial is moved to be the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of <b>this</b> CALL. If there are two active trials, they are merged as a single output of the CALL. Any INDIRECT ops that were holding the active trials are removed. This prototype itself is unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">trialvn</td><td>is the list of Varnodes associated with trials </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classParamActive.html#a23ffb29ecb4569901e136929a50ac6b2">ParamActive::deleteUnusedTrials()</a>, <a class="el" href="classFuncdata.html#aa8657c4c04279316593adc6d2f389be5">Funcdata::deleteVarnode()</a>, <a class="el" href="classFuncCallSpecs.html#a9a59b9321b66bc9f23e69d2ef729258c">findPreexistingWhole()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">Funcdata::getArch()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classFuncdata.html#ae921e42a65283ce74841c5920df4e08f">Funcdata::isDoublePrecisOn()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">Funcdata::opDestroy()</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">Funcdata::opInsertAfter()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">Funcdata::opSetOutput()</a>, <a class="el" href="classVarnode.html#ad7569812931abb759cd4150aab347f7f">Varnode::setPrecisHi()</a>, <a class="el" href="classVarnode.html#a62d871a96ac123caa3b851738cf49760">Varnode::setPrecisLo()</a>, and <a class="el" href="classArchitecture.html#a81f2db17fdc609a7d1cedbc0a2eb7753">Architecture::translate</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveReturn.html#a69af2f49b35ac17b7e2cab3e6c0be11b">ActionActiveReturn::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf5f37e4556f80f027ae502a60092ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::buildParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> representing a specific parameter. </p>
<p>If the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the parameter directly as input to the CALL is available, it must be provided to this method. If it is not available, this assumes an (indirect) stack <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is needed and builds one. If the holding <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is the correct size it is returned, otherwise a truncated <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the parameter (or NULL for a stack parameter) </td></tr>
    <tr><td class="paramname">param</td><td>is the actual parameter description </td></tr>
    <tr><td class="paramname">stackref</td><td>is the stack-pointer placeholder for <b>this</b> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that exactly matches the parameter </dd></dl>

<p>References <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classVarnode.html#a81afc7f92dea9dd9d2b03031153dfa6b">Varnode::hasNoDescend()</a>, <a class="el" href="classVarnode.html#a39a4b23694e20ba10562cb93abd4b7b1">Varnode::isConstant()</a>, <a class="el" href="classVarnode.html#a2dbe26abcf81313e06a89aefd2e648e6">Varnode::isFree()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">Funcdata::newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">Funcdata::opInsertBefore()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">Funcdata::opStackLoad()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>.</p>

</div>
</div>
<a class="anchor" id="acb251c17c1f0a352c73930383dea6c8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::checkInputJoin </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ishislot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if adjacent parameter trials can be combined into a single logical parameter. </p>
<p>A slot must be provided indicating the trial and the only following it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot1</td><td>is the first trial slot </td></tr>
    <tr><td class="paramname">ishislot</td><td>is <b>true</b> if the first slot will be the most significant piece </td></tr>
    <tr><td class="paramname">vn1</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> corresponding to the first trial </td></tr>
    <tr><td class="paramname">vn2</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> corresponding to the second trial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the trials can be combined </dd></dl>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncProto.html#afc2b22892816eb75517aa5f84a3aada1">FuncProto::checkInputJoin()</a>, <a class="el" href="classParamTrial.html#acb74446cf877ef85c504c4145ea9ecb8">ParamTrial::getAddress()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamTrial.html#a16873c9ae44b758456628caf4e522faa">ParamTrial::getSize()</a>, <a class="el" href="classParamActive.html#aa30f49a5999d722eb46721e0f2ed5804">ParamActive::getTrialForInputVarnode()</a>, and <a class="el" href="classFuncCallSpecs.html#a535463c18ea83b3ede30b02c701d0b09">isInputActive()</a>.</p>

<p>Referenced by <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ab49917128896eb002c816e361f875943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::checkInputTrialUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAliasChecker.html">AliasChecker</a> &amp;&#160;</td>
          <td class="paramname"><em>aliascheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if input trials are being actively used. </p>
<p>Run through each input trial and try to make a determination if the trial is <em>active</em> or not, meaning basically that a write has occurred on the trial with no intervening reads between the write and the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">aliascheck</td><td>holds local aliasing information about the function </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncdata.html#a226bd2fae467e85879220d2aaf9b1da1">Funcdata::ancestorOpUse()</a>, <a class="el" href="classAncestorRealistic.html#a5812787dc51e5f5238f8b595ed8cf084">AncestorRealistic::execute()</a>, <a class="el" href="classFuncProto.html#ad02f1ff6836640a55bba8055ed3b9349">FuncProto::extrapop</a>, <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">Funcdata::getArch()</a>, <a class="el" href="classFuncProto.html#a92ce1430cfc4d82aea46aa0fdc4ca7a7">FuncProto::getExtraPop()</a>, <a class="el" href="classFuncdata.html#a1b1961c6d9c58e9a0a20f74c6e49853f">Funcdata::getFuncProto()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFuncProto.html#aaae30180888dcceaaa650b6f209ccb77">FuncProto::getLocalRange()</a>, <a class="el" href="classFuncProto.html#ac5b7b20667b3db5b4855ffab044f346e">FuncProto::getModelExtraPop()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamTrial.html#a14b7cefb6f6b522542985ac3b0c1456b">ParamTrial::getSlot()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classAliasChecker.html#a34a9c8a588d835187621a17b741cfd61">AliasChecker::hasLocalAlias()</a>, <a class="el" href="classFuncProto.html#a13789408c17e4ae93280f6043ea051a8">FuncProto::hasModel()</a>, <a class="el" href="classRangeList.html#a83ace846d1d6faedd894e5756e1f7cf8">RangeList::inRange()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classPcodeOp.html#a9698c22adf2b01491fab1d1acfe271be">PcodeOp::isDead()</a>, <a class="el" href="classVarnode.html#ae3cb6e5f6ce0db8ad02728310636b558">Varnode::isInput()</a>, <a class="el" href="classParamActive.html#a7cf85723002b79c4500f3eba9159b7fa">ParamActive::markNeedsFinalCheck()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, and <a class="el" href="classArchitecture.html#adbb294ba6c3bb21f691e0208c1ac53a1">Architecture::trim_recurse_max</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a82c50f8299ce305411880fc61b8b1907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::checkOutputTrialUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if output trials are being actively used. </p>
<p>Run through each output trial and try to make a determination if the trial is <em>active</em> or not, meaning basically that the first occurrence of a trial after the call is a read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">trialvn</td><td>will hold Varnodes corresponding to the trials </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="classFuncCallSpecs.html#ad241f5566eb01acaa77327da464c7984">collectOutputTrialVarnodes()</a>, and <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveReturn.html#a69af2f49b35ac17b7e2cab3e6c0be11b">ActionActiveReturn::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ae24c733f6fbfbb4288d231869f69455d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * FuncCallSpecs::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>newop</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone <b>this</b> given the mirrored p-code CALL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newop</td><td>replaces the CALL or CALLIND op in the clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> </dd></dl>

<p>References <a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">FuncProto::copy()</a>, <a class="el" href="classFuncCallSpecs.html#a0af7fe0e7b3d1486e41e528a1deec61f">effective_extrapop</a>, <a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a>, <a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs()</a>, <a class="el" href="classFuncCallSpecs.html#aaaa7e05c56f2cad157d9e72095cb53bd">isbadjumptable</a>, <a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a>, <a class="el" href="classFuncCallSpecs.html#ae2f63fcf31daa5cc5663df227a813f0a">setFuncdata()</a>, and <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">Funcdata::truncatedFlow()</a>.</p>

</div>
</div>
<a class="anchor" id="ad241f5566eb01acaa77327da464c7984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::collectOutputTrialVarnodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> objects associated with each output trial</p>
<p>Varnodes can be attached to the CALL or CALLIND or one of the preceding INDIRECTs. They are passed back in a list matching the order of the trials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trialvn</td><td>holds the resulting list of Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classPcodeOp.html#a94eede902decfd58b5443fbfe7c1560a">PcodeOp::isIndirectCreation()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classPcodeOp.html#adeb9d3faf14ef41ad35915f149cc8830">PcodeOp::previousOp()</a>, <a class="el" href="classParamTrial.html#ad7ca7f738c822caea264fb6bf7b2738d">ParamTrial::setAddress()</a>, and <a class="el" href="classParamActive.html#a96ddb19f584727f4ef9b956fb0b8026d">ParamActive::whichTrial()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a82c50f8299ce305411880fc61b8b1907">checkOutputTrialUse()</a>.</p>

</div>
</div>
<a class="anchor" id="a98405e6447b4ada292a557920b828d67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::commitNewInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update input Varnodes to <b>this</b> CALL to reflect the formal input parameters. </p>
<p>The current input parameters must be locked and are presumably out of date with the current state of the CALL Varnodes. These existing input Varnodes must already be gathered in a list. Each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is updated to reflect the parameters, which may involve truncating or extending. Any active trials and stack-pointer placeholder is updated, and the new Varnodes are set as the CALL input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newinput</td><td>holds old input Varnodes and will hold new input Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncCallSpecs.html#aadf5f37e4556f80f027ae502a60092ba">buildParam()</a>, <a class="el" href="classParamActive.html#afadcd4621258a53d5edd7f7d4430eb7b">ParamActive::clear()</a>, <a class="el" href="classFuncCallSpecs.html#af24a93644abe9ee56a9aa86ba4cb0c9f">clearActiveInput()</a>, <a class="el" href="classParamActive.html#a0cc6c52ae0d0c76d38fb603a10a7b53e">ParamActive::finishPass()</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classParamActive.html#aa3850c9c86e2b504acef576a0acb9320">ParamActive::getNumPasses()</a>, <a class="el" href="classFuncProto.html#a6c2e2a05a468048ecefb2b18b81f37a6">FuncProto::getParam()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classFuncCallSpecs.html#ae97d6815ba495a094c2861bdcaeabdc5">getSpacebaseRelative()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncProto.html#a884776a324e2f548b8c9509b844aacb3">FuncProto::isDotdotdot()</a>, <a class="el" href="classFuncProto.html#aea485adaba5702435dc089d2648e1d49">FuncProto::isInputLocked()</a>, <a class="el" href="classParamTrial.html#aa929e7464a8b48843ba7e03f7a741e0a">ParamTrial::markActive()</a>, <a class="el" href="classFuncProto.html#ae6a078e76c55eacf3f979ba0fc61d2e7">FuncProto::numParams()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#adcad3bfd56955103a031fa6d0e78acec">Funcdata::opSetAllInput()</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, <a class="el" href="classVarnode.html#a10d47d335479abe27b8ae75b35f26b02">Varnode::setSpacebasePlaceholder()</a>, <a class="el" href="classFuncCallSpecs.html#ab398038b75b6f13b865384da3fd143b9">setStackPlaceholderSlot()</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="aa357f1ecfa3c9bd2ab86d958bb0670b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::commitNewOutputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>newout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to <b>this</b> CALL to reflect the formal return value. </p>
<p>The current return value must be locked and is presumably out of date with the current CALL output. Unless the return value is <em>void</em>, the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> must exist and must be provided. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is updated to reflect the return value, which may involve truncating or extending. Any active trials are updated, and the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is set as the CALL output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newout</td><td>is the provided old output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (or NULL) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a9b0d946a82d4f68de1e32333df36e1c5">activeoutput</a>, <a class="el" href="classFuncProto.html#a125e6b494f6c1610b5cfde5cbeaf583b">FuncProto::assumedOutputExtension()</a>, <a class="el" href="classParamActive.html#afadcd4621258a53d5edd7f7d4430eb7b">ParamActive::clear()</a>, <a class="el" href="classFuncCallSpecs.html#a5c13854db24718357b5ce7de7802b4ed">clearActiveOutput()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a36a10374a26740a58b5625f340f6ffad">CPUI_COPY</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a5fc7131a25cd3887d2ceabf181fa5b8a">CPUI_INT_SEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a778868cfa2191f9621f632672e596702">CPUI_INT_ZEXT</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a2f366ca905ed81c22e500d5de37de366">CPUI_SUBPIECE</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFuncProto.html#a007c788810868e06307d9c324c824e1d">FuncProto::getOutput()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">AddrSpace::isBigEndian()</a>, <a class="el" href="classFuncProto.html#afd1f88b093e5171128ab22918523fe24">FuncProto::isOutputLocked()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">Funcdata::newIndirectCreation()</a>, <a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">Funcdata::newOp()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">Funcdata::opInsertAfter()</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, <a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">Funcdata::opSetOutput()</a>, <a class="el" href="classFuncdata.html#aacf0cf87976170d62df42411ffe1e10a">Funcdata::opUninsert()</a>, <a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">Funcdata::opUnlink()</a>, <a class="el" href="classFuncdata.html#ab91b54da6501e12d4ad1e81ab5d0e5c4">Funcdata::opUnsetOutput()</a>, <a class="el" href="classParamActive.html#a43a357162f55b3b8f7e13a013ad207b5">ParamActive::registerTrial()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a57f3844d92136d3ab6b67ea9ea316aa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool FuncCallSpecs::compareByEntryAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> by function entry address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td>is the second to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first should be ordered before the second </dd></dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aab6fc72a11289af288ec65f216d7a45b">countMatchingCalls()</a>.</p>

</div>
</div>
<a class="anchor" id="aab6fc72a11289af288ec65f216d7a45b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::countMatchingCalls </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>qlst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of times an individual sub-function is called. </p>
<p>Provided a list of all call sites for a calling function, tally the number of calls to the same sub-function. Update the <b>matchCallCount</b> field of each <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qlst</td><td>is the list of call sites (<a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a>) for the calling function </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a57f3844d92136d3ab6b67ea9ea316aa7">compareByEntryAddress()</a>, <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, and <a class="el" href="classFuncCallSpecs.html#a33ee88ee6bc22078cb8f03dd71ea87d2">matchCallCount</a>.</p>

</div>
</div>
<a class="anchor" id="aad64d557811baf4602afcefb2746f7be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::deindirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>newfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <b>this</b> call site from an indirect to a direct function call. </p>
<p>This call site must be a CALLIND, and the function that it is actually calling must be provided. The method makes a determination if the current state of data-flow allows converting to the prototype of the new function without dropping information due to inaccurate dead-code elimination. If conversion is safe, it is performed immediately. Otherwise a <em>restart</em> directive issued to force decompilation to restart from scratch (now with the direct function in hand) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newfd</td><td>is the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object that we know is the destination of <b>this</b> CALLIND </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">commitNewOutputs()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a50235a7bf50bada36dff73ff740c34d0">CPUI_CALL</a>, <a class="el" href="classFuncCallSpecs.html#a1c5d10d1b705fb05f1ce581b7a6eeed6">entryaddress</a>, <a class="el" href="classFuncCallSpecs.html#ade06e0fcf372e92f2b62ac1e188439be">fd</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncdata.html#a91233c941630a3194e8287206314bb1e">Funcdata::getAddress()</a>, <a class="el" href="classFuncdata.html#a1b1961c6d9c58e9a0a20f74c6e49853f">Funcdata::getFuncProto()</a>, <a class="el" href="classFuncdata.html#a25a0e80f90d02397255cf1d3b11f86cd">Funcdata::getName()</a>, <a class="el" href="classFuncdata.html#ac48d087ed5fbf901cfa608d8f44b6d5c">Funcdata::getOverride()</a>, <a class="el" href="classOverride.html#a244525d6ba415aab3769255c79ab7ba8">Override::insertIndirectOverride()</a>, <a class="el" href="classFuncProto.html#ace8e7092572b8d514b6d74c953944080">FuncProto::isOverride()</a>, <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>, <a class="el" href="classFuncCallSpecs.html#aee4c4b25b4eba36052e847f41f110816">name</a>, <a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">Funcdata::newVarnodeCallSpecs()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">Funcdata::opSetInput()</a>, <a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">Funcdata::opSetOpcode()</a>, and <a class="el" href="classFuncdata.html#af21c852eb9f606c5cd19fb2456927ecd">Funcdata::setRestartPending()</a>.</p>

<p>Referenced by <a class="el" href="classActionDeindirect.html#a4f54f89989ab5700bdac440960ed6fcf">ActionDeindirect::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a489441d9d77d08bdf87eff937e8ef5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::doInputJoin </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ishislot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join two parameter trials. </p>
<p>We assume <a class="el" href="classFuncCallSpecs.html#acb251c17c1f0a352c73930383dea6c8f" title="Check if adjacent parameter trials can be combined into a single logical parameter. ">checkInputJoin()</a> has returned <b>true</b>. Perform the join, replacing the given adjacent trials with a single merged parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot1</td><td>is the trial slot of the first trial </td></tr>
    <tr><td class="paramname">ishislot</td><td>is <b>true</b> if the first slot will be the most significant piece </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classFuncProto.html#af00b0b2e61b845d3fd66c6e3ad7e028b">FuncProto::getArch()</a>, <a class="el" href="classParamActive.html#aa30f49a5999d722eb46721e0f2ed5804">ParamActive::getTrialForInputVarnode()</a>, <a class="el" href="classFuncProto.html#aea485adaba5702435dc089d2648e1d49">FuncProto::isInputLocked()</a>, and <a class="el" href="classParamActive.html#a593685d8f2f13f34e5c48f1f363c793d">ParamActive::joinTrial()</a>.</p>

<p>Referenced by <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a48998cb808c1feedcad257f0984317ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::finalInputCheck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make final activity check on trials that might have been affected by conditional execution. </p>
<p>The activity level a trial may change once conditional execution has been analyzed. This routine (re)checks trials that might be affected by this, which may then be converted to <em>not</em> <em>used</em>. </p>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classAncestorRealistic.html#a5812787dc51e5f5238f8b595ed8cf084">AncestorRealistic::execute()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classParamTrial.html#a14b7cefb6f6b522542985ac3b0c1456b">ParamTrial::getSlot()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, and <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a59b9321b66bc9f23e69d2ef729258c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::findPreexistingWhole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if given two Varnodes are merged into a whole. </p>
<p>If the Varnodes are merged immediately into a common whole and aren't used for anything else, return the whole <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn1</td><td>is the first given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">vn2</td><td>is the second given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7a69a387d1e0b510d027e69bdde8f03caa">CPUI_PIECE</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, and <a class="el" href="classVarnode.html#aa94a908ad49311182b1fadfa3a9d7dba">Varnode::loneDescend()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a15f172165e29fbabfbb02be245ee1c98">buildOutputFromTrials()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bc0ef657c876530f21a6ae60458eb35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::forceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a more restrictive prototype on <b>this</b> call site. </p>
<p>A new prototype must be given, typically recovered from a function pointer data-type that has been propagated to <b>this</b> call site. The method makes a determination if the current state of data-flow allows converting to the new prototype without dropping information due to inaccurate dead-code elimination. If conversion is safe, it is performed immediately. Otherwise a <em>restart</em> directive issued to force decompilation to restart from scratch (now with the new prototype in hand) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">fp</td><td>is the new (more restrictive) function prototype </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>, <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">commitNewOutputs()</a>, <a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">FuncProto::copy()</a>, <a class="el" href="classFuncProto.html#a9c7db7dec63a18a9de97b0ba9f6f42bd">FuncProto::FuncProto()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncdata.html#ac48d087ed5fbf901cfa608d8f44b6d5c">Funcdata::getOverride()</a>, <a class="el" href="classFuncProto.html#a9c9da3b32d9b55d944ee659087fbd2ed">FuncProto::hasInputErrors()</a>, <a class="el" href="classFuncProto.html#aed327cece6d30cbb03de61c7472b4d63">FuncProto::hasOutputErrors()</a>, <a class="el" href="classOverride.html#abf08af570f603eaf60f36f61c3a275ae">Override::insertProtoOverride()</a>, <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">FuncProto::setInputErrors()</a>, <a class="el" href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">FuncProto::setInputLock()</a>, <a class="el" href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">FuncProto::setOutputErrors()</a>, and <a class="el" href="classFuncdata.html#af21c852eb9f606c5cd19fb2456927ecd">Funcdata::setRestartPending()</a>.</p>

<p>Referenced by <a class="el" href="classActionDeindirect.html#a4f54f89989ab5700bdac440960ed6fcf">ActionDeindirect::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1d084c81a9ae8656d7ef79c84398dc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a>* FuncCallSpecs::getFspecFromConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classFspecSpace.html" title="A special space for encoding FuncCallSpecs. ">FspecSpace</a> addresses to the underlying <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given <em>fspec</em> address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> object </dd></dl>

<p>References <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs()</a>, <a class="el" href="classFuncdata.html#a2f5bc4594f2f02f8a67b99469606e60d">Funcdata::getCallSpecs()</a>, <a class="el" href="classTypeOpCall.html#aae7b8edf26f2ca1372efc4678ce70775">TypeOpCall::getInputLocal()</a>, <a class="el" href="classTypeOpCall.html#ae3060180a6d54675150fd3130e72f11c">TypeOpCall::getOutputLocal()</a>, <a class="el" href="classFlowInfo.html#af91718ae694b4852c24f4af6cb0b07a0">FlowInfo::injectPcode()</a>, and <a class="el" href="classPrintC.html#aa03349d27cfe1d81e6e3854cd0eb9252">PrintC::opCall()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f7e27183972392fae6a23127d8302ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncCallSpecs::getInputBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the estimated number of bytes within the given parameter that are consumed. </p>
<p>As a function is decompiled, there may hints about how many of the bytes, within the storage location used to pass the parameter, are used by <b>this</b> sub-function. A non-zero value means that that many least significant bytes of the storage location are used. A value of zero means all bytes are presumed used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the slot of the given input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes used (or 0) </dd></dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a9a0a35536be1d782a6ce613267b0400d">inputConsume</a>.</p>

<p>Referenced by <a class="el" href="classActionDeadCode.html#ab9d6ddd65fbafdded028b20e0df083fc">ActionDeadCode::markConsumedParameters()</a>.</p>

</div>
</div>
<a class="anchor" id="ae97d6815ba495a094c2861bdcaeabdc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::getSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the active stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> at <b>this</b> call site. </p>
<p>Find an instance of the stack-pointer (spacebase register) that is active at the point of <b>this</b> CALL, by examining the <em>stack-pointer</em> <em>placeholder</em> slot. </p><dl class="section return"><dt>Returns</dt><dd>the stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7ad76724dd2fcd9df1dca7e09e6427f10f">CPUI_LOAD</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classVarnode.html#adff3a3f88a31e5c325699517594f891a">Varnode::isSpacebasePlaceholder()</a>, <a class="el" href="classVarnode.html#a98f2475fb9ff24823729adc48d58788e">Varnode::isWritten()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classFuncCallSpecs.html#af655410c6704377c0d260b06fd532e22">stackPlaceholderSlot</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a98405e6447b4ada292a557920b828d67">commitNewInputs()</a>, and <a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f782d0e91a83336fa722483c79d42aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint4 FuncCallSpecs::hasEffectTranslate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate type of side-effect for a given storage location (with caller translation) </p>
<p>Stack locations should be provided from the caller's perspective. They are automatically translated to the callee's perspective before making the underlying query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the effect type </dd></dl>

<p>References <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classFuncProto.html#a116dd89589cc36e9c822426838658871">FuncProto::hasEffect()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncCallSpecs.html#abbbb64f2e2d7f1af62d3226e110079c3a584ec7401809588c22798803bff5b796">offset_unknown</a>, <a class="el" href="classFuncCallSpecs.html#a0c685ecd38c4da586b8c7bddc2fd1983">stackoffset</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea02697f294ad0f4b53317da792c577a10">EffectRecord::unknown_effect</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#aa77f98c62d1bfd1062314c6c2a5035bf">Heritage::callOpIndirectEffect()</a>, and <a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">Heritage::guardCalls()</a>.</p>

</div>
</div>
<a class="anchor" id="aae6a890aaa82deca59ec7c57c92629aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::insertPcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject any <em>upon-return</em> p-code at <b>this</b> call site. </p>
<p>This function prototype may trigger injection of p-code immediately after the CALL or CALLIND to mimic a portion of the callee that decompilation of the caller otherwise wouldn't see. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classFuncdata.html#adb1dd79d78141f89d374e570de21d690">Funcdata::doLiveInject()</a>, <a class="el" href="classPcodeOp.html#a1b3185ba18a255ee4d62edfbae882e94">PcodeOp::getAddr()</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">Funcdata::getArch()</a>, <a class="el" href="classPcodeOp.html#ae4dbd2e0b83e5fadebf7186e904921ca">PcodeOp::getBasicIter()</a>, <a class="el" href="classFuncProto.html#a3928162e5f03fe83a86be8d499fb3705">FuncProto::getInjectUponReturn()</a>, <a class="el" href="classPcodeOp.html#a84c6ef6d203fa724f0b9b58e5772673e">PcodeOp::getParent()</a>, <a class="el" href="classPcodeInjectLibrary.html#a19cc3c09c39f815b1e797ca147063977">PcodeInjectLibrary::getPayload()</a>, <a class="el" href="classFuncProto.html#a0d6fe1d0e0e45e71b366020d00914319">FuncProto::injectid</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">Architecture::pcodeinjectlib</a>.</p>

<p>Referenced by <a class="el" href="classActionDefaultParams.html#a32f4c196d02d9f86c66749b9bf5d2247">ActionDefaultParams::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ab55b52b70e4def9167d06709746635e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::lateRestriction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>restrictedProto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>newoutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <b>this</b> prototype to match a given (more specialized) prototype. </p>
<p>This method assumes that <b>this</b> prototype is in some intermediate state during the parameter recovery process and that a new definitive (locked) prototype is discovered for <b>this</b> call site. This method checks to see if <b>this</b> can be updated to match the new prototype without missing any data-flow. If so, <b>this</b> is updated, and new input and output Varnodes for the CALL are passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restrictedProto</td><td>is the new definitive function prototype </td></tr>
    <tr><td class="paramname">newinput</td><td>will hold the new list of input Varnodes for the CALL </td></tr>
    <tr><td class="paramname">newoutput</td><td>will hold the new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>this</b> can be fully converted </dd></dl>

<p>References <a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">FuncProto::copy()</a>, <a class="el" href="classFuncProto.html#a13789408c17e4ae93280f6043ea051a8">FuncProto::hasModel()</a>, <a class="el" href="classFuncProto.html#af5002ce3745f1bfcc63de287def37080">FuncProto::isCompatible()</a>, <a class="el" href="classFuncProto.html#a884776a324e2f548b8c9509b844aacb3">FuncProto::isDotdotdot()</a>, <a class="el" href="classFuncCallSpecs.html#ab19a159dce6a7370b84dba2ff11637f7">isinputactive</a>, <a class="el" href="classFuncProto.html#aea485adaba5702435dc089d2648e1d49">FuncProto::isInputLocked()</a>, <a class="el" href="classFuncProto.html#afd1f88b093e5171128ab22918523fe24">FuncProto::isOutputLocked()</a>, <a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput()</a>, and <a class="el" href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">transferLockedOutput()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect()</a>, and <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a01e16ebebb71bdc63fb884c8d0e3b7e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::paramshiftModifyStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw out any paramshift parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made </dd></dl>

<p>References <a class="el" href="classFuncProto.html#aa0cb7670073defa354745e16bc3f998b">FuncProto::isParamshiftApplied()</a>, <a class="el" href="classPcodeOp.html#af426e964bfc805355abdf5ca4e058133">PcodeOp::numInput()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, <a class="el" href="classFuncCallSpecs.html#a303b8605ffd3e4432fb7ca3c70759f2d">paramshift</a>, <a class="el" href="classFuncProto.html#abc9a8f192846b36ba99ed0464bb10862">FuncProto::removeParam()</a>, and <a class="el" href="classFuncProto.html#ab1a494d8691b68a76a56495907ab9f6d">FuncProto::setParamshiftApplied()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ad2a3f374049dec6fdf0f9d20295305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::resolveSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>phvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the stack offset of <b>this</b> call site. </p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> must be the input to the CALL in the <em>placeholder</em> slot and must be defined by a COPY from a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the stack space. Calculate the offset of the stack-pointer at the point of <b>this</b> CALL, relative to the incoming stack-pointer value. This can be obtained either be looking at a stack parameter, or if there is no stack parameter, the stack-pointer <em>placeholder</em> can be used. If the <em>placeholder</em> has no other purpose, remove it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">phvn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the <em>placeholder</em> slot for <b>this</b> CALL </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classVarnode.html#a8f227a762a3baec9ffa6962c5298e3a3">Varnode::getDef()</a>, <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classVarnode.html#a0c8f14c382ed1f493411b4ccb3e4841a">Varnode::getOffset()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classVarnode.html#aba88f8fa19ffe2c7c842da40ecce7a44">Varnode::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">Funcdata::opRemoveInput()</a>, <a class="el" href="classFuncdata.html#a5084ee379b9bdbcd47ef1b4b73a7b362">Funcdata::warningHeader()</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

<p>Referenced by <a class="el" href="classRuleLoadVarnode.html#aba1b981179387a727272c5ba7b407777">RuleLoadVarnode::applyOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a216c014e3072c48a36fbea0be650349e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::setInputBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the estimated number of bytes within the given parameter that are consumed. </p>
<p>This provides a hint to the dead code <em>consume</em> algorithm, while examining the calling function, about how the given parameter within the subfunction is used. A non-zero value means that that many least significant bytes of the storage location are used. A value of zero means all bytes are presumed used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the slot of the given input parameter </td></tr>
    <tr><td class="paramname">val</td><td>is the number of bytes consumed (or 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there was a change in the estimate </dd></dl>

<p>References <a class="el" href="classFuncCallSpecs.html#a9a0a35536be1d782a6ce613267b0400d">inputConsume</a>.</p>

<p>Referenced by <a class="el" href="classRulePiecePathology.html#a681659c18d630bbf9064fbf7191dd02d">RulePiecePathology::tracePathologyForward()</a>.</p>

</div>
</div>
<a class="anchor" id="a51c269dac5b3730ea0093d2bc6841b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::transferLockedInput </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List and/or create a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for each input parameter of <b>this</b> prototype. </p>
<p>Varnodes will be passed back in order that match current input parameters. A NULL <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> indicates a stack parameter. <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> dimensions may not match parameter dimensions exactly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newinput</td><td>will hold the resulting list of Varnodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> only if the list needs to indicate stack variables and there is no stack-pointer placeholder </dd></dl>

<p>References <a class="el" href="classPcodeOp.html#a346b81187c4eab2f5e0ced8b455c1531">PcodeOp::getIn()</a>, <a class="el" href="classFuncProto.html#a6c2e2a05a468048ecefb2b18b81f37a6">FuncProto::getParam()</a>, <a class="el" href="classFuncCallSpecs.html#ae97d6815ba495a094c2861bdcaeabdc5">getSpacebaseRelative()</a>, <a class="el" href="classFuncProto.html#ae6a078e76c55eacf3f979ba0fc61d2e7">FuncProto::numParams()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classFuncCallSpecs.html#a3ea6ae61949247b9e8c4643ce68860e3">transferLockedInputParam()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ea6ae61949247b9e8c4643ce68860e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncCallSpecs::transferLockedInputParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the CALL input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that matches the given parameter. </p>
<p>This method facilitates the building of a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> matching the given parameter from existing data-flow. Return either:</p><ul>
<li>0 if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can't be built</li>
<li>slot# for the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to reuse</li>
<li>-1 if the parameter needs to be built from the stack <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>is the given parameter to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded slot </dd></dl>
</li>
</ul>

<p>References <a class="el" href="classFuncCallSpecs.html#ae356496b5aa7f2c01cdbf0e929aba55d">activeinput</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, and <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a51c269dac5b3730ea0093d2bc6841b07">transferLockedInput()</a>.</p>

</div>
</div>
<a class="anchor" id="aed1cb380c5ca6bf3d02f441cf582c50e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::transferLockedOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>newoutput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass back the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> needed to match the output parameter (return value) </p>
<p>Search for the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> matching the current output parameter and pass it back. The dimensions of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> may not exactly match the return value. If the return value is e void, a NULL is passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newoutput</td><td>will hold the passed back <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the passed back value is accurate </dd></dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classFuncProto.html#a007c788810868e06307d9c324c824e1d">FuncProto::getOutput()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classFuncCallSpecs.html#a077b8ed8181bb5523e1be06583d3d588">transferLockedOutputParam()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">lateRestriction()</a>.</p>

</div>
</div>
<a class="anchor" id="a077b8ed8181bb5523e1be06583d3d588"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * FuncCallSpecs::transferLockedOutputParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the p-code op whose output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> corresponds to the given parameter (return value)</p>
<p>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> may be attached to the base CALL or CALLIND, but it also may be attached to an INDIRECT preceding the CALL. The output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> may not exactly match the dimensions of the given parameter. We return non-null if either:</p><ul>
<li>The parameter contains the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (the easier case) OR if</li>
<li>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properly contains the parameter <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>is the given paramter (return value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> or NULL </dd></dl>
</li>
</ul>

<p>References <a class="el" href="classPcodeOp.html#a7ea2c706ee84cf2572141321a04d94f4">PcodeOp::code()</a>, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7aa89e33b07a26ca7d26b54315e45c8424">CPUI_INDIRECT</a>, <a class="el" href="classVarnode.html#a128ca9ceeb101837c78cce9cdfe842c5">Varnode::getAddr()</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classPcodeOp.html#a71498bcea3f59f0eb5878e56536d68c3">PcodeOp::getOut()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classPcodeOp.html#a94eede902decfd58b5443fbfe7c1560a">PcodeOp::isIndirectCreation()</a>, <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>, <a class="el" href="classFuncCallSpecs.html#a42e16ea23d22a20d4c343f33a50307eb">op</a>, and <a class="el" href="classPcodeOp.html#adeb9d3faf14ef41ad35915f149cc8830">PcodeOp::previousOp()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aed1cb380c5ca6bf3d02f441cf582c50e">transferLockedOutput()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fspec_8hh.html">fspec.hh</a></li>
<li>fspec.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
