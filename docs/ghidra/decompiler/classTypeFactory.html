<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: TypeFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTypeFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TypeFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container class for all <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> objects in an <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a>.  
 <a href="classTypeFactory.html#details">More...</a></p>

<p><code>#include &lt;type.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TypeFactory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classTypeFactory.png" usemap="#TypeFactory_map" alt=""/>
  <map id="TypeFactory_map" name="TypeFactory_map">
<area href="classTypeFactoryGhidra.html" title="An implementation of the TypeFactory interface, query a Ghidra client for data-type information..." alt="TypeFactoryGhidra" shape="rect" coords="0,56,122,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68a14752ee51f674664cce90522fe559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a68a14752ee51f674664cce90522fe559">TypeFactory</a> (<a class="el" href="classArchitecture.html">Architecture</a> *g)</td></tr>
<tr class="memdesc:a68a14752ee51f674664cce90522fe559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a factory.  <a href="#a68a14752ee51f674664cce90522fe559">More...</a><br /></td></tr>
<tr class="separator:a68a14752ee51f674664cce90522fe559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae3189d62867e5358bcbb98e7723b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afae3189d62867e5358bcbb98e7723b75">setupSizes</a> (void)</td></tr>
<tr class="memdesc:afae3189d62867e5358bcbb98e7723b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive some size information from <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a>.  <a href="#afae3189d62867e5358bcbb98e7723b75">More...</a><br /></td></tr>
<tr class="separator:afae3189d62867e5358bcbb98e7723b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8497930bbd88dd89d91536de06a79f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8497930bbd88dd89d91536de06a79f3f">clear</a> (void)</td></tr>
<tr class="memdesc:a8497930bbd88dd89d91536de06a79f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out all types.  <a href="#a8497930bbd88dd89d91536de06a79f3f">More...</a><br /></td></tr>
<tr class="separator:a8497930bbd88dd89d91536de06a79f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4b55a83c2f6dbb6f4f13b5ca930ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afa4b55a83c2f6dbb6f4f13b5ca930ae4">clearNoncore</a> (void)</td></tr>
<tr class="memdesc:afa4b55a83c2f6dbb6f4f13b5ca930ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out non-core types.  <a href="#afa4b55a83c2f6dbb6f4f13b5ca930ae4">More...</a><br /></td></tr>
<tr class="separator:afa4b55a83c2f6dbb6f4f13b5ca930ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d006876061f78e680f8697a335399d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d006876061f78e680f8697a335399d5"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2d006876061f78e680f8697a335399d5">~TypeFactory</a> (void)</td></tr>
<tr class="memdesc:a2d006876061f78e680f8697a335399d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2d006876061f78e680f8697a335399d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ffda99be9ec6acf0bc8a963021e050"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ffda99be9ec6acf0bc8a963021e050"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aa0ffda99be9ec6acf0bc8a963021e050">setStructAlign</a> (int4 al)</td></tr>
<tr class="memdesc:aa0ffda99be9ec6acf0bc8a963021e050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default structure alignment. <br /></td></tr>
<tr class="separator:aa0ffda99be9ec6acf0bc8a963021e050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a8351569c26778bce1c8e37b63bde8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a8351569c26778bce1c8e37b63bde8"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a59a8351569c26778bce1c8e37b63bde8">getStructAlign</a> (void) const </td></tr>
<tr class="memdesc:a59a8351569c26778bce1c8e37b63bde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default structure alignment. <br /></td></tr>
<tr class="separator:a59a8351569c26778bce1c8e37b63bde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3f68a44efa373c20c56d3e99fe6afe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e3f68a44efa373c20c56d3e99fe6afe"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6e3f68a44efa373c20c56d3e99fe6afe">getSizeOfInt</a> (void) const </td></tr>
<tr class="memdesc:a6e3f68a44efa373c20c56d3e99fe6afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the default "int". <br /></td></tr>
<tr class="separator:a6e3f68a44efa373c20c56d3e99fe6afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b53df79da81c7cae1083e40460ba47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39b53df79da81c7cae1083e40460ba47"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a39b53df79da81c7cae1083e40460ba47">getArch</a> (void) const </td></tr>
<tr class="memdesc:a39b53df79da81c7cae1083e40460ba47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> object. <br /></td></tr>
<tr class="separator:a39b53df79da81c7cae1083e40460ba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e139f5b338e423fd2b1beb7d941d30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a5e139f5b338e423fd2b1beb7d941d30f">findByName</a> (const string &amp;n)</td></tr>
<tr class="memdesc:a5e139f5b338e423fd2b1beb7d941d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of given name.  <a href="#a5e139f5b338e423fd2b1beb7d941d30f">More...</a><br /></td></tr>
<tr class="separator:a5e139f5b338e423fd2b1beb7d941d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c74462f5a832e6233421bb6cb1beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6a2c74462f5a832e6233421bb6cb1beb">setName</a> (<a class="el" href="classDatatype.html">Datatype</a> *ct, const string &amp;n)</td></tr>
<tr class="memdesc:a6a2c74462f5a832e6233421bb6cb1beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given types name.  <a href="#a6a2c74462f5a832e6233421bb6cb1beb">More...</a><br /></td></tr>
<tr class="separator:a6a2c74462f5a832e6233421bb6cb1beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1fc5e17c8e0636ea976cc0e28113fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afc1fc5e17c8e0636ea976cc0e28113fd">setFields</a> (vector&lt; <a class="el" href="structTypeField.html">TypeField</a> &gt; &amp;fd, <a class="el" href="classTypeStruct.html">TypeStruct</a> *ot, int4 fixedsize, uint4 flags)</td></tr>
<tr class="memdesc:afc1fc5e17c8e0636ea976cc0e28113fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fields on a <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;. ">TypeStruct</a>.  <a href="#afc1fc5e17c8e0636ea976cc0e28113fd">More...</a><br /></td></tr>
<tr class="separator:afc1fc5e17c8e0636ea976cc0e28113fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cf58ac6b927a91b4f794a3347b2822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a17cf58ac6b927a91b4f794a3347b2822">setEnumValues</a> (const vector&lt; string &gt; &amp;namelist, const vector&lt; uintb &gt; &amp;vallist, const vector&lt; bool &gt; &amp;assignlist, <a class="el" href="classTypeEnum.html">TypeEnum</a> *te)</td></tr>
<tr class="memdesc:a17cf58ac6b927a91b4f794a3347b2822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set named values for an enumeration.  <a href="#a17cf58ac6b927a91b4f794a3347b2822">More...</a><br /></td></tr>
<tr class="separator:a17cf58ac6b927a91b4f794a3347b2822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5f4036abb11e63ca5f79a9eacfc93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aea5f4036abb11e63ca5f79a9eacfc93c">restoreXmlType</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:aea5f4036abb11e63ca5f79a9eacfc93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> from XML.  <a href="#aea5f4036abb11e63ca5f79a9eacfc93c">More...</a><br /></td></tr>
<tr class="separator:aea5f4036abb11e63ca5f79a9eacfc93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25856a74501dae4b91e1b5313773bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab25856a74501dae4b91e1b5313773bff">restoreXmlTypeWithCodeFlags</a> (const <a class="el" href="classElement.html">Element</a> *el, bool isConstructor, bool isDestructor)</td></tr>
<tr class="memdesc:ab25856a74501dae4b91e1b5313773bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore data-type from XML with extra "code" flags.  <a href="#ab25856a74501dae4b91e1b5313773bff">More...</a><br /></td></tr>
<tr class="separator:ab25856a74501dae4b91e1b5313773bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7277908ef32101f172633ec00fbecb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeVoid.html">TypeVoid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">getTypeVoid</a> (void)</td></tr>
<tr class="memdesc:ab7277908ef32101f172633ec00fbecb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "void" data-type.  <a href="#ab7277908ef32101f172633ec00fbecb1">More...</a><br /></td></tr>
<tr class="separator:ab7277908ef32101f172633ec00fbecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca2937f24e37c5ac19ba442cd1df0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#adca2937f24e37c5ac19ba442cd1df0d8">getBaseNoChar</a> (int4 s, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m)</td></tr>
<tr class="memdesc:adca2937f24e37c5ac19ba442cd1df0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get atomic type excluding "char".  <a href="#adca2937f24e37c5ac19ba442cd1df0d8">More...</a><br /></td></tr>
<tr class="separator:adca2937f24e37c5ac19ba442cd1df0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe1ae26c0b76b18d59d5cd27a9b8ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">getBase</a> (int4 s, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m)</td></tr>
<tr class="memdesc:a5fe1ae26c0b76b18d59d5cd27a9b8ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get atomic type.  <a href="#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">More...</a><br /></td></tr>
<tr class="separator:a5fe1ae26c0b76b18d59d5cd27a9b8ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2848b5923834b755de0749d9f96880e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2848b5923834b755de0749d9f96880e1">getBase</a> (int4 s, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m, const string &amp;n)</td></tr>
<tr class="memdesc:a2848b5923834b755de0749d9f96880e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get named atomic type.  <a href="#a2848b5923834b755de0749d9f96880e1">More...</a><br /></td></tr>
<tr class="separator:a2848b5923834b755de0749d9f96880e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c3d70d9598d2b4ce3770593f6ce97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeCode.html">TypeCode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a47c3d70d9598d2b4ce3770593f6ce97e">getTypeCode</a> (void)</td></tr>
<tr class="memdesc:a47c3d70d9598d2b4ce3770593f6ce97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an "anonymous" function data-type.  <a href="#a47c3d70d9598d2b4ce3770593f6ce97e">More...</a><br /></td></tr>
<tr class="separator:a47c3d70d9598d2b4ce3770593f6ce97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff97843c231aea653d16621caa5f1ee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aff97843c231aea653d16621caa5f1ee6">getTypePointerStripArray</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *pt, uint4 ws)</td></tr>
<tr class="memdesc:aff97843c231aea653d16621caa5f1ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a pointer data-type, stripping an ARRAY level.  <a href="#aff97843c231aea653d16621caa5f1ee6">More...</a><br /></td></tr>
<tr class="separator:aff97843c231aea653d16621caa5f1ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff26aa7e6197ffb865907313f752d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a2ff26aa7e6197ffb865907313f752d43">getTypePointer</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *pt, uint4 ws)</td></tr>
<tr class="memdesc:a2ff26aa7e6197ffb865907313f752d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an absolute pointer data-type.  <a href="#a2ff26aa7e6197ffb865907313f752d43">More...</a><br /></td></tr>
<tr class="separator:a2ff26aa7e6197ffb865907313f752d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77988d5cf50fc10fe92dec8e265a720f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypePointer.html">TypePointer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a77988d5cf50fc10fe92dec8e265a720f">getTypePointerNoDepth</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *pt, uint4 ws)</td></tr>
<tr class="memdesc:a77988d5cf50fc10fe92dec8e265a720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a depth limited pointer data-type.  <a href="#a77988d5cf50fc10fe92dec8e265a720f">More...</a><br /></td></tr>
<tr class="separator:a77988d5cf50fc10fe92dec8e265a720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1efe412493c66b6072ae0def3b53004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeArray.html">TypeArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ad1efe412493c66b6072ae0def3b53004">getTypeArray</a> (int4 as, <a class="el" href="classDatatype.html">Datatype</a> *ao)</td></tr>
<tr class="memdesc:ad1efe412493c66b6072ae0def3b53004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array data-type.  <a href="#ad1efe412493c66b6072ae0def3b53004">More...</a><br /></td></tr>
<tr class="separator:ad1efe412493c66b6072ae0def3b53004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a75179b840571eeb97e24642c55ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeStruct.html">TypeStruct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aaa4a75179b840571eeb97e24642c55ee">getTypeStruct</a> (const string &amp;n)</td></tr>
<tr class="memdesc:aaa4a75179b840571eeb97e24642c55ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an (empty) structure.  <a href="#aaa4a75179b840571eeb97e24642c55ee">More...</a><br /></td></tr>
<tr class="separator:aaa4a75179b840571eeb97e24642c55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1aba15e198a7ba2b67741c571de3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeEnum.html">TypeEnum</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a3bb1aba15e198a7ba2b67741c571de3a">getTypeEnum</a> (const string &amp;n)</td></tr>
<tr class="memdesc:a3bb1aba15e198a7ba2b67741c571de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an (empty) enumeration.  <a href="#a3bb1aba15e198a7ba2b67741c571de3a">More...</a><br /></td></tr>
<tr class="separator:a3bb1aba15e198a7ba2b67741c571de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85de9d19ce1dc44476a414f5ce69b97e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeSpacebase.html">TypeSpacebase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a85de9d19ce1dc44476a414f5ce69b97e">getTypeSpacebase</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a85de9d19ce1dc44476a414f5ce69b97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a "spacebase" type.  <a href="#a85de9d19ce1dc44476a414f5ce69b97e">More...</a><br /></td></tr>
<tr class="separator:a85de9d19ce1dc44476a414f5ce69b97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99362bf53b0ead2d57a2221bc2fd03cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeCode.html">TypeCode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a99362bf53b0ead2d57a2221bc2fd03cc">getTypeCode</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *model, <a class="el" href="classDatatype.html">Datatype</a> *outtype, const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;intypes, bool dotdotdot)</td></tr>
<tr class="memdesc:a99362bf53b0ead2d57a2221bc2fd03cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a "function" datatype.  <a href="#a99362bf53b0ead2d57a2221bc2fd03cc">More...</a><br /></td></tr>
<tr class="separator:a99362bf53b0ead2d57a2221bc2fd03cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4edd4fa31629380ec4124c840022f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab4edd4fa31629380ec4124c840022f5a">destroyType</a> (<a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:ab4edd4fa31629380ec4124c840022f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a data-type from <b>this</b>.  <a href="#ab4edd4fa31629380ec4124c840022f5a">More...</a><br /></td></tr>
<tr class="separator:ab4edd4fa31629380ec4124c840022f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979852b4d0b186f833d16d4638fe6f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a979852b4d0b186f833d16d4638fe6f08">downChain</a> (<a class="el" href="classDatatype.html">Datatype</a> *ptrtype, uintb &amp;off)</td></tr>
<tr class="memdesc:a979852b4d0b186f833d16d4638fe6f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a sub-type matching a pointer and offset.  <a href="#a979852b4d0b186f833d16d4638fe6f08">More...</a><br /></td></tr>
<tr class="separator:a979852b4d0b186f833d16d4638fe6f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5c58286d60717b8305f4f26a39c5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aab5c58286d60717b8305f4f26a39c5ac">concretize</a> (<a class="el" href="classDatatype.html">Datatype</a> *ct)</td></tr>
<tr class="memdesc:aab5c58286d60717b8305f4f26a39c5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert given data-type to concrete form.  <a href="#aab5c58286d60717b8305f4f26a39c5ac">More...</a><br /></td></tr>
<tr class="separator:aab5c58286d60717b8305f4f26a39c5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d139dc80a61d3b6bb8f75d22622dc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ab9d139dc80a61d3b6bb8f75d22622dc3">dependentOrder</a> (vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;deporder) const </td></tr>
<tr class="memdesc:ab9d139dc80a61d3b6bb8f75d22622dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place all data-types in dependency order.  <a href="#ab9d139dc80a61d3b6bb8f75d22622dc3">More...</a><br /></td></tr>
<tr class="separator:ab9d139dc80a61d3b6bb8f75d22622dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cb3fbc3488c2c79c32a73585e91df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#ad0cb3fbc3488c2c79c32a73585e91df8">saveXml</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:ad0cb3fbc3488c2c79c32a73585e91df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <b>this</b> container to stream.  <a href="#ad0cb3fbc3488c2c79c32a73585e91df8">More...</a><br /></td></tr>
<tr class="separator:ad0cb3fbc3488c2c79c32a73585e91df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea468e00b8ec283aecea4305a873cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a4ea468e00b8ec283aecea4305a873cda">saveXmlCoreTypes</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a4ea468e00b8ec283aecea4305a873cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save core types to stream.  <a href="#a4ea468e00b8ec283aecea4305a873cda">More...</a><br /></td></tr>
<tr class="separator:a4ea468e00b8ec283aecea4305a873cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a16d80bfd84732a8dca11ed4a23fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#af9a16d80bfd84732a8dca11ed4a23fab">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:af9a16d80bfd84732a8dca11ed4a23fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> container from a stream.  <a href="#af9a16d80bfd84732a8dca11ed4a23fab">More...</a><br /></td></tr>
<tr class="separator:af9a16d80bfd84732a8dca11ed4a23fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c7308dab804e4f89fd567500b97d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a24c7308dab804e4f89fd567500b97d63">restoreXmlCoreTypes</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a24c7308dab804e4f89fd567500b97d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize basic type names.  <a href="#a24c7308dab804e4f89fd567500b97d63">More...</a><br /></td></tr>
<tr class="separator:a24c7308dab804e4f89fd567500b97d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e13c732148b6c5f78797d60e1a115f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6e13c732148b6c5f78797d60e1a115f5">parseDataOrganization</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a6e13c732148b6c5f78797d60e1a115f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the &lt;data_organization&gt; tag.  <a href="#a6e13c732148b6c5f78797d60e1a115f5">More...</a><br /></td></tr>
<tr class="separator:a6e13c732148b6c5f78797d60e1a115f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d10b37cae4c213ca3a613f454ada676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8d10b37cae4c213ca3a613f454ada676">parseEnumConfig</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a8d10b37cae4c213ca3a613f454ada676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the &lt;enum&gt; tag.  <a href="#a8d10b37cae4c213ca3a613f454ada676">More...</a><br /></td></tr>
<tr class="separator:a8d10b37cae4c213ca3a613f454ada676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f142a54450d41bc12ca18fe06c6e1e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a7f142a54450d41bc12ca18fe06c6e1e0">setCoreType</a> (const string &amp;name, int4 size, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> meta, bool chartp)</td></tr>
<tr class="memdesc:a7f142a54450d41bc12ca18fe06c6e1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a core data-type.  <a href="#a7f142a54450d41bc12ca18fe06c6e1e0">More...</a><br /></td></tr>
<tr class="separator:a7f142a54450d41bc12ca18fe06c6e1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ccfeecd29c1d5d40ada6b1d4032212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a16ccfeecd29c1d5d40ada6b1d4032212">cacheCoreTypes</a> (void)</td></tr>
<tr class="memdesc:a16ccfeecd29c1d5d40ada6b1d4032212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache common types.  <a href="#a16ccfeecd29c1d5d40ada6b1d4032212">More...</a><br /></td></tr>
<tr class="separator:a16ccfeecd29c1d5d40ada6b1d4032212"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a59da7b0f1344952448062e7b96ceb3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a59da7b0f1344952448062e7b96ceb3e7">findByIdLocal</a> (const string &amp;nm, uint8 id) const </td></tr>
<tr class="memdesc:a59da7b0f1344952448062e7b96ceb3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search locally by name and id.  <a href="#a59da7b0f1344952448062e7b96ceb3e7">More...</a><br /></td></tr>
<tr class="separator:a59da7b0f1344952448062e7b96ceb3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cd8d76884043080a3430f3aff8b010"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a79cd8d76884043080a3430f3aff8b010">findById</a> (const string &amp;n, uint8 id)</td></tr>
<tr class="memdesc:a79cd8d76884043080a3430f3aff8b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search by name and id.  <a href="#a79cd8d76884043080a3430f3aff8b010">More...</a><br /></td></tr>
<tr class="separator:a79cd8d76884043080a3430f3aff8b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0652ec9d4b9d9d0943d1fbffe9b9c740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0652ec9d4b9d9d0943d1fbffe9b9c740"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a0652ec9d4b9d9d0943d1fbffe9b9c740">glb</a></td></tr>
<tr class="memdesc:a0652ec9d4b9d9d0943d1fbffe9b9c740"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> object that owns this <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture. ">TypeFactory</a>. <br /></td></tr>
<tr class="separator:a0652ec9d4b9d9d0943d1fbffe9b9c740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afc2ac2061c8ef5121cdd247164a275c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#afc2ac2061c8ef5121cdd247164a275c3">findNoName</a> (<a class="el" href="classDatatype.html">Datatype</a> &amp;ct)</td></tr>
<tr class="memdesc:afc2ac2061c8ef5121cdd247164a275c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find data-type (in this container) by function.  <a href="#afc2ac2061c8ef5121cdd247164a275c3">More...</a><br /></td></tr>
<tr class="separator:afc2ac2061c8ef5121cdd247164a275c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">findAdd</a> (<a class="el" href="classDatatype.html">Datatype</a> &amp;ct)</td></tr>
<tr class="memdesc:a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find data-type in this container or add it.  <a href="#a8df9fbdeaf67e5f8b4e7b8d02d67cfcc">More...</a><br /></td></tr>
<tr class="separator:a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341cb25206ac827394e47ac7954b501e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a341cb25206ac827394e47ac7954b501e">orderRecurse</a> (vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;deporder, <a class="el" href="type_8hh.html#a718b9f8902a3f2dcc61b4eb84c58adf2">DatatypeSet</a> &amp;mark, <a class="el" href="classDatatype.html">Datatype</a> *ct) const </td></tr>
<tr class="memdesc:a341cb25206ac827394e47ac7954b501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out dependency list.  <a href="#a341cb25206ac827394e47ac7954b501e">More...</a><br /></td></tr>
<tr class="separator:a341cb25206ac827394e47ac7954b501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefbb272df63d0e3bddd0195e52fd308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#adefbb272df63d0e3bddd0195e52fd308">restoreXmlTypeNoRef</a> (const <a class="el" href="classElement.html">Element</a> *el, bool forcecore)</td></tr>
<tr class="memdesc:adefbb272df63d0e3bddd0195e52fd308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore from an XML tag.  <a href="#adefbb272df63d0e3bddd0195e52fd308">More...</a><br /></td></tr>
<tr class="separator:adefbb272df63d0e3bddd0195e52fd308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a52357e69fba6dd4b4adaf4b5279a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a82a52357e69fba6dd4b4adaf4b5279a2">clearCache</a> (void)</td></tr>
<tr class="memdesc:a82a52357e69fba6dd4b4adaf4b5279a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the common type cache.  <a href="#a82a52357e69fba6dd4b4adaf4b5279a2">More...</a><br /></td></tr>
<tr class="separator:a82a52357e69fba6dd4b4adaf4b5279a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9fd247245e31f9eeeec29d245cfa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeChar.html">TypeChar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#af2a9fd247245e31f9eeeec29d245cfa2">getTypeChar</a> (const string &amp;n)</td></tr>
<tr class="memdesc:af2a9fd247245e31f9eeeec29d245cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default "char" type.  <a href="#af2a9fd247245e31f9eeeec29d245cfa2">More...</a><br /></td></tr>
<tr class="separator:af2a9fd247245e31f9eeeec29d245cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a15ff2da4b9476d4f2e9eeeb012fbc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeUnicode.html">TypeUnicode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a7a15ff2da4b9476d4f2e9eeeb012fbc7">getTypeUnicode</a> (const string &amp;nm, int4 sz, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a> m)</td></tr>
<tr class="memdesc:a7a15ff2da4b9476d4f2e9eeeb012fbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default "unicode" type.  <a href="#a7a15ff2da4b9476d4f2e9eeeb012fbc7">More...</a><br /></td></tr>
<tr class="separator:a7a15ff2da4b9476d4f2e9eeeb012fbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264037dc13d6d5d5c643bc805c373375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeCode.html">TypeCode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a264037dc13d6d5d5c643bc805c373375">getTypeCode</a> (const string &amp;n)</td></tr>
<tr class="memdesc:a264037dc13d6d5d5c643bc805c373375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a default "code" type.  <a href="#a264037dc13d6d5d5c643bc805c373375">More...</a><br /></td></tr>
<tr class="separator:a264037dc13d6d5d5c643bc805c373375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a29c926d1ab19f6cd2d5fa7df86eba78e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29c926d1ab19f6cd2d5fa7df86eba78e"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a29c926d1ab19f6cd2d5fa7df86eba78e">sizeOfInt</a></td></tr>
<tr class="memdesc:a29c926d1ab19f6cd2d5fa7df86eba78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the core "int" datatype. <br /></td></tr>
<tr class="separator:a29c926d1ab19f6cd2d5fa7df86eba78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180f8e14584ec0dba65dfc258f96e7ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a180f8e14584ec0dba65dfc258f96e7ea"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a180f8e14584ec0dba65dfc258f96e7ea">align</a></td></tr>
<tr class="memdesc:a180f8e14584ec0dba65dfc258f96e7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment of structures. <br /></td></tr>
<tr class="separator:a180f8e14584ec0dba65dfc258f96e7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe3fddd79a56398f5d9dc7cd537bf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47fe3fddd79a56398f5d9dc7cd537bf3"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a47fe3fddd79a56398f5d9dc7cd537bf3">enumsize</a></td></tr>
<tr class="memdesc:a47fe3fddd79a56398f5d9dc7cd537bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of an enumerated type. <br /></td></tr>
<tr class="separator:a47fe3fddd79a56398f5d9dc7cd537bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b53c08b2845563e7b03253e0474559b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b53c08b2845563e7b03253e0474559b"></a>
<a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a9b53c08b2845563e7b03253e0474559b">enumtype</a></td></tr>
<tr class="memdesc:a9b53c08b2845563e7b03253e0474559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default enumeration meta-type (when parsing C) <br /></td></tr>
<tr class="separator:a9b53c08b2845563e7b03253e0474559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9d31778ed2c9ccc958ba9f52125de2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed9d31778ed2c9ccc958ba9f52125de2"></a>
<a class="el" href="type_8hh.html#a718b9f8902a3f2dcc61b4eb84c58adf2">DatatypeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aed9d31778ed2c9ccc958ba9f52125de2">tree</a></td></tr>
<tr class="memdesc:aed9d31778ed2c9ccc958ba9f52125de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datatypes within this factory (sorted by function) <br /></td></tr>
<tr class="separator:aed9d31778ed2c9ccc958ba9f52125de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35525edc1bb4b769c3e9fbe48d8b642b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35525edc1bb4b769c3e9fbe48d8b642b"></a>
<a class="el" href="type_8hh.html#aa1db0a143363e2b1d1150e3f2168c3ea">DatatypeNameSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a35525edc1bb4b769c3e9fbe48d8b642b">nametree</a></td></tr>
<tr class="memdesc:a35525edc1bb4b769c3e9fbe48d8b642b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-reference by name. <br /></td></tr>
<tr class="separator:a35525edc1bb4b769c3e9fbe48d8b642b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f8367763c472cfe82ebf0c7ef7c6e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5f8367763c472cfe82ebf0c7ef7c6e0"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#aa5f8367763c472cfe82ebf0c7ef7c6e0">typecache</a> [9][8]</td></tr>
<tr class="memdesc:aa5f8367763c472cfe82ebf0c7ef7c6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of the most common atomic data-types. <br /></td></tr>
<tr class="separator:aa5f8367763c472cfe82ebf0c7ef7c6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e98189b4baf44aee9f715375ecd4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e2e98189b4baf44aee9f715375ecd4f"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8e2e98189b4baf44aee9f715375ecd4f">typecache10</a></td></tr>
<tr class="memdesc:a8e2e98189b4baf44aee9f715375ecd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specially cached 10-byte float type. <br /></td></tr>
<tr class="separator:a8e2e98189b4baf44aee9f715375ecd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6071eb27ddaaa93055c521420442a865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6071eb27ddaaa93055c521420442a865"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a6071eb27ddaaa93055c521420442a865">typecache16</a></td></tr>
<tr class="memdesc:a6071eb27ddaaa93055c521420442a865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specially cached 16-byte float type. <br /></td></tr>
<tr class="separator:a6071eb27ddaaa93055c521420442a865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8366394e6205c501a1e128465566b761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8366394e6205c501a1e128465566b761"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeFactory.html#a8366394e6205c501a1e128465566b761">type_nochar</a></td></tr>
<tr class="memdesc:a8366394e6205c501a1e128465566b761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same dimensions as char but acts and displays as an INT. <br /></td></tr>
<tr class="separator:a8366394e6205c501a1e128465566b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Container class for all <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> objects in an <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a68a14752ee51f674664cce90522fe559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeFactory::TypeFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a factory. </p>
<p>Initialize an empty container </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>is the owning <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a16ccfeecd29c1d5d40ada6b1d4032212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::cacheCoreTypes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache common types. </p>
<p>Run through the list of "core" data-types and cache the most commonly accessed ones for quick access (avoiding the tree lookup). The "core" data-types must have been previously initialized. </p>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classDatatype.html#a34c80ea3d6d8d77b59fcde6ff3dd0af0">Datatype::isASCII()</a>, <a class="el" href="classDatatype.html#a662b74f0a1ef64f631ae33d4bc0a8d4b">Datatype::isCharPrint()</a>, <a class="el" href="classDatatype.html#aad9d7fb2e0536d4f5dfd76bcb70868ff">Datatype::isCoreType()</a>, <a class="el" href="classDatatype.html#a83efa6362931d0941b30b84fbc1f0d27">Datatype::isEnumType()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa3e0f738756c5205d71c69d955603f46c">TYPE_BOOL</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p>Referenced by <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra::buildTypegrp()</a>.</p>

</div>
</div>
<a class="anchor" id="a8497930bbd88dd89d91536de06a79f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear out all types. </p>
<p>Remove all <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> objects owned by this <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture. ">TypeFactory</a>. </p>

</div>
</div>
<a class="anchor" id="a82a52357e69fba6dd4b4adaf4b5279a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::clearCache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the common type cache. </p>
<p>Clear the matrix of commonly used atomic types. </p>

</div>
</div>
<a class="anchor" id="afa4b55a83c2f6dbb6f4f13b5ca930ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::clearNoncore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear out non-core types. </p>
<p>Delete anything that isn't a core type. </p>

<p>References <a class="el" href="classDatatype.html#aad9d7fb2e0536d4f5dfd76bcb70868ff">Datatype::isCoreType()</a>.</p>

<p>Referenced by <a class="el" href="classFlushNative.html#a92fb03dcd3fb080a2033442403cde93c">FlushNative::rawAction()</a>.</p>

</div>
</div>
<a class="anchor" id="aab5c58286d60717b8305f4f26a39c5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::concretize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert given data-type to concrete form. </p>
<p>The data-type propagation system can push around data-types that are <em>partial</em> or are otherwise unrepresentable in the source language. This method substitutes those data-types with a concrete data-type that is representable, or returns the same data-type if is already concrete. Its important that the returned data-type have the same size as the original data-type regardless. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the given data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concrete data-type </dd></dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classDatatype.html#a79a16cdae5aff36880bee9122889a0b9">Datatype::metatype</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="classScopeLocal.html#a9776a5769d4422c1e9b9d2dd7c6dfd06">ScopeLocal::createEntry()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d139dc80a61d3b6bb8f75d22622dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::dependentOrder </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>deporder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place all data-types in dependency order. </p>
<p>Place data-types in an order such that if the definition of data-type "a" depends on the definition of data-type "b", then "b" occurs earlier in the order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deporder</td><td>will hold the generated dependency list of data-types </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classPrintC.html#a6511933f0b8fd3f2fef8aa3920aa9de6">PrintC::docTypeDefinitions()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4edd4fa31629380ec4124c840022f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::destroyType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a data-type from <b>this</b>. </p>
<p>The indicated <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object is removed from this container. Indirect references (via <a class="el" href="classTypeArray.html" title="Datatype object representing an array of elements. ">TypeArray</a> <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;. ">TypeStruct</a> etc.) are not affected </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to destroy </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#aad9d7fb2e0536d4f5dfd76bcb70868ff">Datatype::isCoreType()</a>.</p>

</div>
</div>
<a class="anchor" id="a979852b4d0b186f833d16d4638fe6f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::downChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ptrtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb &amp;&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a sub-type matching a pointer and offset. </p>
<p>Add a constant offset to a pointer with known data-type. If there is a valid component at that offset, return a pointer to the data-type of the component or NULL otherwise. This routine only goes down one level at most. Pass back the renormalized offset relative to the new data-type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrtype</td><td>is the pointer data-type being added to </td></tr>
    <tr><td class="paramname">off</td><td>is a reference to the offset to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer datatype for the component or NULL </dd></dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#a88bdee9c5df55dba85ccb3868ee20582">Datatype::getSubType()</a>, <a class="el" href="classTypePointer.html#ae3d9bdbcadcd0cc09b4aea95acba5d7f">TypePointer::getWordSize()</a>, <a class="el" href="classDatatype.html#a79a16cdae5aff36880bee9122889a0b9">Datatype::metatype</a>, <a class="el" href="classTypePointer.html#aa8c502781518e5f51b3020ddd4ac9fe1">TypePointer::ptrto</a>, <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>.</p>

<p>Referenced by <a class="el" href="classTypeOpPtrsub.html#a5c24f6f74d61d5779abadeba089cf0f5">TypeOpPtrsub::getOutputToken()</a>, and <a class="el" href="classActionInferTypes.html#ab2646ac81500c316b9a563ab68a32a79">ActionInferTypes::propagateAddIn2Out()</a>.</p>

</div>
</div>
<a class="anchor" id="a8df9fbdeaf67e5f8b4e7b8d02d67cfcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> &amp;&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find data-type in this container or add it. </p>
<p>Use quickest method (name or id is possible) to locate the matching data-type. If its not currently in <b>this</b> container, clone the data-type and add it to the container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object in this container </dd></dl>

<p>References <a class="el" href="classDatatype.html#a6bd032d91f40efe36841adc85b3ff0ec">Datatype::clone()</a>, <a class="el" href="classDatatype.html#aced5f03d34712b0161e8a9246eb45d53">Datatype::compareDependency()</a>, <a class="el" href="classDatatype.html#aa4d58bf8fd718cb26ed16e8db4a4b067">Datatype::getId()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classDatatype.html#a66d6613a73e69cd4665c90441c4613b3">Datatype::name</a>, and <a class="el" href="classDatatype.html#a0054995eceb34112a7d4265ed8d5be77">Datatype::printRaw()</a>.</p>

</div>
</div>
<a class="anchor" id="a79cd8d76884043080a3430f3aff8b010"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findById </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search by name and id. </p>
<p>Search for a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> by <b>name</b> and/or <b>id</b>. Derived classes may search outside this container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the data-type </td></tr>
    <tr><td class="paramname">id</td><td>is the type id of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>Reimplemented in <a class="el" href="classTypeFactoryGhidra.html#a494fd9c2fb18db1b1f9ee4d7078d590c">TypeFactoryGhidra</a>.</p>

<p>Referenced by <a class="el" href="classTypeFactoryGhidra.html#a494fd9c2fb18db1b1f9ee4d7078d590c">TypeFactoryGhidra::findById()</a>.</p>

</div>
</div>
<a class="anchor" id="a59da7b0f1344952448062e7b96ceb3e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findByIdLocal </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search locally by name and id. </p>
<p>Looking just within this container, find a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> by <b>name</b> and/or <b>id</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the data-type </td></tr>
    <tr><td class="paramname">id</td><td>is the type id of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

</div>
</div>
<a class="anchor" id="a5e139f5b338e423fd2b1beb7d941d30f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of given name. </p>
<p>Find type with given name. If there are more than, return first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object with the name or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="afc2ac2061c8ef5121cdd247164a275c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::findNoName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> &amp;&#160;</td>
          <td class="paramname"><em>ct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find data-type (in this container) by function. </p>
<p>Find data-type without reference to name, using the functional comparators For this to work, the type must be built out of dependencies that are already present in <b>this</b> type factory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a5fe1ae26c0b76b18d59d5cd27a9b8ff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::getBase </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get atomic type. </p>
<p>Get one of the "base" datatypes. This routine is called a lot, so we go through a cache first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the desired size </td></tr>
    <tr><td class="paramname">m</td><td>is the desired meta-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="classMapState.html#a967931fd52c114a90cbbeedd5abc124b">MapState::addGuard()</a>, <a class="el" href="classRuleSubRight.html#a41e3a0031c161d828b8a32239d2c965e">RuleSubRight::applyOp()</a>, <a class="el" href="classCastStrategyC.html#a478423d83d44c4c2d28a461dad75654c">CastStrategyC::arithmeticOutputStandard()</a>, <a class="el" href="classLabSymbol.html#a344ba1ed1c70098c839c2ac33bf83f80">LabSymbol::buildType()</a>, <a class="el" href="classTypeOp.html#a2d6d392af7b7097ccc1153961caf5324">TypeOp::getInputLocal()</a>, <a class="el" href="classTypeOpBinary.html#ad5dddde0ed0b1d0721fe7e140503985c">TypeOpBinary::getInputLocal()</a>, <a class="el" href="classTypeOpUnary.html#acb1b8b0a239bbc31426b1ad312425abb">TypeOpUnary::getInputLocal()</a>, <a class="el" href="classTypeOpFunc.html#a7b3608691fcf7c39432e45e38a8358b0">TypeOpFunc::getInputLocal()</a>, <a class="el" href="classTypeOpCbranch.html#a9e32b6ab7f3ff2cf24854461ad47c120">TypeOpCbranch::getInputLocal()</a>, <a class="el" href="classTypeOpPtradd.html#ab118b0d5709742db5fa189855caa295a">TypeOpPtradd::getInputLocal()</a>, <a class="el" href="classTypeOpPtrsub.html#af4af2514d52a833bfed5a6f7a33f8edf">TypeOpPtrsub::getInputLocal()</a>, <a class="el" href="classTypeOpCpoolref.html#a77c460d64ce863b4f94d80c3868c1e60">TypeOpCpoolref::getInputLocal()</a>, <a class="el" href="classTypeOpInsert.html#af87b1782fc5b6dabf05d2031d61e6b9c">TypeOpInsert::getInputLocal()</a>, <a class="el" href="classTypeOpExtract.html#add66513ac5cbf8d3284a5836e08c5fe6">TypeOpExtract::getInputLocal()</a>, <a class="el" href="classTypeOp.html#acebbee9b0b54b9e3fd319cd9736e93db">TypeOp::getOutputLocal()</a>, <a class="el" href="classTypeOpBinary.html#aecbef2320541af3469089261e741432b">TypeOpBinary::getOutputLocal()</a>, <a class="el" href="classTypeOpUnary.html#ac38de6a3d144e2dec2cf0120de3db98e">TypeOpUnary::getOutputLocal()</a>, <a class="el" href="classTypeOpFunc.html#a823f957f4bb4a29e452fa46cea1e9edd">TypeOpFunc::getOutputLocal()</a>, <a class="el" href="classTypeOpPtradd.html#aa8ec8862e3153dabe5f5637845605ca7">TypeOpPtradd::getOutputLocal()</a>, <a class="el" href="classTypeOpPtrsub.html#abb4f612959227c221077ac9b7f41656c">TypeOpPtrsub::getOutputLocal()</a>, <a class="el" href="classTypeOpCpoolref.html#a7802896b840b22a468a9a74cb967e81b">TypeOpCpoolref::getOutputLocal()</a>, <a class="el" href="classTypeOpIntLeft.html#ae7fcbe8dd18b69c53eb4c8bf71961685">TypeOpIntLeft::getOutputToken()</a>, <a class="el" href="classTypeOpIntRight.html#a4054c4130f44622d2a3a0efc1e249ece">TypeOpIntRight::getOutputToken()</a>, <a class="el" href="classTypeOpIntSright.html#ab84b96a97ff0697f90380fac1a4433e1">TypeOpIntSright::getOutputToken()</a>, <a class="el" href="classTypeOpPiece.html#ae4a4a055003df2d94820f5226a50f7da">TypeOpPiece::getOutputToken()</a>, <a class="el" href="classTypeOpSubpiece.html#abeb192fdf62c91d2c90fd63e84bba3ff">TypeOpSubpiece::getOutputToken()</a>, <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">Funcdata::mapGlobals()</a>, <a class="el" href="classRangeHint.html#acce59afd659776a70a7086f9d9024a1e">RangeHint::merge()</a>, <a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">Funcdata::newConstant()</a>, <a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">Funcdata::newUnique()</a>, <a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">Funcdata::newUniqueOut()</a>, <a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">Funcdata::newVarnode()</a>, <a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">Funcdata::newVarnodeCallSpecs()</a>, <a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">Funcdata::newVarnodeIop()</a>, <a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">Funcdata::newVarnodeOut()</a>, <a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">Funcdata::newVarnodeSpace()</a>, <a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">FuncProto::paramShift()</a>, <a class="el" href="classScopeInternal.html#a07b67a407984707a01a2228b347d9fed">ScopeInternal::processCollision()</a>, <a class="el" href="classActionInferTypes.html#ab2646ac81500c316b9a563ab68a32a79">ActionInferTypes::propagateAddIn2Out()</a>, <a class="el" href="classActionInferTypes.html#a7cd85268ef220778b05b1fcaa38b2c91">ActionInferTypes::propagateTypeEdge()</a>, <a class="el" href="classPrintC.html#a234b95d9f3fdb8a79eeff02eb4acbca3">PrintC::pushAnnotation()</a>, <a class="el" href="classParameterBasic.html#ac3aed750efa13f72a9a674ceb666eb9a">ParameterBasic::resetSizeLockType()</a>, <a class="el" href="classEquateSymbol.html#ab4aa7cdacdd28777f82bf0be1ad55454">EquateSymbol::restoreXml()</a>, <a class="el" href="classFuncProto.html#a33463f351b0ebc8c8f6065eff896dbc3">FuncProto::updateInputNoTypes()</a>, <a class="el" href="classFuncProto.html#ae89afc199ba2c4c8261dac381c5e426b">FuncProto::updateInputTypes()</a>, and <a class="el" href="classFuncProto.html#a882e34d08f3e4e44ba5aa25b87c84bfe">FuncProto::updateOutputNoTypes()</a>.</p>

</div>
</div>
<a class="anchor" id="a2848b5923834b755de0749d9f96880e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::getBase </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get named atomic type. </p>
<p>Get or create a "base" type with a specified name and properties </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the desired size </td></tr>
    <tr><td class="paramname">m</td><td>is the desired meta-type </td></tr>
    <tr><td class="paramname">n</td><td>is the desired name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classDatabase.html" title="A manager for symbol scopes for a whole executable. ">Database</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a class="anchor" id="adca2937f24e37c5ac19ba442cd1df0d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::getBaseNoChar </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get atomic type excluding "char". </p>
<p>Get a "base" data-type, given its size and <b>metatype</b>. If a 1-byte integer is requested, do NOT return a <a class="el" href="classTypeChar.html" title="Base type for character data-types: i.e. char. ">TypeChar</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the data-type </td></tr>
    <tr><td class="paramname">m</td><td>is the meta-type of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>.</p>

<p>Referenced by <a class="el" href="classTypeOpIntLeft.html#ad896026e2f3dbc6c7ddf91cb811816f9">TypeOpIntLeft::getInputLocal()</a>, <a class="el" href="classTypeOpIntRight.html#a30b31466abcf5049aaea990036ed889a">TypeOpIntRight::getInputLocal()</a>, and <a class="el" href="classTypeOpIntSright.html#a4206b7fc83bbf25a0a854dfc06bfc05d">TypeOpIntSright::getInputLocal()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1efe412493c66b6072ae0def3b53004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeArray.html">TypeArray</a> * TypeFactory::getTypeArray </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ao</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an array data-type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>is the number of elements in the desired array </td></tr>
    <tr><td class="paramname">ao</td><td>is the data-type of the array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeArray.html" title="Datatype object representing an array of elements. ">TypeArray</a> object </dd></dl>

<p>Referenced by <a class="el" href="classScopeLocal.html#a9776a5769d4422c1e9b9d2dd7c6dfd06">ScopeLocal::createEntry()</a>.</p>

</div>
</div>
<a class="anchor" id="af2a9fd247245e31f9eeeec29d245cfa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeChar.html">TypeChar</a> * TypeFactory::getTypeChar </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a default "char" type. </p>
<p>This creates a 1-byte character datatype (assumed to use UTF8 encoding) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name to give the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new character <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a class="anchor" id="a264037dc13d6d5d5c643bc805c373375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeCode.html">TypeCode</a> * TypeFactory::getTypeCode </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a default "code" type. </p>
<p>Create a "function" or "executable" <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object This is used for anonymous function pointers with no prototype </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

<p>Referenced by <a class="el" href="classExternRefSymbol.html#aa4910e1cd3e935b25574a07752a0b6ea">ExternRefSymbol::buildNameType()</a>, <a class="el" href="classFunctionSymbol.html#afdba700a8ea13faf3b57747ab4f08503">FunctionSymbol::buildType()</a>, <a class="el" href="classTypeOpCbranch.html#a9e32b6ab7f3ff2cf24854461ad47c120">TypeOpCbranch::getInputLocal()</a>, <a class="el" href="classTypeOpCallind.html#a5ce36d1fe2e6af0d213d3c88b7e6383a">TypeOpCallind::getInputLocal()</a>, <a class="el" href="classTypeOpIndirect.html#a274b67b0eb3f40164eec2ace66e65ad2">TypeOpIndirect::getInputLocal()</a>, and <a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">Funcdata::newCodeRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a47c3d70d9598d2b4ce3770593f6ce97e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeCode.html">TypeCode</a> * TypeFactory::getTypeCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an "anonymous" function data-type. </p>
<p>Retrieve or create the core "code" <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object This has no prototype attached to it and is appropriate for anonymous function pointers. </p><dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeCode.html" title="Datatype object representing executable code. ">TypeCode</a> object </dd></dl>

<p>References <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>.</p>

</div>
</div>
<a class="anchor" id="a99362bf53b0ead2d57a2221bc2fd03cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeCode.html">TypeCode</a> * TypeFactory::getTypeCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>outtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>intypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dotdotdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a "function" datatype. </p>
<p>Creates a <a class="el" href="classTypeCode.html" title="Datatype object representing executable code. ">TypeCode</a> object and associates a specific function prototype with it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>is the prototype model associated with the function </td></tr>
    <tr><td class="paramname">outtype</td><td>is the return type of the function </td></tr>
    <tr><td class="paramname">intypes</td><td>is the array of input parameters of the function </td></tr>
    <tr><td class="paramname">dotdotdot</td><td>is true if the function takes variable arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeCode.html" title="Datatype object representing executable code. ">TypeCode</a> object </dd></dl>

<p>References <a class="el" href="classTypeCode.html#a878a806b0169f8e0a4b7cab6c8b4c91b">TypeCode::set()</a>.</p>

</div>
</div>
<a class="anchor" id="a3bb1aba15e198a7ba2b67741c571de3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeEnum.html">TypeEnum</a> * TypeFactory::getTypeEnum </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an (empty) enumeration. </p>
<p>The created enumeration will have no named values and a default configuration Named values must be added later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the enumeration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeEnum.html" title="An enumerated Datatype object: an integer with named values. ">TypeEnum</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebdac49f33c823aed43744eb7b5ab70d48cb">Datatype::enumtype</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff26aa7e6197ffb865907313f752d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypePointer.html">TypePointer</a> * TypeFactory::getTypePointer </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an absolute pointer data-type. </p>
<p>Allows "pointer to array" to be constructed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the pointer </td></tr>
    <tr><td class="paramname">pt</td><td>is the pointed-to data-type </td></tr>
    <tr><td class="paramname">ws</td><td>is the wordsize associated with the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypePointer.html" title="Datatype object representing a pointer. ">TypePointer</a> object </dd></dl>

<p>Referenced by <a class="el" href="classParamListStandard.html#aef94d59e375ee645f417b9ba1b550bfc">ParamListStandard::assignMap()</a>, <a class="el" href="classParamListStandardOut.html#a132e68df82ac19f9ed54e1d4364309e9">ParamListStandardOut::assignMap()</a>, <a class="el" href="classExternRefSymbol.html#aa4910e1cd3e935b25574a07752a0b6ea">ExternRefSymbol::buildNameType()</a>, <a class="el" href="classTypeOpLoad.html#a8023cd2838b18183834eb3713de42c5a">TypeOpLoad::getInputCast()</a>, <a class="el" href="classTypeOpStore.html#a7574db6e31ff8738e872602818f77786">TypeOpStore::getInputCast()</a>, <a class="el" href="classTypeOpCbranch.html#a9e32b6ab7f3ff2cf24854461ad47c120">TypeOpCbranch::getInputLocal()</a>, <a class="el" href="classTypeOpCallind.html#a5ce36d1fe2e6af0d213d3c88b7e6383a">TypeOpCallind::getInputLocal()</a>, <a class="el" href="classTypeOpIndirect.html#a274b67b0eb3f40164eec2ace66e65ad2">TypeOpIndirect::getInputLocal()</a>, <a class="el" href="classActionInferTypes.html#ab2646ac81500c316b9a563ab68a32a79">ActionInferTypes::propagateAddIn2Out()</a>, <a class="el" href="classActionInferTypes.html#a7cd85268ef220778b05b1fcaa38b2c91">ActionInferTypes::propagateTypeEdge()</a>, <a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">Funcdata::spacebase()</a>, and <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">Funcdata::spacebaseConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a77988d5cf50fc10fe92dec8e265a720f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypePointer.html">TypePointer</a> * TypeFactory::getTypePointerNoDepth </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a depth limited pointer data-type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the pointer </td></tr>
    <tr><td class="paramname">pt</td><td>is the pointed-to data-type </td></tr>
    <tr><td class="paramname">ws</td><td>is the wordsize associated with the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypePointer.html" title="Datatype object representing a pointer. ">TypePointer</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="classActionInferTypes.html#a7cd85268ef220778b05b1fcaa38b2c91">ActionInferTypes::propagateTypeEdge()</a>.</p>

</div>
</div>
<a class="anchor" id="aff97843c231aea653d16621caa5f1ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypePointer.html">TypePointer</a> * TypeFactory::getTypePointerStripArray </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a pointer data-type, stripping an ARRAY level. </p>
<p>This creates a pointer to a given data-type. If the given data-type is an array, the TYPE_ARRAY property is stripped off, and a pointer to the array element data-type is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the pointer </td></tr>
    <tr><td class="paramname">pt</td><td>is the pointed-to data-type </td></tr>
    <tr><td class="paramname">ws</td><td>is the wordsize associated with the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypePointer.html" title="Datatype object representing a pointer. ">TypePointer</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">Funcdata::spacebaseConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a85de9d19ce1dc44476a414f5ce69b97e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeSpacebase.html">TypeSpacebase</a> * TypeFactory::getTypeSpacebase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a "spacebase" type. </p>
<p>Creates the special <a class="el" href="classTypeSpacebase.html" title="Special Datatype object used to describe pointers that index into the symbol table. ">TypeSpacebase</a> with an associated address space and scope </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the address space </td></tr>
    <tr><td class="paramname">addr</td><td>specifies the function scope, or isInvalid() for global scope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeSpacebase.html" title="Special Datatype object used to describe pointers that index into the symbol table. ">TypeSpacebase</a> object </dd></dl>

<p>Referenced by <a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">Funcdata::spacebase()</a>, and <a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">Funcdata::spacebaseConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa4a75179b840571eeb97e24642c55ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeStruct.html">TypeStruct</a> * TypeFactory::getTypeStruct </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an (empty) structure. </p>
<p>The created structure will have no fields. They must be added later. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the name of the structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;. ">TypeStruct</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a class="anchor" id="a7a15ff2da4b9476d4f2e9eeeb012fbc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeUnicode.html">TypeUnicode</a> * TypeFactory::getTypeUnicode </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a default "unicode" type. </p>
<p>This creates a multi-byte character data-type (using UTF16 or UTF32 encoding) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name to give the data-type </td></tr>
    <tr><td class="paramname">sz</td><td>is the size of the data-type in bytes </td></tr>
    <tr><td class="paramname">m</td><td>is the presumed <b>meta-type</b> when treating the character as an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new character <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, and <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>.</p>

</div>
</div>
<a class="anchor" id="ab7277908ef32101f172633ec00fbecb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeVoid.html">TypeVoid</a> * TypeFactory::getTypeVoid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "void" data-type. </p>
<p>There should be exactly one instance of the "void" <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object, which this fetches </p><dl class="section return"><dt>Returns</dt><dd>the "void" data-type </dd></dl>

<p>References <a class="el" href="classTypeVoid.html#a7426947eba25e48f22f6c889db3cb429">TypeVoid::clone()</a>, <a class="el" href="classDatatype.html#aed6a6e39276b70ffb7d8bba122988438">Datatype::getName()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa19a0a402d33a2e049e91ea9e37e90c2f">TYPE_FLOAT</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p>Referenced by <a class="el" href="classActionDefaultParams.html#a32f4c196d02d9f86c66749b9bf5d2247">ActionDefaultParams::apply()</a>, <a class="el" href="classPrintC.html#a18fa1574b22c87e7ef25e4a0b99284ac">PrintC::buildTypeStack()</a>, <a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">FuncProto::paramShift()</a>, <a class="el" href="classPrintJava.html#af82e5ca143891ea052778b1ed234d3e0">PrintJava::pushTypeStart()</a>, and <a class="el" href="classOverride.html#a81f34dfc11c427ea0873358bef93ada3">Override::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a341cb25206ac827394e47ac7954b501e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::orderRecurse </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>deporder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#a718b9f8902a3f2dcc61b4eb84c58adf2">DatatypeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out dependency list. </p>
<p>Recursively write out all the components of a data-type in dependency order Component data-types will come before the data-type containing them in the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deporder</td><td>holds the ordered list of data-types to construct </td></tr>
    <tr><td class="paramname">mark</td><td>is a "marking" container to prevent cycles </td></tr>
    <tr><td class="paramname">ct</td><td>is the data-type to have written out </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#a9cc7b10e17d91c9ee6bb03cb43c951b2">Datatype::getDepend()</a>, <a class="el" href="classDatatype.html#a3fa6babebaf8fb9e4936d519da186c1c">Datatype::numDepend()</a>, and <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>.</p>

</div>
</div>
<a class="anchor" id="a6e13c732148b6c5f78797d60e1a115f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::parseDataOrganization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the &lt;data_organization&gt; tag. </p>
<p>Recover various sizes relevant to <b>this</b> container, such as the default size of "int" and structure alignment, by parsing the &lt;data_organization&gt; tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, and <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d10b37cae4c213ca3a613f454ada676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::parseEnumConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the &lt;enum&gt; tag. </p>
<p>Recover default enumeration properties (size and meta-type) from an &lt;enum&gt; XML tag. Should probably consider this deprecated. These values are only used by the internal C parser. param el is the XML element </p>

<p>References <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebdac49f33c823aed43744eb7b5ab70d48cb">Datatype::enumtype</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

</div>
</div>
<a class="anchor" id="af9a16d80bfd84732a8dca11ed4a23fab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <b>this</b> container from a stream. </p>
<p>Read data-types into this container from an XML stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root XML element </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebdac49f33c823aed43744eb7b5ab70d48cb">Datatype::enumtype</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

</div>
</div>
<a class="anchor" id="a24c7308dab804e4f89fd567500b97d63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::restoreXmlCoreTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize basic type names. </p>
<p>Restore data-types from an XML stream into this container This stream is presumed to contain "core" datatypes and the cached matrix will be populated from this set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root XML element </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>.</p>

<p>Referenced by <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra::buildTypegrp()</a>.</p>

</div>
</div>
<a class="anchor" id="aea5f4036abb11e63ca5f79a9eacfc93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::restoreXmlType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> from XML. </p>
<p>Restore a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object from an XML tag description: either &lt;type&gt;, &lt;typeref&gt;, or &lt;void&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element describing the data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>, and <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>.</p>

<p>Referenced by <a class="el" href="classTypeFactoryGhidra.html#a494fd9c2fb18db1b1f9ee4d7078d590c">TypeFactoryGhidra::findById()</a>, <a class="el" href="classCPoolRecord.html#a93e21b4afa8d1db68152b7d6e56c3413">CPoolRecord::restoreXml()</a>, <a class="el" href="classProtoStoreInternal.html#ae1c3cd409eda277f1ff924cf858eddef">ProtoStoreInternal::restoreXml()</a>, and <a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">FuncProto::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="adefbb272df63d0e3bddd0195e52fd308"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::restoreXmlTypeNoRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forcecore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore from an XML tag. </p>
<p>Restore a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object from an XML &lt;type&gt; tag. (Don't use for &lt;typeref&gt; tags) The new <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> is added to <b>this</b> container </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element </td></tr>
    <tr><td class="paramname">forcecore</td><td>is true if the new type should be labeled as a core type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#aced5f03d34712b0161e8a9246eb45d53">Datatype::compareDependency()</a>, <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebda8efcece19aae42262429fbf59330a2c7">Datatype::coretype</a>, <a class="el" href="classTypeStruct.html#a4d5a49b12324fb588f6c1631c35bc37d">TypeStruct::field</a>, <a class="el" href="classDatatype.html#a82e59a9379488b5afdae69817c0955fb">Datatype::flags</a>, <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, <a class="el" href="classDatatype.html#a0089e0e5057fe9c8caa1011d15ac22d9">Datatype::hashSize()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, <a class="el" href="classDatatype.html#aed882ae693a31a64d56fffb9abdaa575">Datatype::restoreXml()</a>, <a class="el" href="classTypeUnicode.html#a3158417117649e59ffe402137c22bb67">TypeUnicode::restoreXml()</a>, <a class="el" href="classTypePointer.html#a8f62fbff5e735eb8ad562878bc5efed7">TypePointer::restoreXml()</a>, <a class="el" href="classTypeArray.html#a3f933b477f4089344f7a58ef67aa6ee1">TypeArray::restoreXml()</a>, <a class="el" href="classTypeEnum.html#a1bd4dc88f4ea0b58b4b164b4b5f4f5e5">TypeEnum::restoreXml()</a>, <a class="el" href="classTypeStruct.html#af2b09832da8420f6da67382a4e2d9f0e">TypeStruct::restoreXml()</a>, <a class="el" href="classTypeCode.html#a8b721a26b30c296fe2510738601e3333">TypeCode::restoreXml()</a>, <a class="el" href="classTypeSpacebase.html#ad47f882d367ee73d16adf3140862ca65">TypeSpacebase::restoreXml()</a>, <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>, <a class="el" href="type_8hh.html#ae2f04f32a572d784b4c46f6745239c42">string2metatype()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fae8e2fb69af09eb8907e86b16ff585324">TYPE_SPACEBASE</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

</div>
</div>
<a class="anchor" id="ab25856a74501dae4b91e1b5313773bff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::restoreXmlTypeWithCodeFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConstructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDestructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore data-type from XML with extra "code" flags. </p>
<p>Kludge to get flags into code pointer types, when they can't come through XML </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the XML element describing the <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> </td></tr>
    <tr><td class="paramname">isConstructor</td><td>toggles "constructor" property on "function" datatypes </td></tr>
    <tr><td class="paramname">isDestructor</td><td>toggles "destructor" property on "function" datatypes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the restored <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>, <a class="el" href="classTypePointer.html#aa8c502781518e5f51b3020ddd4ac9fe1">TypePointer::ptrto</a>, <a class="el" href="classTypeCode.html#a8b721a26b30c296fe2510738601e3333">TypeCode::restoreXml()</a>, <a class="el" href="classDatatype.html#afeb70488c52d024b293d5198c98b3f49">Datatype::restoreXmlBasic()</a>, <a class="el" href="classTypeCode.html#a634e7a06efa647d6fa756bddc005a228">TypeCode::setProperties()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="classTypePointer.html#a32eee64befc16e8200d81477a5846ec6">TypePointer::wordsize</a>.</p>

<p>Referenced by <a class="el" href="classCPoolRecord.html#a93e21b4afa8d1db68152b7d6e56c3413">CPoolRecord::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0cb3fbc3488c2c79c32a73585e91df8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save <b>this</b> container to stream. </p>
<p>All data-types, in dependency order, are written out to an XML stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="xml_8hh.html#a87634423f394bc832a51957ee6fc85c9">a_v_b()</a>, <a class="el" href="xml_8hh.html#aa12f4a381037faf4e90d1876bb44aa02">a_v_i()</a>, <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebdac49f33c823aed43744eb7b5ab70d48cb">Datatype::enumtype</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa4fcd4421533bb21c827865bdbac4fef9">TYPE_INT</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea468e00b8ec283aecea4305a873cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::saveXmlCoreTypes </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save core types to stream. </p>
<p>Any data-type within this container marked as "core" will be written to an XML &lt;coretypes&gt; stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#aad9d7fb2e0536d4f5dfd76bcb70868ff">Datatype::isCoreType()</a>, <a class="el" href="classDatatype.html#a803c57a943c69d832a432777791a0df0">Datatype::saveXml()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fad189c0a53681ec74eeea1f56d08d741f">TYPE_ARRAY</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa311715f465e358409d513be004f82b2f">TYPE_PTR</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa9001cd1bc103bb1d664228d46715f65c">TYPE_STRUCT</a>.</p>

<p>Referenced by <a class="el" href="classXmlArchitecture.html#a6acd4b968cc1398afc0c7098052a464e">XmlArchitecture::saveXml()</a>, <a class="el" href="classRawBinaryArchitecture.html#a14266f82ce3157a3a3a5031c451f8c1c">RawBinaryArchitecture::saveXml()</a>, and <a class="el" href="classBfdArchitecture.html#ac8794cb8946bed2576715e52f33ec658">BfdArchitecture::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f142a54450d41bc12ca18fe06c6e1e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::setCoreType </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61f">type_metatype</a>&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chartp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a core data-type. </p>
<p>Manually create a "base" core type. This currently must be called before any pointers or arrays are defined off of the type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the data-type name </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the data-type </td></tr>
    <tr><td class="paramname">meta</td><td>is the meta-type of the data-type </td></tr>
    <tr><td class="paramname">chartp</td><td>is true if a character type should be created </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebda8efcece19aae42262429fbf59330a2c7">Datatype::coretype</a>, <a class="el" href="classDatatype.html#a82e59a9379488b5afdae69817c0955fb">Datatype::flags</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa88922d1c65a64d2f39ebaba3411aa057">TYPE_CODE</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p>Referenced by <a class="el" href="classArchitectureGhidra.html#afdc4a7c905c401909628967b4b249ddc">ArchitectureGhidra::buildTypegrp()</a>.</p>

</div>
</div>
<a class="anchor" id="a17cf58ac6b927a91b4f794a3347b2822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeFactory::setEnumValues </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; uintb &gt; &amp;&#160;</td>
          <td class="paramname"><em>vallist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>assignlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeEnum.html">TypeEnum</a> *&#160;</td>
          <td class="paramname"><em>te</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set named values for an enumeration. </p>
<p>Set the list of enumeration values and identifiers for a <a class="el" href="classTypeEnum.html" title="An enumerated Datatype object: an integer with named values. ">TypeEnum</a> Fill in any values for any names that weren't explicitly assigned and check for duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namelist</td><td>is the list of names in the enumeration </td></tr>
    <tr><td class="paramname">vallist</td><td>is the corresponding list of values assigned to names in namelist </td></tr>
    <tr><td class="paramname">assignlist</td><td>is true if the corresponding name in namelist has an assigned value </td></tr>
    <tr><td class="paramname">te</td><td>is the enumeration object to modify </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the modification is successful (no duplicate names) </dd></dl>

<p>References <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, and <a class="el" href="classTypeEnum.html#a888839555ff7b768f371e794a979a8dc">TypeEnum::setNameMap()</a>.</p>

</div>
</div>
<a class="anchor" id="afc1fc5e17c8e0636ea976cc0e28113fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeFactory::setFields </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structTypeField.html">TypeField</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeStruct.html">TypeStruct</a> *&#160;</td>
          <td class="paramname"><em>ot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>fixedsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fields on a <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;. ">TypeStruct</a>. </p>
<p>Make sure all the offsets are fully established then set fields of the structure If -fixedsize- is greater than 0, force the final structure to have that size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the list of fields to set </td></tr>
    <tr><td class="paramname">ot</td><td>is the <a class="el" href="classTypeStruct.html" title="A composite Datatype object: A &quot;structure&quot; with component &quot;fields&quot;. ">TypeStruct</a> object to modify </td></tr>
    <tr><td class="paramname">fixedsize</td><td>is 0 or the forced size of the structure </td></tr>
    <tr><td class="paramname">flags</td><td>are other flags to set on the structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if modification was successful </dd></dl>

<p>References <a class="el" href="classDatatype.html#a82e59a9379488b5afdae69817c0955fb">Datatype::flags</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classDatatype.html#aed6a6e39276b70ffb7d8bba122988438">Datatype::getName()</a>, <a class="el" href="classDatatype.html#a8f6926356d42756e5b4d7ecaa3650dbb">Datatype::getSize()</a>, <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebdadb3bd443e2c976a3add73a7f8fe3dd44">Datatype::opaque_string</a>, <a class="el" href="classTypeStruct.html#abf9d27b301d027a5fad874b1f8c93b8c">TypeStruct::setFields()</a>, <a class="el" href="classDatatype.html#a14476d90cd8993852b349b621876b292">Datatype::size</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>, and <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebda10212791964f9bfc9413faab7031080b">Datatype::variable_length</a>.</p>

</div>
</div>
<a class="anchor" id="a6a2c74462f5a832e6233421bb6cb1beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDatatype.html">Datatype</a> * TypeFactory::setName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given types name. </p>
<p>This routine renames a <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object and fixes up cross-referencing </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ct</td><td>is the data-type to rename </td></tr>
    <tr><td class="paramname">n</td><td>is the new name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the renamed <a class="el" href="classDatatype.html" title="The base datatype class for the decompiler. ">Datatype</a> object </dd></dl>

<p>References <a class="el" href="classDatatype.html#a4733a0e51a359ad324583d06824b5b92">Datatype::hashName()</a>, <a class="el" href="classDatatype.html#ac2bb702c6067fae98d7c0257e928d5a1">Datatype::id</a>, and <a class="el" href="classDatatype.html#a66d6613a73e69cd4665c90441c4613b3">Datatype::name</a>.</p>

</div>
</div>
<a class="anchor" id="afae3189d62867e5358bcbb98e7723b75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeFactory::setupSizes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derive some size information from <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a>. </p>
<p>Set up default values for size of "int", structure alignment, and enums. </p>

<p>References <a class="el" href="classDatatype.html#af2bce313e85e260a67f5b91d51622ebdac49f33c823aed43744eb7b5ab70d48cb">Datatype::enumtype</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61faba807ad7d41a3ac08fd4a71e9e013192">TYPE_UINT</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="type_8hh.html">type.hh</a></li>
<li>type.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
