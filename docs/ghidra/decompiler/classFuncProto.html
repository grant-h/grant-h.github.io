<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: FuncProto Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFuncProto-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FuncProto Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <b>function</b> <b>prototype</b>.  
 <a href="classFuncProto.html#details">More...</a></p>

<p><code>#include &lt;fspec.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FuncProto:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFuncProto.png" usemap="#FuncProto_map" alt=""/>
  <map id="FuncProto_map" name="FuncProto_map">
<area href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. " alt="FuncCallSpecs" shape="rect" coords="0,56,98,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c7db7dec63a18a9de97b0ba9f6f42bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c7db7dec63a18a9de97b0ba9f6f42bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9c7db7dec63a18a9de97b0ba9f6f42bd">FuncProto</a> (void)</td></tr>
<tr class="memdesc:a9c7db7dec63a18a9de97b0ba9f6f42bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a9c7db7dec63a18a9de97b0ba9f6f42bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142706f5f3c9086635f812501521f3b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142706f5f3c9086635f812501521f3b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a142706f5f3c9086635f812501521f3b4">~FuncProto</a> (void)</td></tr>
<tr class="memdesc:a142706f5f3c9086635f812501521f3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a142706f5f3c9086635f812501521f3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00b0b2e61b845d3fd66c6e3ad7e028b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af00b0b2e61b845d3fd66c6e3ad7e028b"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af00b0b2e61b845d3fd66c6e3ad7e028b">getArch</a> (void) const </td></tr>
<tr class="memdesc:af00b0b2e61b845d3fd66c6e3ad7e028b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> owning <b>this</b>. <br /></td></tr>
<tr class="separator:af00b0b2e61b845d3fd66c6e3ad7e028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4f3bc764b11b57f4e71b9d19df27d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">copy</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:a9bd4f3bc764b11b57f4e71b9d19df27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another function prototype.  <a href="#a9bd4f3bc764b11b57f4e71b9d19df27d">More...</a><br /></td></tr>
<tr class="separator:a9bd4f3bc764b11b57f4e71b9d19df27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26c345cdf567de704b24cd99e8a254"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace26c345cdf567de704b24cd99e8a254"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace26c345cdf567de704b24cd99e8a254">copyFlowEffects</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:ace26c345cdf567de704b24cd99e8a254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy properties that affect data-flow. <br /></td></tr>
<tr class="separator:ace26c345cdf567de704b24cd99e8a254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b8d7ee2d89654f589f62ed7f02af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6b2b8d7ee2d89654f589f62ed7f02af8">getPieces</a> (<a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces) const </td></tr>
<tr class="memdesc:a6b2b8d7ee2d89654f589f62ed7f02af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw pieces of the prototype.  <a href="#a6b2b8d7ee2d89654f589f62ed7f02af8">More...</a><br /></td></tr>
<tr class="separator:a6b2b8d7ee2d89654f589f62ed7f02af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f53c7733c8aa58d9138a8f3add2ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8e6f53c7733c8aa58d9138a8f3add2ce">setPieces</a> (const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces)</td></tr>
<tr class="memdesc:a8e6f53c7733c8aa58d9138a8f3add2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> prototype based on raw pieces.  <a href="#a8e6f53c7733c8aa58d9138a8f3add2ce">More...</a><br /></td></tr>
<tr class="separator:a8e6f53c7733c8aa58d9138a8f3add2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83eddece4cb123d198ad288dfa89bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">setScope</a> (<a class="el" href="classScope.html">Scope</a> *s, const <a class="el" href="classAddress.html">Address</a> &amp;startpoint)</td></tr>
<tr class="memdesc:adc83eddece4cb123d198ad288dfa89bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a backing symbol <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> for <b>this</b>.  <a href="#adc83eddece4cb123d198ad288dfa89bd">More...</a><br /></td></tr>
<tr class="separator:adc83eddece4cb123d198ad288dfa89bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f89b0b3c5165e521d33b658599699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699">setInternal</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m, <a class="el" href="classDatatype.html">Datatype</a> *vt)</td></tr>
<tr class="memdesc:af69f89b0b3c5165e521d33b658599699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set internal backing storage for <b>this</b>.  <a href="#af69f89b0b3c5165e521d33b658599699">More...</a><br /></td></tr>
<tr class="separator:af69f89b0b3c5165e521d33b658599699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c14d15c7296c47deae3433687b1b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae8c14d15c7296c47deae3433687b1b15">setModel</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m)</td></tr>
<tr class="memdesc:ae8c14d15c7296c47deae3433687b1b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the prototype model for <b>this</b>.  <a href="#ae8c14d15c7296c47deae3433687b1b15">More...</a><br /></td></tr>
<tr class="separator:ae8c14d15c7296c47deae3433687b1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13789408c17e4ae93280f6043ea051a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13789408c17e4ae93280f6043ea051a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a13789408c17e4ae93280f6043ea051a8">hasModel</a> (void) const </td></tr>
<tr class="memdesc:a13789408c17e4ae93280f6043ea051a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> prototype have a model. <br /></td></tr>
<tr class="separator:a13789408c17e4ae93280f6043ea051a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb7a86abc4cdae2aad0f5104f374c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7fb7a86abc4cdae2aad0f5104f374c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad7fb7a86abc4cdae2aad0f5104f374c7">hasMatchingModel</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> *op2) const </td></tr>
<tr class="memdesc:ad7fb7a86abc4cdae2aad0f5104f374c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> have a matching model. <br /></td></tr>
<tr class="separator:ad7fb7a86abc4cdae2aad0f5104f374c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac5ccbadf105478e51f8f7773cf369e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeac5ccbadf105478e51f8f7773cf369e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aeac5ccbadf105478e51f8f7773cf369e">hasMatchingModel</a> (const <a class="el" href="classProtoModel.html">ProtoModel</a> *op2) const </td></tr>
<tr class="memdesc:aeac5ccbadf105478e51f8f7773cf369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> use the given model. <br /></td></tr>
<tr class="separator:aeac5ccbadf105478e51f8f7773cf369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ab2e02f3915ee505485c186d5c5d93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11ab2e02f3915ee505485c186d5c5d93"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a11ab2e02f3915ee505485c186d5c5d93">getModelName</a> (void) const </td></tr>
<tr class="memdesc:a11ab2e02f3915ee505485c186d5c5d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the prototype model name. <br /></td></tr>
<tr class="separator:a11ab2e02f3915ee505485c186d5c5d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b7b20667b3db5b4855ffab044f346e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5b7b20667b3db5b4855ffab044f346e"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac5b7b20667b3db5b4855ffab044f346e">getModelExtraPop</a> (void) const </td></tr>
<tr class="memdesc:ac5b7b20667b3db5b4855ffab044f346e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>extrapop</em> of the prototype model. <br /></td></tr>
<tr class="separator:ac5b7b20667b3db5b4855ffab044f346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea485adaba5702435dc089d2648e1d49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea485adaba5702435dc089d2648e1d49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aea485adaba5702435dc089d2648e1d49">isInputLocked</a> (void) const </td></tr>
<tr class="memdesc:aea485adaba5702435dc089d2648e1d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are input data-types locked. <br /></td></tr>
<tr class="separator:aea485adaba5702435dc089d2648e1d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1f88b093e5171128ab22918523fe24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd1f88b093e5171128ab22918523fe24"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afd1f88b093e5171128ab22918523fe24">isOutputLocked</a> (void) const </td></tr>
<tr class="memdesc:afd1f88b093e5171128ab22918523fe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the output data-type locked. <br /></td></tr>
<tr class="separator:afd1f88b093e5171128ab22918523fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bb700410ebb96b7c61f78727f00297"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28bb700410ebb96b7c61f78727f00297"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a28bb700410ebb96b7c61f78727f00297">isModelLocked</a> (void) const </td></tr>
<tr class="memdesc:a28bb700410ebb96b7c61f78727f00297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the prototype model for <b>this</b> locked. <br /></td></tr>
<tr class="separator:a28bb700410ebb96b7c61f78727f00297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456b9cdb2e397d44ff6df1a4093d6e87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a456b9cdb2e397d44ff6df1a4093d6e87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a456b9cdb2e397d44ff6df1a4093d6e87">isUnknownModel</a> (void) const </td></tr>
<tr class="memdesc:a456b9cdb2e397d44ff6df1a4093d6e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is prototype model officially "unknown". <br /></td></tr>
<tr class="separator:a456b9cdb2e397d44ff6df1a4093d6e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651695b4cf7caa3a6af56b2a6126592"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8651695b4cf7caa3a6af56b2a6126592"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8651695b4cf7caa3a6af56b2a6126592">hasCustomStorage</a> (void) const </td></tr>
<tr class="memdesc:a8651695b4cf7caa3a6af56b2a6126592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a "custom" function prototype. <br /></td></tr>
<tr class="separator:a8651695b4cf7caa3a6af56b2a6126592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe216709633a3b075111d6f1b7148f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">setInputLock</a> (bool val)</td></tr>
<tr class="memdesc:a4afe216709633a3b075111d6f1b7148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on input parameters.  <a href="#a4afe216709633a3b075111d6f1b7148f">More...</a><br /></td></tr>
<tr class="separator:a4afe216709633a3b075111d6f1b7148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7593a0880a632bce714a376244ef4f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a7593a0880a632bce714a376244ef4f9a">setOutputLock</a> (bool val)</td></tr>
<tr class="memdesc:a7593a0880a632bce714a376244ef4f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on the return value.  <a href="#a7593a0880a632bce714a376244ef4f9a">More...</a><br /></td></tr>
<tr class="separator:a7593a0880a632bce714a376244ef4f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc303c449c418dd875319c6f6cd9436f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acc303c449c418dd875319c6f6cd9436f">setModelLock</a> (bool val)</td></tr>
<tr class="memdesc:acc303c449c418dd875319c6f6cd9436f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the lock on the prototype model for <b>this</b>.  <a href="#acc303c449c418dd875319c6f6cd9436f">More...</a><br /></td></tr>
<tr class="separator:acc303c449c418dd875319c6f6cd9436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ef8c7a2b09476fcfbdf21cd8a01fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ef8c7a2b09476fcfbdf21cd8a01fbf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a93ef8c7a2b09476fcfbdf21cd8a01fbf">isInline</a> (void) const </td></tr>
<tr class="memdesc:a93ef8c7a2b09476fcfbdf21cd8a01fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function get <em>in-lined</em> during decompilation. <br /></td></tr>
<tr class="separator:a93ef8c7a2b09476fcfbdf21cd8a01fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843bc3ca11536028c5cb00ce5479182d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a843bc3ca11536028c5cb00ce5479182d">setInline</a> (bool val)</td></tr>
<tr class="memdesc:a843bc3ca11536028c5cb00ce5479182d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>in-line</em> setting for functions with <b>this</b> prototype.  <a href="#a843bc3ca11536028c5cb00ce5479182d">More...</a><br /></td></tr>
<tr class="separator:a843bc3ca11536028c5cb00ce5479182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a76cc76c0db3fbb3a195497b0e5d6b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad9a76cc76c0db3fbb3a195497b0e5d6b">getInjectId</a> (void) const </td></tr>
<tr class="memdesc:ad9a76cc76c0db3fbb3a195497b0e5d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the injection id associated with <b>this</b>.  <a href="#ad9a76cc76c0db3fbb3a195497b0e5d6b">More...</a><br /></td></tr>
<tr class="separator:ad9a76cc76c0db3fbb3a195497b0e5d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b68b5cd7ac131ac02b0761ae5e9ff2"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a30b68b5cd7ac131ac02b0761ae5e9ff2">getReturnBytesConsumed</a> (void) const </td></tr>
<tr class="memdesc:a30b68b5cd7ac131ac02b0761ae5e9ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an estimate of the number of bytes consumed by callers of <b>this</b> prototype.  <a href="#a30b68b5cd7ac131ac02b0761ae5e9ff2">More...</a><br /></td></tr>
<tr class="separator:a30b68b5cd7ac131ac02b0761ae5e9ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd05102695a39cdad0170eeb92884b3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abd05102695a39cdad0170eeb92884b3a">setReturnBytesConsumed</a> (int4 val)</td></tr>
<tr class="memdesc:abd05102695a39cdad0170eeb92884b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of bytes consumed by callers of <b>this</b>.  <a href="#abd05102695a39cdad0170eeb92884b3a">More...</a><br /></td></tr>
<tr class="separator:abd05102695a39cdad0170eeb92884b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f6374aa63909ba29c707218977a6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9f6374aa63909ba29c707218977a6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8b9f6374aa63909ba29c707218977a6a">isNoReturn</a> (void) const </td></tr>
<tr class="memdesc:a8b9f6374aa63909ba29c707218977a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a function with <b>this</b> prototype never return. <br /></td></tr>
<tr class="separator:a8b9f6374aa63909ba29c707218977a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf0bda9b424dfd5c6a28d3a45fb100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aacaf0bda9b424dfd5c6a28d3a45fb100">setNoReturn</a> (bool val)</td></tr>
<tr class="memdesc:aacaf0bda9b424dfd5c6a28d3a45fb100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>no-return</em> setting for functions with <b>this</b> prototype.  <a href="#aacaf0bda9b424dfd5c6a28d3a45fb100">More...</a><br /></td></tr>
<tr class="separator:aacaf0bda9b424dfd5c6a28d3a45fb100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542e5292caab46acd79baeefbbf1dd9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a542e5292caab46acd79baeefbbf1dd9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a542e5292caab46acd79baeefbbf1dd9e">hasThisPointer</a> (void) const </td></tr>
<tr class="memdesc:a542e5292caab46acd79baeefbbf1dd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a prototype for a class method, taking a <em>this</em> pointer. <br /></td></tr>
<tr class="separator:a542e5292caab46acd79baeefbbf1dd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa63d717686011c29949077e426d50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2aa63d717686011c29949077e426d50"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad2aa63d717686011c29949077e426d50">isConstructor</a> (void) const </td></tr>
<tr class="memdesc:ad2aa63d717686011c29949077e426d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class constructor method. <br /></td></tr>
<tr class="separator:ad2aa63d717686011c29949077e426d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2f80e5cf4043147ccd83a863ee83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1ff2f80e5cf4043147ccd83a863ee83f">setConstructor</a> (bool val)</td></tr>
<tr class="memdesc:a1ff2f80e5cf4043147ccd83a863ee83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>constructor</em> method.  <a href="#a1ff2f80e5cf4043147ccd83a863ee83f">More...</a><br /></td></tr>
<tr class="separator:a1ff2f80e5cf4043147ccd83a863ee83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd47f48645a6c80e1a66443b360958e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdd47f48645a6c80e1a66443b360958e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abdd47f48645a6c80e1a66443b360958e">isDestructor</a> (void) const </td></tr>
<tr class="memdesc:abdd47f48645a6c80e1a66443b360958e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class destructor method. <br /></td></tr>
<tr class="separator:abdd47f48645a6c80e1a66443b360958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa191f5c52ce98ba14ef14f63a763a7da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa191f5c52ce98ba14ef14f63a763a7da">setDestructor</a> (bool val)</td></tr>
<tr class="memdesc:aa191f5c52ce98ba14ef14f63a763a7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>destructor</em> method.  <a href="#aa191f5c52ce98ba14ef14f63a763a7da">More...</a><br /></td></tr>
<tr class="separator:aa191f5c52ce98ba14ef14f63a763a7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9da3b32d9b55d944ee659087fbd2ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9da3b32d9b55d944ee659087fbd2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9c9da3b32d9b55d944ee659087fbd2ed">hasInputErrors</a> (void) const </td></tr>
<tr class="memdesc:a9c9da3b32d9b55d944ee659087fbd2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect input parameter descriptions. <br /></td></tr>
<tr class="separator:a9c9da3b32d9b55d944ee659087fbd2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed327cece6d30cbb03de61c7472b4d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed327cece6d30cbb03de61c7472b4d63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aed327cece6d30cbb03de61c7472b4d63">hasOutputErrors</a> (void) const </td></tr>
<tr class="memdesc:aed327cece6d30cbb03de61c7472b4d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect return value description. <br /></td></tr>
<tr class="separator:aed327cece6d30cbb03de61c7472b4d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f36aaa3e2d1d7cdc90d101065abbc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">setInputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ad5f36aaa3e2d1d7cdc90d101065abbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the input error setting for <b>this</b> prototype.  <a href="#ad5f36aaa3e2d1d7cdc90d101065abbc0">More...</a><br /></td></tr>
<tr class="separator:ad5f36aaa3e2d1d7cdc90d101065abbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eacd70fbc6e4cd5d694d2ae5b1ed64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">setOutputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ac8eacd70fbc6e4cd5d694d2ae5b1ed64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the output error setting for <b>this</b> prototype.  <a href="#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">More...</a><br /></td></tr>
<tr class="separator:ac8eacd70fbc6e4cd5d694d2ae5b1ed64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ce1430cfc4d82aea46aa0fdc4ca7a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92ce1430cfc4d82aea46aa0fdc4ca7a7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a92ce1430cfc4d82aea46aa0fdc4ca7a7">getExtraPop</a> (void) const </td></tr>
<tr class="memdesc:a92ce1430cfc4d82aea46aa0fdc4ca7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the general <em>extrapop</em> setting for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:a92ce1430cfc4d82aea46aa0fdc4ca7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32fa24642ff5423ec167e6f8bca065a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af32fa24642ff5423ec167e6f8bca065a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af32fa24642ff5423ec167e6f8bca065a">setExtraPop</a> (int4 ep)</td></tr>
<tr class="memdesc:af32fa24642ff5423ec167e6f8bca065a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the general <em>extrapop</em> for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:af32fa24642ff5423ec167e6f8bca065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf11c169a30501c86c760933c22b276"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaf11c169a30501c86c760933c22b276"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aaaf11c169a30501c86c760933c22b276">getInjectUponEntry</a> (void) const </td></tr>
<tr class="memdesc:aaaf11c169a30501c86c760933c22b276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any <em>upon-entry</em> injection id (or -1) <br /></td></tr>
<tr class="separator:aaaf11c169a30501c86c760933c22b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3928162e5f03fe83a86be8d499fb3705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3928162e5f03fe83a86be8d499fb3705"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3928162e5f03fe83a86be8d499fb3705">getInjectUponReturn</a> (void) const </td></tr>
<tr class="memdesc:a3928162e5f03fe83a86be8d499fb3705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any <em>upon-return</em> injection id (or -1) <br /></td></tr>
<tr class="separator:a3928162e5f03fe83a86be8d499fb3705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22889d3a526dce245368b8de9c889529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a22889d3a526dce245368b8de9c889529">resolveExtraPop</a> (void)</td></tr>
<tr class="memdesc:a22889d3a526dce245368b8de9c889529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <b>this</b> prototype is locked, calculate the <em>extrapop</em>.  <a href="#a22889d3a526dce245368b8de9c889529">More...</a><br /></td></tr>
<tr class="separator:a22889d3a526dce245368b8de9c889529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91eb49088323b42bdb38b83586eea6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91eb49088323b42bdb38b83586eea6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae91eb49088323b42bdb38b83586eea6f">clearUnlockedInput</a> (void)</td></tr>
<tr class="memdesc:ae91eb49088323b42bdb38b83586eea6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input parameters that have not been locked. <br /></td></tr>
<tr class="separator:ae91eb49088323b42bdb38b83586eea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7428f70c6c7e040b4d090f3efeee08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c7428f70c6c7e040b4d090f3efeee08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3c7428f70c6c7e040b4d090f3efeee08">clearUnlockedOutput</a> (void)</td></tr>
<tr class="memdesc:a3c7428f70c6c7e040b4d090f3efeee08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the return value if it has not been locked. <br /></td></tr>
<tr class="separator:a3c7428f70c6c7e040b4d090f3efeee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8059930e66577c8906ade2f36f65cce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8059930e66577c8906ade2f36f65cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af8059930e66577c8906ade2f36f65cce">clearInput</a> (void)</td></tr>
<tr class="memdesc:af8059930e66577c8906ade2f36f65cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all input parameters regardless of lock. <br /></td></tr>
<tr class="separator:af8059930e66577c8906ade2f36f65cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb585835251e43a5c9f644519e69dc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bb585835251e43a5c9f644519e69dc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0bb585835251e43a5c9f644519e69dc0">cancelInjectId</a> (void)</td></tr>
<tr class="memdesc:a0bb585835251e43a5c9f644519e69dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn-off any in-lining for this function. <br /></td></tr>
<tr class="separator:a0bb585835251e43a5c9f644519e69dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b71963b55dd19755eeaccd016c4bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afd3b71963b55dd19755eeaccd016c4bf">resolveModel</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active)</td></tr>
<tr class="memdesc:afd3b71963b55dd19755eeaccd016c4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>this</b> has a <em>merged</em> model, pick the most likely model (from the merged set)  <a href="#afd3b71963b55dd19755eeaccd016c4bf">More...</a><br /></td></tr>
<tr class="separator:afd3b71963b55dd19755eeaccd016c4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaba4c71323374c0c056922ff1bb7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aacaba4c71323374c0c056922ff1bb7b2">deriveInputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const </td></tr>
<tr class="memdesc:aacaba4c71323374c0c056922ff1bb7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of input <em>trials</em>, derive the most likely inputs for <b>this</b> prototype.  <a href="#aacaba4c71323374c0c056922ff1bb7b2">More...</a><br /></td></tr>
<tr class="separator:aacaba4c71323374c0c056922ff1bb7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629ceb32fa6bd296038fa56347570789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a629ceb32fa6bd296038fa56347570789">deriveOutputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const </td></tr>
<tr class="memdesc:a629ceb32fa6bd296038fa56347570789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of output <em>trials</em>, derive the most likely return value for <b>this</b> prototype.  <a href="#a629ceb32fa6bd296038fa56347570789">More...</a><br /></td></tr>
<tr class="separator:a629ceb32fa6bd296038fa56347570789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2b22892816eb75517aa5f84a3aada1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afc2b22892816eb75517aa5f84a3aada1">checkInputJoin</a> (const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz) const </td></tr>
<tr class="memdesc:afc2b22892816eb75517aa5f84a3aada1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given two input storage locations can represent a single logical parameter.  <a href="#afc2b22892816eb75517aa5f84a3aada1">More...</a><br /></td></tr>
<tr class="separator:afc2b22892816eb75517aa5f84a3aada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee79f9d371fb681fb91bf6761138dade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aee79f9d371fb681fb91bf6761138dade">checkInputSplit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 splitpoint) const </td></tr>
<tr class="memdesc:aee79f9d371fb681fb91bf6761138dade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if it makes sense to split a single storage location into two input parameters.  <a href="#aee79f9d371fb681fb91bf6761138dade">More...</a><br /></td></tr>
<tr class="separator:aee79f9d371fb681fb91bf6761138dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89afc199ba2c4c8261dac381c5e426b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae89afc199ba2c4c8261dac381c5e426b">updateInputTypes</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput)</td></tr>
<tr class="memdesc:ae89afc199ba2c4c8261dac381c5e426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials.  <a href="#ae89afc199ba2c4c8261dac381c5e426b">More...</a><br /></td></tr>
<tr class="separator:ae89afc199ba2c4c8261dac381c5e426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33463f351b0ebc8c8f6065eff896dbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a33463f351b0ebc8c8f6065eff896dbc3">updateInputNoTypes</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput)</td></tr>
<tr class="memdesc:a33463f351b0ebc8c8f6065eff896dbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but do not store the data-type.  <a href="#a33463f351b0ebc8c8f6065eff896dbc3">More...</a><br /></td></tr>
<tr class="separator:a33463f351b0ebc8c8f6065eff896dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cbde2e23cdcf41ddb870721e02be6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a56cbde2e23cdcf41ddb870721e02be6b">updateOutputTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist)</td></tr>
<tr class="memdesc:a56cbde2e23cdcf41ddb870721e02be6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials.  <a href="#a56cbde2e23cdcf41ddb870721e02be6b">More...</a><br /></td></tr>
<tr class="separator:a56cbde2e23cdcf41ddb870721e02be6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e34d08f3e4e44ba5aa25b87c84bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a882e34d08f3e4e44ba5aa25b87c84bfe">updateOutputNoTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;triallist, <a class="el" href="classTypeFactory.html">TypeFactory</a> *factory)</td></tr>
<tr class="memdesc:a882e34d08f3e4e44ba5aa25b87c84bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but don't store the data-type.  <a href="#a882e34d08f3e4e44ba5aa25b87c84bfe">More...</a><br /></td></tr>
<tr class="separator:a882e34d08f3e4e44ba5aa25b87c84bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad6aba5f6731281a4c16fdfac76de2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9ad6aba5f6731281a4c16fdfac76de2c">updateAllTypes</a> (const vector&lt; string &gt; &amp;namelist, const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;typelist, bool dtdtdt)</td></tr>
<tr class="memdesc:a9ad6aba5f6731281a4c16fdfac76de2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> entire function prototype based on a list of names and data-types.  <a href="#a9ad6aba5f6731281a4c16fdfac76de2c">More...</a><br /></td></tr>
<tr class="separator:a9ad6aba5f6731281a4c16fdfac76de2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2e2a05a468048ecefb2b18b81f37a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2e2a05a468048ecefb2b18b81f37a6"></a>
<a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6c2e2a05a468048ecefb2b18b81f37a6">getParam</a> (int4 i) const </td></tr>
<tr class="memdesc:a6c2e2a05a468048ecefb2b18b81f37a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th input parameter. <br /></td></tr>
<tr class="separator:a6c2e2a05a468048ecefb2b18b81f37a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9a8f192846b36ba99ed0464bb10862"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc9a8f192846b36ba99ed0464bb10862"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abc9a8f192846b36ba99ed0464bb10862">removeParam</a> (int4 i)</td></tr>
<tr class="memdesc:abc9a8f192846b36ba99ed0464bb10862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the i-th input parameter. <br /></td></tr>
<tr class="separator:abc9a8f192846b36ba99ed0464bb10862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a078e76c55eacf3f979ba0fc61d2e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a078e76c55eacf3f979ba0fc61d2e7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae6a078e76c55eacf3f979ba0fc61d2e7">numParams</a> (void) const </td></tr>
<tr class="memdesc:ae6a078e76c55eacf3f979ba0fc61d2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of input parameters. <br /></td></tr>
<tr class="separator:ae6a078e76c55eacf3f979ba0fc61d2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c788810868e06307d9c324c824e1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a007c788810868e06307d9c324c824e1d"></a>
<a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a007c788810868e06307d9c324c824e1d">getOutput</a> (void) const </td></tr>
<tr class="memdesc:a007c788810868e06307d9c324c824e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return value. <br /></td></tr>
<tr class="separator:a007c788810868e06307d9c324c824e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fdfce821c12a33707447c88ca6e4bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99fdfce821c12a33707447c88ca6e4bf"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a99fdfce821c12a33707447c88ca6e4bf">getOutputType</a> (void) const </td></tr>
<tr class="memdesc:a99fdfce821c12a33707447c88ca6e4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return value data-type. <br /></td></tr>
<tr class="separator:a99fdfce821c12a33707447c88ca6e4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae30180888dcceaaa650b6f209ccb77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae30180888dcceaaa650b6f209ccb77"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aaae30180888dcceaaa650b6f209ccb77">getLocalRange</a> (void) const </td></tr>
<tr class="memdesc:aaae30180888dcceaaa650b6f209ccb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of potential local stack variables. <br /></td></tr>
<tr class="separator:aaae30180888dcceaaa650b6f209ccb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4afb65306836b7e095666c6c08fc6d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4afb65306836b7e095666c6c08fc6d8"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae4afb65306836b7e095666c6c08fc6d8">getParamRange</a> (void) const </td></tr>
<tr class="memdesc:ae4afb65306836b7e095666c6c08fc6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of potential stack parameters. <br /></td></tr>
<tr class="separator:ae4afb65306836b7e095666c6c08fc6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d8b4daf3c381c86b3172987bca1360"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d8b4daf3c381c86b3172987bca1360"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a08d8b4daf3c381c86b3172987bca1360">isStackGrowsNegative</a> (void) const </td></tr>
<tr class="memdesc:a08d8b4daf3c381c86b3172987bca1360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if the stack grows toward smaller addresses. <br /></td></tr>
<tr class="separator:a08d8b4daf3c381c86b3172987bca1360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884776a324e2f548b8c9509b844aacb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884776a324e2f548b8c9509b844aacb3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a884776a324e2f548b8c9509b844aacb3">isDotdotdot</a> (void) const </td></tr>
<tr class="memdesc:a884776a324e2f548b8c9509b844aacb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> takes a variable number of arguments. <br /></td></tr>
<tr class="separator:a884776a324e2f548b8c9509b844aacb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d237b521223b740d5d052b68966b556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d237b521223b740d5d052b68966b556"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6d237b521223b740d5d052b68966b556">setDotdotdot</a> (bool val)</td></tr>
<tr class="memdesc:a6d237b521223b740d5d052b68966b556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> takes variable arguments. <br /></td></tr>
<tr class="separator:a6d237b521223b740d5d052b68966b556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e7092572b8d514b6d74c953944080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace8e7092572b8d514b6d74c953944080"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace8e7092572b8d514b6d74c953944080">isOverride</a> (void) const </td></tr>
<tr class="memdesc:ace8e7092572b8d514b6d74c953944080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> is a call site override. <br /></td></tr>
<tr class="separator:ace8e7092572b8d514b6d74c953944080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827a8f9335cbb8587a566d8e1765d5a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a827a8f9335cbb8587a566d8e1765d5a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a827a8f9335cbb8587a566d8e1765d5a2">setOverride</a> (bool val)</td></tr>
<tr class="memdesc:a827a8f9335cbb8587a566d8e1765d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> is a call site override. <br /></td></tr>
<tr class="separator:a827a8f9335cbb8587a566d8e1765d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116dd89589cc36e9c822426838658871"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a116dd89589cc36e9c822426838658871">hasEffect</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:a116dd89589cc36e9c822426838658871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effect <b>this</b> has an a given storage location.  <a href="#a116dd89589cc36e9c822426838658871">More...</a><br /></td></tr>
<tr class="separator:a116dd89589cc36e9c822426838658871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70399bdfec836ca56808f7e01a80a46a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70399bdfec836ca56808f7e01a80a46a"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a70399bdfec836ca56808f7e01a80a46a">effectBegin</a> (void) const </td></tr>
<tr class="memdesc:a70399bdfec836ca56808f7e01a80a46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to front of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:a70399bdfec836ca56808f7e01a80a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade59fd4d6ada7abffefa727e918622c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade59fd4d6ada7abffefa727e918622c4"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ade59fd4d6ada7abffefa727e918622c4">effectEnd</a> (void) const </td></tr>
<tr class="memdesc:ade59fd4d6ada7abffefa727e918622c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to end of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:ade59fd4d6ada7abffefa727e918622c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ba8eb1fe9b3a22a6db69492caa7ab6"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a31ba8eb1fe9b3a22a6db69492caa7ab6">numLikelyTrash</a> (void) const </td></tr>
<tr class="memdesc:a31ba8eb1fe9b3a22a6db69492caa7ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <em>likely-trash</em> locations.  <a href="#a31ba8eb1fe9b3a22a6db69492caa7ab6">More...</a><br /></td></tr>
<tr class="separator:a31ba8eb1fe9b3a22a6db69492caa7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f5fae79b01744c1f192dc321e45208"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a44f5fae79b01744c1f192dc321e45208">getLikelyTrash</a> (int4 i) const </td></tr>
<tr class="memdesc:a44f5fae79b01744c1f192dc321e45208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th <em>likely-trash</em> location.  <a href="#a44f5fae79b01744c1f192dc321e45208">More...</a><br /></td></tr>
<tr class="separator:a44f5fae79b01744c1f192dc321e45208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7f34957c913ca07bae0c9547c7ecf9"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aea7f34957c913ca07bae0c9547c7ecf9">characterizeAsInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:aea7f34957c913ca07bae0c9547c7ecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be, or could hold, an input parameter.  <a href="#aea7f34957c913ca07bae0c9547c7ecf9">More...</a><br /></td></tr>
<tr class="separator:aea7f34957c913ca07bae0c9547c7ecf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa391f4e68cb3e704ed02f09f492359b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa391f4e68cb3e704ed02f09f492359b7">possibleInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:aa391f4e68cb3e704ed02f09f492359b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be an input parameter.  <a href="#aa391f4e68cb3e704ed02f09f492359b7">More...</a><br /></td></tr>
<tr class="separator:aa391f4e68cb3e704ed02f09f492359b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d78264270ac627f7fb50bf582510861"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0d78264270ac627f7fb50bf582510861">possibleOutputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const </td></tr>
<tr class="memdesc:a0d78264270ac627f7fb50bf582510861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be a return value.  <a href="#a0d78264270ac627f7fb50bf582510861">More...</a><br /></td></tr>
<tr class="separator:a0d78264270ac627f7fb50bf582510861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e48e3d5705fca6d20e3cb6091ff600"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af8e48e3d5705fca6d20e3cb6091ff600">getMaxInputDelay</a> (void) const </td></tr>
<tr class="memdesc:af8e48e3d5705fca6d20e3cb6091ff600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible input parameters.  <a href="#af8e48e3d5705fca6d20e3cb6091ff600">More...</a><br /></td></tr>
<tr class="separator:af8e48e3d5705fca6d20e3cb6091ff600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293543ad3d0de9d6f13489acb0f4cf5b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a293543ad3d0de9d6f13489acb0f4cf5b">getMaxOutputDelay</a> (void) const </td></tr>
<tr class="memdesc:a293543ad3d0de9d6f13489acb0f4cf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible return values.  <a href="#a293543ad3d0de9d6f13489acb0f4cf5b">More...</a><br /></td></tr>
<tr class="separator:a293543ad3d0de9d6f13489acb0f4cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd0d3d5c6568b3102ac220afde1649d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3cd0d3d5c6568b3102ac220afde1649d">unjustifiedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:a3cd0d3d5c6568b3102ac220afde1649d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given storage location looks like an <em>unjustified</em> input parameter.  <a href="#a3cd0d3d5c6568b3102ac220afde1649d">More...</a><br /></td></tr>
<tr class="separator:a3cd0d3d5c6568b3102ac220afde1649d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b575b6e4e078a57f5050cf8669cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afb3b575b6e4e078a57f5050cf8669cd5">assumedInputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:afb3b575b6e4e078a57f5050cf8669cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing input parameter for the given storage.  <a href="#afb3b575b6e4e078a57f5050cf8669cd5">More...</a><br /></td></tr>
<tr class="separator:afb3b575b6e4e078a57f5050cf8669cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125e6b494f6c1610b5cfde5cbeaf583b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a125e6b494f6c1610b5cfde5cbeaf583b">assumedOutputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:a125e6b494f6c1610b5cfde5cbeaf583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing return value location for the given storage.  <a href="#a125e6b494f6c1610b5cfde5cbeaf583b">More...</a><br /></td></tr>
<tr class="separator:a125e6b494f6c1610b5cfde5cbeaf583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0977d7bbeb3feb291f9bba86e127e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1b0977d7bbeb3feb291f9bba86e127e3">getBiggestContainedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const </td></tr>
<tr class="memdesc:a1b0977d7bbeb3feb291f9bba86e127e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the biggest potential input parameter contained within the given range.  <a href="#a1b0977d7bbeb3feb291f9bba86e127e3">More...</a><br /></td></tr>
<tr class="separator:a1b0977d7bbeb3feb291f9bba86e127e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5002ce3745f1bfcc63de287def37080"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af5002ce3745f1bfcc63de287def37080">isCompatible</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2) const </td></tr>
<tr class="memdesc:af5002ce3745f1bfcc63de287def37080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if <b>this</b> can be safely restricted to match another prototype.  <a href="#af5002ce3745f1bfcc63de287def37080">More...</a><br /></td></tr>
<tr class="separator:af5002ce3745f1bfcc63de287def37080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee77105cc94d27f7f23399f6b8d7485d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee77105cc94d27f7f23399f6b8d7485d"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aee77105cc94d27f7f23399f6b8d7485d">getSpacebase</a> (void) const </td></tr>
<tr class="memdesc:aee77105cc94d27f7f23399f6b8d7485d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>stack</em> address space. <br /></td></tr>
<tr class="separator:aee77105cc94d27f7f23399f6b8d7485d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa091ef811ff6637ada75d39238f1db89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa091ef811ff6637ada75d39238f1db89">printRaw</a> (const string &amp;funcname, ostream &amp;s) const </td></tr>
<tr class="memdesc:aa091ef811ff6637ada75d39238f1db89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <b>this</b> prototype as a single line of text.  <a href="#aa091ef811ff6637ada75d39238f1db89">More...</a><br /></td></tr>
<tr class="separator:aa091ef811ff6637ada75d39238f1db89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af419fd1cdb7f73c724795c03a6e4463f"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af419fd1cdb7f73c724795c03a6e4463f">getComparableFlags</a> (void) const </td></tr>
<tr class="memdesc:af419fd1cdb7f73c724795c03a6e4463f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comparable properties of <b>this</b> prototype.  <a href="#af419fd1cdb7f73c724795c03a6e4463f">More...</a><br /></td></tr>
<tr class="separator:af419fd1cdb7f73c724795c03a6e4463f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d423d90f94aaed9c6f943a9e3b0e7b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9d423d90f94aaed9c6f943a9e3b0e7b8">saveXml</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a9d423d90f94aaed9c6f943a9e3b0e7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <b>this</b> to an XML stream as a &lt;prototype&gt; tag.  <a href="#a9d423d90f94aaed9c6f943a9e3b0e7b8">More...</a><br /></td></tr>
<tr class="separator:a9d423d90f94aaed9c6f943a9e3b0e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4f9da74ee904e6abfa195bd843521e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el, <a class="el" href="classArchitecture.html">Architecture</a> *glb)</td></tr>
<tr class="memdesc:a4c4f9da74ee904e6abfa195bd843521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> from an XML stream.  <a href="#a4c4f9da74ee904e6abfa195bd843521e">More...</a><br /></td></tr>
<tr class="separator:a4c4f9da74ee904e6abfa195bd843521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a75f9569f65cd6472f80d3e85d8453ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">paramShift</a> (int4 paramshift)</td></tr>
<tr class="memdesc:a75f9569f65cd6472f80d3e85d8453ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add parameters to the front of the input parameter list.  <a href="#a75f9569f65cd6472f80d3e85d8453ced">More...</a><br /></td></tr>
<tr class="separator:a75f9569f65cd6472f80d3e85d8453ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cb7670073defa354745e16bc3f998b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa0cb7670073defa354745e16bc3f998b">isParamshiftApplied</a> (void) const </td></tr>
<tr class="separator:aa0cb7670073defa354745e16bc3f998b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a494d8691b68a76a56495907ab9f6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1a494d8691b68a76a56495907ab9f6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ab1a494d8691b68a76a56495907ab9f6d">setParamshiftApplied</a> (bool val)</td></tr>
<tr class="memdesc:ab1a494d8691b68a76a56495907ab9f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether a parameter shift has been applied. <br /></td></tr>
<tr class="separator:ab1a494d8691b68a76a56495907ab9f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:adea3eb774baf54baaae345791ac29e23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a24bde0261b8c75ddb3705ef751948348">dotdotdot</a> = 1, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23aa432bfcda8da1eff32e91fdd9de0aeab">voidinputlock</a> = 2, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a519afb62d431805053d05f3b795a5e1c">modellock</a> = 4, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a6557655f164b9f5b0f4336ee6bc65101">is_inline</a> = 8, 
<br />
&#160;&#160;<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a4607139ad6c0132fc2fcafb6d7aac02d">no_return</a> = 16, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a9aa3c245ae4b12176572d3d0e779a919">paramshift_applied</a> = 32, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23ac15073f4083124fb02f87f8012d3bdc7">error_inputparam</a> = 64, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a842ad75d09e1f68d744589e3f4019ad2">error_outputparam</a> = 128, 
<br />
&#160;&#160;<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a227f55ba19c86180846edbcf0fa64ebb">custom_storage</a> = 256, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a788e19bf65941ac5596bdf3a28c9517b">unknown_model</a> = 512, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a9d466ed940e89c0db59fb82539ea5923">is_constructor</a> = 0x400, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a48e230e76bfa66b62ea61209c32a1e23">is_destructor</a> = 0x800, 
<br />
&#160;&#160;<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a898b708b9366c3bce94fad332a338f3f">has_thisptr</a> = 0x1000, 
<a class="el" href="classFuncProto.html#adea3eb774baf54baaae345791ac29e23a2e59d90f37faecde0015949c2fa05ae4">is_override</a> = 0x2000
<br />
 }</td></tr>
<tr class="separator:adea3eb774baf54baaae345791ac29e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a987b9ee85738005c25a6916b1219be97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a987b9ee85738005c25a6916b1219be97">updateThisPointer</a> (void)</td></tr>
<tr class="memdesc:a987b9ee85738005c25a6916b1219be97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure any "this" parameter is properly marked.  <a href="#a987b9ee85738005c25a6916b1219be97">More...</a><br /></td></tr>
<tr class="separator:a987b9ee85738005c25a6916b1219be97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad64bc80473c320f8c03fea7d2572129f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad64bc80473c320f8c03fea7d2572129f"></a>
<a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad64bc80473c320f8c03fea7d2572129f">model</a></td></tr>
<tr class="memdesc:ad64bc80473c320f8c03fea7d2572129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model of for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:ad64bc80473c320f8c03fea7d2572129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466b9de4309adbc101f22befc21fc22e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a466b9de4309adbc101f22befc21fc22e"></a>
<a class="el" href="classProtoStore.html">ProtoStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a466b9de4309adbc101f22befc21fc22e">store</a></td></tr>
<tr class="memdesc:a466b9de4309adbc101f22befc21fc22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage interface for parameters. <br /></td></tr>
<tr class="separator:a466b9de4309adbc101f22befc21fc22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02f1ff6836640a55bba8055ed3b9349"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad02f1ff6836640a55bba8055ed3b9349"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad02f1ff6836640a55bba8055ed3b9349">extrapop</a></td></tr>
<tr class="memdesc:ad02f1ff6836640a55bba8055ed3b9349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra bytes popped from stack. <br /></td></tr>
<tr class="separator:ad02f1ff6836640a55bba8055ed3b9349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330fb9fba4bf6c83fc054886ee0b3d52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a330fb9fba4bf6c83fc054886ee0b3d52"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a330fb9fba4bf6c83fc054886ee0b3d52">flags</a></td></tr>
<tr class="memdesc:a330fb9fba4bf6c83fc054886ee0b3d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean properties of the function prototype. <br /></td></tr>
<tr class="separator:a330fb9fba4bf6c83fc054886ee0b3d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663b1c1abf2f11d7681ae84e758fce35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663b1c1abf2f11d7681ae84e758fce35"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a663b1c1abf2f11d7681ae84e758fce35">effectlist</a></td></tr>
<tr class="memdesc:a663b1c1abf2f11d7681ae84e758fce35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Side-effects associated with non-parameter storage locations. <br /></td></tr>
<tr class="separator:a663b1c1abf2f11d7681ae84e758fce35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac301c5cfafc4757f2b2ae5e149e9bc4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac301c5cfafc4757f2b2ae5e149e9bc4c"></a>
vector&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac301c5cfafc4757f2b2ae5e149e9bc4c">likelytrash</a></td></tr>
<tr class="memdesc:ac301c5cfafc4757f2b2ae5e149e9bc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locations that may contain <em>trash</em> values. <br /></td></tr>
<tr class="separator:ac301c5cfafc4757f2b2ae5e149e9bc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6fe1d0e0e45e71b366020d00914319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d6fe1d0e0e45e71b366020d00914319"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0d6fe1d0e0e45e71b366020d00914319">injectid</a></td></tr>
<tr class="memdesc:a0d6fe1d0e0e45e71b366020d00914319"><td class="mdescLeft">&#160;</td><td class="mdescRight">(If non-negative) id of p-code snippet that should replace this function <br /></td></tr>
<tr class="separator:a0d6fe1d0e0e45e71b366020d00914319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffe71f730be1c9ba92204b5d54b21ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adffe71f730be1c9ba92204b5d54b21ee"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#adffe71f730be1c9ba92204b5d54b21ee">returnBytesConsumed</a></td></tr>
<tr class="memdesc:adffe71f730be1c9ba92204b5d54b21ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes of return value that are consumed by callers (0 = all bytes) <br /></td></tr>
<tr class="separator:adffe71f730be1c9ba92204b5d54b21ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <b>function</b> <b>prototype</b>. </p>
<p>A description of the parameters and return value for a specific function. Parameter descriptions include both source code features like <em>name</em> and <em>data-type</em> but also give the storage location. Storage follows a specific parameter passing convention (<a class="el" href="classProtoModel.html" title="A prototype model: a model for passing parameters between functions. ">ProtoModel</a>), although individual parameters may be customized. The prototype describes numerous properties related to calling the specific function:</p><ul>
<li>Side-effects on non-parameter storage locations (like save registers)</li>
<li>P-code injection associated with the function (uponentry, uponreturn, callfixup)</li>
<li>Additional bytes (<b>extrapop</b>) popped from the stack by the function</li>
<li>Method flags (thiscall, is_constructor, is_destructor) </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="adea3eb774baf54baaae345791ac29e23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a24bde0261b8c75ddb3705ef751948348"></a>dotdotdot&#160;</td><td class="fielddoc">
<p>Set if <b>this</b> prototype takes variable arguments (varargs) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23aa432bfcda8da1eff32e91fdd9de0aeab"></a>voidinputlock&#160;</td><td class="fielddoc">
<p>Set if <b>this</b> prototype takes no inputs and is locked. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a519afb62d431805053d05f3b795a5e1c"></a>modellock&#160;</td><td class="fielddoc">
<p>Set if the PrototypeModel is locked for <b>this</b> prototype. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a6557655f164b9f5b0f4336ee6bc65101"></a>is_inline&#160;</td><td class="fielddoc">
<p>Should <b>this</b> be inlined (within calling function) by decompiler. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a4607139ad6c0132fc2fcafb6d7aac02d"></a>no_return&#160;</td><td class="fielddoc">
<p>Function does not return. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a9aa3c245ae4b12176572d3d0e779a919"></a>paramshift_applied&#160;</td><td class="fielddoc">
<p>paramshift parameters have been added and removed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23ac15073f4083124fb02f87f8012d3bdc7"></a>error_inputparam&#160;</td><td class="fielddoc">
<p>Set if the input parameters are not properly represented. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a842ad75d09e1f68d744589e3f4019ad2"></a>error_outputparam&#160;</td><td class="fielddoc">
<p>Set if the return value(s) are not properly represented. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a227f55ba19c86180846edbcf0fa64ebb"></a>custom_storage&#160;</td><td class="fielddoc">
<p>Parameter storage is custom (not derived from <a class="el" href="classProtoModel.html" title="A prototype model: a model for passing parameters between functions. ">ProtoModel</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a788e19bf65941ac5596bdf3a28c9517b"></a>unknown_model&#160;</td><td class="fielddoc">
<p>Set if the PrototypeModel isn't known. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a9d466ed940e89c0db59fb82539ea5923"></a>is_constructor&#160;</td><td class="fielddoc">
<p>Function is an (object-oriented) constructor. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a48e230e76bfa66b62ea61209c32a1e23"></a>is_destructor&#160;</td><td class="fielddoc">
<p>Function is an (object-oriented) destructor. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a898b708b9366c3bce94fad332a338f3f"></a>has_thisptr&#160;</td><td class="fielddoc">
<p>Function is a method with a 'this' pointer as an argument. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adea3eb774baf54baaae345791ac29e23a2e59d90f37faecde0015949c2fa05ae4"></a>is_override&#160;</td><td class="fielddoc">
<p>Set if <b>this</b> prototype is created to override a single call site. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afb3b575b6e4e078a57f5050cf8669cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> FuncProto::assumedInputExtension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of extension and containing input parameter for the given storage. </p>
<p>If the given storage is properly contained within a normal parameter and the model typically extends a small value into the full container, pass back the full container and the type of extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given storage </td></tr>
    <tr><td class="paramname">res</td><td>is the parameter storage to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extension operator (INT_ZEXT INT_SEXT) or INT_COPY if there is no extension. INT_PIECE indicates the extension is determined by the specific prototype. </dd></dl>

<p>References <a class="el" href="classProtoModel.html#a3f5e2452fba8aae845fb84bbef1505e2">ProtoModel::assumedInputExtension()</a>.</p>

<p>Referenced by <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a125e6b494f6c1610b5cfde5cbeaf583b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> FuncProto::assumedOutputExtension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of extension and containing return value location for the given storage. </p>
<p>If the given storage is properly contained within a normal return value location and the model typically extends a small value into the full container, pass back the full container and the type of extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given storage </td></tr>
    <tr><td class="paramname">res</td><td>is the parameter storage to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extension operator (INT_ZEXT INT_SEXT) or INT_COPY if there is no extension. INT_PIECE indicates the extension is determined by the specific prototype. </dd></dl>

<p>References <a class="el" href="classProtoModel.html#a997a148155b920b507923c18162f3b0d">ProtoModel::assumedOutputExtension()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aa357f1ecfa3c9bd2ab86d958bb0670b4">FuncCallSpecs::commitNewOutputs()</a>, and <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="aea7f34957c913ca07bae0c9547c7ecf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncProto::characterizeAsInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether a given storage location could be, or could hold, an input parameter. </p>
<p>If the input is locked, check if the location overlaps one of the current parameters. Otherwise, check if the location overlaps an entry in the prototype model. Return:</p><ul>
<li>0 if the location neither contains or is contained by a parameter storage location</li>
<li>1 if the location is contained by a parameter storage location</li>
<li>2 if the location contains a parameter storage location <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the characterization code </dd></dl>
</li>
</ul>

<p>References <a class="el" href="classAddress.html#a96db8627391dda4a570ee397e9cad814">Address::containedBy()</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classProtoParameter.html#a155b564b34ae0b36d39d5a1caf5d0014">ProtoParameter::isTypeLocked()</a>, and <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">Heritage::guardCalls()</a>.</p>

</div>
</div>
<a class="anchor" id="afc2b22892816eb75517aa5f84a3aada1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::checkInputJoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>hiaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>hisz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>losz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given two input storage locations can represent a single logical parameter. </p>
<p>For <b>this</b> prototype, do the two (hi/lo) locations represent consecutive input parameter locations that can be replaced by a single logical parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hiaddr</td><td>is the address of the most significant part of the value </td></tr>
    <tr><td class="paramname">hisz</td><td>is the size of the most significant part in bytes </td></tr>
    <tr><td class="paramname">loaddr</td><td>is the address of the least significant part of the value </td></tr>
    <tr><td class="paramname">losz</td><td>is the size of the least significant part in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the two pieces can be joined </dd></dl>

<p>References <a class="el" href="classProtoModel.html#a3a32d39e07a31784ba283a617a387c09">ProtoModel::checkInputJoin()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#acb251c17c1f0a352c73930383dea6c8f">FuncCallSpecs::checkInputJoin()</a>.</p>

</div>
</div>
<a class="anchor" id="aee79f9d371fb681fb91bf6761138dade"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::checkInputSplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>splitpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if it makes sense to split a single storage location into two input parameters. </p>
<p>A storage location and split point is provided, implying two new storage locations. Does <b>this</b> prototype allow these locations to be considered separate parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of provided storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the location in bytes </td></tr>
    <tr><td class="paramname">splitpoint</td><td>is the number of bytes to consider in the first (in address order) piece </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the storage location can be split </dd></dl>

<p>References <a class="el" href="classProtoModel.html#acf26dbac6ed3eb61ebc7da22a9a0e6dd">ProtoModel::checkInputSplit()</a>.</p>

<p>Referenced by <a class="el" href="classActionParamDouble.html#a8aad0e7534680ca4a79a20c196da103c">ActionParamDouble::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a9bd4f3bc764b11b57f4e71b9d19df27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy another function prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the other function prototype to copy into <b>this</b> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classProtoStore.html#aaefd44fa7803bbeb4d91059cc6480419">ProtoStore::clone()</a>, <a class="el" href="classFuncProto.html#a663b1c1abf2f11d7681ae84e758fce35">effectlist</a>, <a class="el" href="classFuncProto.html#ad02f1ff6836640a55bba8055ed3b9349">extrapop</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classFuncProto.html#a330fb9fba4bf6c83fc054886ee0b3d52">flags</a>, <a class="el" href="classFuncProto.html#a0d6fe1d0e0e45e71b366020d00914319">injectid</a>, <a class="el" href="classFuncProto.html#ac301c5cfafc4757f2b2ae5e149e9bc4c">likelytrash</a>, <a class="el" href="classFuncProto.html#ad64bc80473c320f8c03fea7d2572129f">model</a>, and <a class="el" href="classFuncProto.html#a466b9de4309adbc101f22befc21fc22e">store</a>.</p>

<p>Referenced by <a class="el" href="classActionDefaultParams.html#a32f4c196d02d9f86c66749b9bf5d2247">ActionDefaultParams::apply()</a>, <a class="el" href="classOverride.html#a32eb96e495854245e36dc5aec67b1de9">Override::applyPrototype()</a>, <a class="el" href="classFuncCallSpecs.html#ae24c733f6fbfbb4288d231869f69455d">FuncCallSpecs::clone()</a>, <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">FuncCallSpecs::forceSet()</a>, and <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">FuncCallSpecs::lateRestriction()</a>.</p>

</div>
</div>
<a class="anchor" id="aacaba4c71323374c0c056922ff1bb7b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::deriveInputMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of input <em>trials</em>, derive the most likely inputs for <b>this</b> prototype. </p>
<p>Trials are sorted and marked as <em>used</em> or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>is the collection of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> input trials </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classProtoModel.html#a92757e231783a8bde6a8421508e79cac">ProtoModel::deriveInputMap()</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>, and <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a629ceb32fa6bd296038fa56347570789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::deriveOutputMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of output <em>trials</em>, derive the most likely return value for <b>this</b> prototype. </p>
<p>One trial (at most) is marked <em>used</em> and moved to the front of the list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>is the collection of output trials </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classProtoModel.html#a7227757a8bc69c942cba3f47ddf907b7">ProtoModel::deriveOutputMap()</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveReturn.html#a69af2f49b35ac17b7e2cab3e6c0be11b">ActionActiveReturn::apply()</a>, and <a class="el" href="classActionReturnRecovery.html#aaad5058cd2347ea61be24b63f8b17d60">ActionReturnRecovery::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b0977d7bbeb3feb291f9bba86e127e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::getBiggestContainedInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass-back the biggest potential input parameter contained within the given range. </p>
<p>Pass-back the biggest input parameter contained within the given range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">res</td><td>will hold the parameter storage description being passed back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there is at least one parameter contained in the range </dd></dl>

<p>References <a class="el" href="classAddress.html#a96db8627391dda4a570ee397e9cad814">Address::containedBy()</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classProtoParameter.html#a155b564b34ae0b36d39d5a1caf5d0014">ProtoParameter::isTypeLocked()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#af7e83865af3d5e10a05513db464902b6">Heritage::guardCallOverlappingInput()</a>.</p>

</div>
</div>
<a class="anchor" id="af419fd1cdb7f73c724795c03a6e4463f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 FuncProto::getComparableFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the comparable properties of <b>this</b> prototype. </p>
<p>Get properties not including locking, error, and inlining flags. </p><dl class="section return"><dt>Returns</dt><dd>the active set of flags for <b>this</b> prototype </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a76cc76c0db3fbb3a195497b0e5d6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncProto::getInjectId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the injection id associated with <b>this</b>. </p>
<p>A non-negative id indicates a <em>call-fixup</em> is used to in-line function's with <b>this</b> prototype. </p><dl class="section return"><dt>Returns</dt><dd>the id value corresponding to the specific call-fixup or -1 if there is no call-fixup </dd></dl>

<p>Referenced by <a class="el" href="classFlowInfo.html#af91718ae694b4852c24f4af6cb0b07a0">FlowInfo::injectPcode()</a>, and <a class="el" href="classFlowInfo.html#a2af126390aed6c71823ff7b2c6eaca9e">FlowInfo::injectSubFunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a44f5fae79b01744c1f192dc321e45208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp; FuncProto::getLikelyTrash </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the i-th <em>likely-trash</em> location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the index of the storage location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the storage location which may hold a trash value </dd></dl>

<p>Referenced by <a class="el" href="classActionLikelyTrash.html#afbd2ec1783db1f08cedf5b259304f158">ActionLikelyTrash::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="af8e48e3d5705fca6d20e3cb6091ff600"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncProto::getMaxInputDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum heritage delay across all possible input parameters. </p>
<p>Depending on the address space, data-flow for a parameter may not be available until extra transform passes have completed. This method returns the number of passes that must occur before we can guarantee that all parameters have data-flow info. </p><dl class="section return"><dt>Returns</dt><dd>the maximum number of passes across all input parameters in <b>this</b> prototype </dd></dl>

<p>References <a class="el" href="classProtoModel.html#a3c7b629cb5cf8920c75ef37d4a27281a">ProtoModel::getMaxInputDelay()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a0b481b6be0cc41e4f1b35089fc5f192b">FuncCallSpecs::initActiveInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a293543ad3d0de9d6f13489acb0f4cf5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncProto::getMaxOutputDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum heritage delay across all possible return values. </p>
<p>Depending on the address space, data-flow for a parameter may not be available until extra transform passes have completed. This method returns the number of passes that must occur before we can guarantee that any return value has data-flow info. </p><dl class="section return"><dt>Returns</dt><dd>the maximum number of passes across all output parameters in <b>this</b> prototype </dd></dl>

<p>References <a class="el" href="classProtoModel.html#a33371bd1cfae0237ce58d2d413bafd83">ProtoModel::getMaxOutputDelay()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ae454fbd3566fbd43103dcabdf2681fd8">Funcdata::initActiveOutput()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b2b8d7ee2d89654f589f62ed7f02af8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::getPieces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;&#160;</td>
          <td class="paramname"><em>pieces</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the raw pieces of the prototype. </p>
<p>Copy out the raw pieces of <b>this</b> prototype as stand-alone objects, includings model, names, and data-types </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieces</td><td>will hold the raw pieces </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structPrototypePieces.html#a06df4f0bbd4f67847962c3ae35e8945d">PrototypePieces::dotdotdot</a>, <a class="el" href="classProtoParameter.html#a03d8c36596d1564b5366295ff63fc182">ProtoParameter::getName()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="structPrototypePieces.html#ab424fb1bcab5c7d008b590a24a3ad34e">PrototypePieces::innames</a>, <a class="el" href="structPrototypePieces.html#aca89ccc6fb7ef4527613909e341efe64">PrototypePieces::intypes</a>, <a class="el" href="structPrototypePieces.html#a35b3c9fbc711e8623021f4e21284de13">PrototypePieces::model</a>, and <a class="el" href="structPrototypePieces.html#ab145dec69a82cf13bef723679f6800b0">PrototypePieces::outtype</a>.</p>

</div>
</div>
<a class="anchor" id="a30b68b5cd7ac131ac02b0761ae5e9ff2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncProto::getReturnBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an estimate of the number of bytes consumed by callers of <b>this</b> prototype. </p>
<p>A value of 0 means <em>all</em> possible bytes of the storage location are consumed. </p><dl class="section return"><dt>Returns</dt><dd>the number of bytes or 0 </dd></dl>

<p>Referenced by <a class="el" href="classActionDeadCode.html#a4b150802a63d15938664d75c166c166c">ActionDeadCode::gatherConsumedReturn()</a>.</p>

</div>
</div>
<a class="anchor" id="a116dd89589cc36e9c822426838658871"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint4 FuncProto::hasEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the effect <b>this</b> has an a given storage location. </p>
<p>For a storage location that is active before and after a call to a function with <b>this</b> prototype, we determine the type of side-effect the function will have on the storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of side-effect: <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea3488da6d6b149499cbe384f7b57d0564" title="The sub-function does not change the value at all. ">EffectRecord::unaffected</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeaacd8991c4ebdeb4057e15faf1d08abc2" title="The memory is changed and is completely unrelated to its original value. ">EffectRecord::killedbycall</a>, etc. </dd></dl>

<p>References <a class="el" href="classProtoModel.html#aec744a55c36bed8f08fa923fad80df46">ProtoModel::lookupEffect()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a2f782d0e91a83336fa722483c79d42aa">FuncCallSpecs::hasEffectTranslate()</a>, and <a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">Funcdata::setInputVarnode()</a>.</p>

</div>
</div>
<a class="anchor" id="af5002ce3745f1bfcc63de287def37080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::isCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide if <b>this</b> can be safely restricted to match another prototype. </p>
<p>Do <b>this</b> and another given function prototype share enough of their model, that if we restrict <b>this</b> to the other prototype, we know we won't miss data-flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the other restricting prototype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the two prototypes are compatible enough to restrict </dd></dl>

<p>References <a class="el" href="classFuncProto.html#a663b1c1abf2f11d7681ae84e758fce35">effectlist</a>, <a class="el" href="classFuncProto.html#ad02f1ff6836640a55bba8055ed3b9349">extrapop</a>, <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classFuncProto.html#a330fb9fba4bf6c83fc054886ee0b3d52">flags</a>, <a class="el" href="classProtoStore.html#aeb240f8e1b797060196c4bb7be000197">ProtoStore::getOutput()</a>, <a class="el" href="classFuncProto.html#a0d6fe1d0e0e45e71b366020d00914319">injectid</a>, <a class="el" href="classFuncProto.html#a884776a324e2f548b8c9509b844aacb3">isDotdotdot()</a>, <a class="el" href="classFuncProto.html#afd1f88b093e5171128ab22918523fe24">isOutputLocked()</a>, <a class="el" href="classFuncProto.html#ac301c5cfafc4757f2b2ae5e149e9bc4c">likelytrash</a>, <a class="el" href="classFuncProto.html#ad64bc80473c320f8c03fea7d2572129f">model</a>, and <a class="el" href="classFuncProto.html#a466b9de4309adbc101f22befc21fc22e">store</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#ab55b52b70e4def9167d06709746635e9">FuncCallSpecs::lateRestriction()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0cb7670073defa354745e16bc3f998b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::isParamshiftApplied </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Has a parameter shift been applied </p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a01e16ebebb71bdc63fb884c8d0e3b7e3">FuncCallSpecs::paramshiftModifyStop()</a>.</p>

</div>
</div>
<a class="anchor" id="a31ba8eb1fe9b3a22a6db69492caa7ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncProto::numLikelyTrash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <em>likely-trash</em> locations. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of individual storage locations </dd></dl>

<p>Referenced by <a class="el" href="classActionLikelyTrash.html#afbd2ec1783db1f08cedf5b259304f158">ActionLikelyTrash::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a75f9569f65cd6472f80d3e85d8453ced"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::paramShift </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>paramshift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add parameters to the front of the input parameter list. </p>
<p>Prepend the indicated number of input parameters to <b>this</b>. The new parameters have a data-type of xunknown4. If they were originally locked, the existing parameters are preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramshift</td><td>is the number of parameters to add (must be &gt;0) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classTypeFactory.html#a39b53df79da81c7cae1083e40460ba47">TypeFactory::getArch()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classProtoParameter.html#a03d8c36596d1564b5366295ff63fc182">ProtoParameter::getName()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classTypeFactory.html#ab7277908ef32101f172633ec00fbecb1">TypeFactory::getTypeVoid()</a>, <a class="el" href="structParameterPieces.html#afc17dcffd5b1b61a870d56603141df2baab9b7725bf05d092537566b207e8c225">ParameterPieces::hiddenretparm</a>, <a class="el" href="classProtoStoreInternal.html#a9dfb7feca9c49b33e9857740e7ea9a9a">ProtoStoreInternal::setOutput()</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#aac7bcd5ea5ed14adbe74b4ca4c7e0814">FuncCallSpecs::paramshiftModifyStart()</a>.</p>

</div>
</div>
<a class="anchor" id="aa391f4e68cb3e704ed02f09f492359b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::possibleInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether a given storage location could be an input parameter. </p>
<p>If the input is locked, check if the location matches one of the current parameters. Otherwise, check if the location <em>could</em> be a parameter based on the prototype model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> if the location is definitely not an input parameter </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classProtoParameter.html#a155b564b34ae0b36d39d5a1caf5d0014">ProtoParameter::isTypeLocked()</a>, and <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>.</p>

<p>Referenced by <a class="el" href="classActionDirectWrite.html#a02ef8c3c9a53549db52478cd566e320f">ActionDirectWrite::apply()</a>, and <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d78264270ac627f7fb50bf582510861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::possibleOutputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether a given storage location could be a return value. </p>
<p>If the output is locked, check if the location matches the current return value. Otherwise, check if the location <em>could</em> be a return value based on the prototype model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> if the location is definitely not the return value </dd></dl>

<p>References <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>.</p>

<p>Referenced by <a class="el" href="classHeritage.html#a8eee271623cb06fb85aa3d99fda9f653">Heritage::guardCalls()</a>.</p>

</div>
</div>
<a class="anchor" id="aa091ef811ff6637ada75d39238f1db89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::printRaw </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>funcname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print <b>this</b> prototype as a single line of text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">funcname</td><td>is an identifier of the function using <b>this</b> prototype </td></tr>
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22889d3a526dce245368b8de9c889529"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::resolveExtraPop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming <b>this</b> prototype is locked, calculate the <em>extrapop</em>. </p>
<p>If <em>extrapop</em> is unknown and <b>this</b> prototype is locked, try to directly calculate what the <em>extrapop</em> should be. This is really only designed to work with 32-bit x86 binaries. </p>

<p>References <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, and <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>.</p>

</div>
</div>
<a class="anchor" id="afd3b71963b55dd19755eeaccd016c4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::resolveModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <b>this</b> has a <em>merged</em> model, pick the most likely model (from the merged set) </p>
<p>The given parameter trials are used to pick from among the merged ProtoModels and <b>this</b> prototype is changed (specialized) to the pick </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>is the set of parameter trials to evaluate with </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classProtoModelMerged.html#a32076d04bcf66da07c9abaa627748283">ProtoModelMerged::selectModel()</a>.</p>

<p>Referenced by <a class="el" href="classActionActiveParam.html#ab4bc14613f94c7114c1890d436c4d729">ActionActiveParam::apply()</a>, and <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c4f9da74ee904e6abfa195bd843521e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td>
          <td class="paramname"><em>glb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <b>this</b> from an XML stream. </p>
<p>The backing store for the parameters must already be established using either setStore() or <a class="el" href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699" title="Set internal backing storage for this. ">setInternal()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the &lt;prototype&gt; XML element </td></tr>
    <tr><td class="paramname">glb</td><td>is the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> owning the prototype </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structParameterPieces.html#a64a8ea85886ffa493a625e75cb5b01e0">ParameterPieces::addr</a>, <a class="el" href="classInjectPayload.html#ab67e84f2efa677b02cef7cbec0ced80aad5a56c387d306b588447302bfc5191bc">InjectPayload::CALLFIXUP_TYPE</a>, <a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">Architecture::defaultfp</a>, <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="structParameterPieces.html#aedb19159c26f9137c4ec68238f25933a">ParameterPieces::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classDatatype.html#a483d78811e95ccbaeff6b5b2a2f27ea4">Datatype::getMetatype()</a>, <a class="el" href="classArchitecture.html#a60eb829144de24bdd0a20a6f5a20fbb6">Architecture::getModel()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>, <a class="el" href="classPcodeInjectLibrary.html#af408528503493b69fcb4472697303676">PcodeInjectLibrary::getPayloadId()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeaacd8991c4ebdeb4057e15faf1d08abc2">EffectRecord::killedbycall</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">Architecture::pcodeinjectlib</a>, <a class="el" href="classAddress.html#a31fdc8c33088abb3040027d35e7c4026">Address::restoreXml()</a>, <a class="el" href="classTypeFactory.html#aea5f4036abb11e63ca5f79a9eacfc93c">TypeFactory::restoreXmlType()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeafa04c6c617a1044c79c7bc9b7d661be2">EffectRecord::return_address</a>, <a class="el" href="structParameterPieces.html#a628fd8428a2331db63516291840e8409">ParameterPieces::type</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa84de340fe64164ed0dcf473aad846961">TYPE_VOID</a>, <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea3488da6d6b149499cbe384f7b57d0564">EffectRecord::unaffected</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

<p>Referenced by <a class="el" href="classOverride.html#a81f34dfc11c427ea0873358bef93ada3">Override::restoreXml()</a>, and <a class="el" href="classFuncdata.html#a7419de8057421b8e9300c4a26c60ecef">Funcdata::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d423d90f94aaed9c6f943a9e3b0e7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save <b>this</b> to an XML stream as a &lt;prototype&gt; tag. </p>
<p>Save everything under the control of this prototype, which may <em>not</em> include input parameters, as these are typically controlled by the function's symbol table scope. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="xml_8hh.html#a0fa1b18d881c70abd1489da2ba2f6792">a_v()</a>, <a class="el" href="xml_8hh.html#a87634423f394bc832a51957ee6fc85c9">a_v_b()</a>, <a class="el" href="xml_8hh.html#aa12f4a381037faf4e90d1876bb44aa02">a_v_i()</a>, <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classPcodeInjectLibrary.html#a6abba15ff959df5b94384e899aee9b48">PcodeInjectLibrary::getCallFixupName()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classProtoParameter.html#a05bfe5b4fe563c1e4e93bf2648239061">ProtoParameter::getType()</a>, <a class="el" href="classProtoParameter.html#a155b564b34ae0b36d39d5a1caf5d0014">ProtoParameter::isTypeLocked()</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeaacd8991c4ebdeb4057e15faf1d08abc2">EffectRecord::killedbycall</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classArchitecture.html#a7d04d77ca75b9e75caa3750c156d9bbf">Architecture::pcodeinjectlib</a>, <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aeafa04c6c617a1044c79c7bc9b7d661be2">EffectRecord::return_address</a>, <a class="el" href="classAddress.html#abddd3a282e1936bfed855f34824a2ec6">Address::saveXml()</a>, <a class="el" href="classDatatype.html#a803c57a943c69d832a432777791a0df0">Datatype::saveXml()</a>, <a class="el" href="classAddrSpace.html#a808aa3d9bee6d70656fcdad268e17406">AddrSpace::saveXmlAttributes()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, and <a class="el" href="classEffectRecord.html#a1b211db4b8e90687781810255052f6aea3488da6d6b149499cbe384f7b57d0564">EffectRecord::unaffected</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#ad23142354572370c67625649f5119c8a">Funcdata::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ff2f80e5cf4043147ccd83a863ee83f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setConstructor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether <b>this</b> prototype is a <em>constructor</em> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if <b>this</b> is a constructor, <b>false</b> otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa191f5c52ce98ba14ef14f63a763a7da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setDestructor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether <b>this</b> prototype is a <em>destructor</em> method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if <b>this</b> is a destructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a843bc3ca11536028c5cb00ce5479182d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setInline </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the <em>in-line</em> setting for functions with <b>this</b> prototype. </p>
<p>In-lining can be based on a <em>call-fixup</em>, or the full body of the function can be in-lined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if in-lining should be performed. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classOptionInline.html#a497ab996c7c25c719860d4e3f558096d">OptionInline::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5f36aaa3e2d1d7cdc90d101065abbc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setInputErrors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the input error setting for <b>this</b> prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if input parameters should be marked as in error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">FuncCallSpecs::forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a4afe216709633a3b075111d6f1b7148f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setInputLock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the data-type lock on input parameters. </p>
<p>The lock on the data-type of input parameters is set as specified. A <b>true</b> value indicates that future analysis will not change the number of input parameters or their data-type. Zero parameters or <em>void</em> can be locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> to indicate a lock, <b>false</b> for unlocked </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, and <a class="el" href="classProtoParameter.html#a91f745d13f913e959f724e7259c52fa2">ProtoParameter::setTypeLock()</a>.</p>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">FuncCallSpecs::forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="af69f89b0b3c5165e521d33b658599699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>vt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set internal backing storage for <b>this</b>. </p>
<p>A prototype model is set, and any parameters added to <b>this</b> during analysis will be backed internally. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is the prototype model to set </td></tr>
    <tr><td class="paramname">vt</td><td>is the default <em>void</em> data-type to use if the return-value remains unassigned </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classActionDefaultParams.html#a32f4c196d02d9f86c66749b9bf5d2247">ActionDefaultParams::apply()</a>, and <a class="el" href="classOverride.html#a81f34dfc11c427ea0873358bef93ada3">Override::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8c14d15c7296c47deae3433687b1b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProtoModel.html">ProtoModel</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the prototype model for <b>this</b>. </p>
<p>Establish a specific prototype model for <b>this</b> function prototype. Some basic properties are inherited from the model, otherwise parameters are unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is the new prototype model to set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classProtoModel.html#a0dd1871a456f9289660766c333448ba5ab0874d825448e7c731717fad59bbec92">ProtoModel::extrapop_unknown</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classProtoModel.html#aac914edc848e54dc0073e75b35d1821e">ProtoModel::getExtraPop()</a>, <a class="el" href="classProtoModel.html#a316951a92d26bf8b0a89cb2ac09c18a9">ProtoModel::hasThisPointer()</a>, and <a class="el" href="classProtoModel.html#a3c283f2b5bc458be23d6df45b3e2fbfa">ProtoModel::isConstructor()</a>.</p>

<p>Referenced by <a class="el" href="classActionPrototypeTypes.html#a4c4654505369c0d674f2260c313c76b3">ActionPrototypeTypes::apply()</a>, and <a class="el" href="classActionDefaultParams.html#a32f4c196d02d9f86c66749b9bf5d2247">ActionDefaultParams::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="acc303c449c418dd875319c6f6cd9436f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setModelLock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the lock on the prototype model for <b>this</b>. </p>
<p>The prototype model can be locked while still leaving parameters unlocked. Parameter recovery will follow the rules of the locked model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> to indicate a lock, <b>false</b> for unlocked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacaf0bda9b424dfd5c6a28d3a45fb100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setNoReturn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the <em>no-return</em> setting for functions with <b>this</b> prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> to treat the function as never returning </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classOptionNoReturn.html#a60586eaa31158c4be083997d425dfc8a">OptionNoReturn::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8eacd70fbc6e4cd5d694d2ae5b1ed64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setOutputErrors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the output error setting for <b>this</b> prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if return value should be marked as in error </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">FuncCallSpecs::forceSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a7593a0880a632bce714a376244ef4f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setOutputLock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the data-type lock on the return value. </p>
<p>The lock of the data-type of the return value is set as specified. A <b>true</b> value indicates that future analysis will not change the presence of or the data-type of the return value. A <em>void</em> return value can be locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> to indicate a lock, <b>false</b> for unlocked </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>.</p>

</div>
</div>
<a class="anchor" id="a8e6f53c7733c8aa58d9138a8f3add2ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setPieces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;&#160;</td>
          <td class="paramname"><em>pieces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <b>this</b> prototype based on raw pieces. </p>
<p>The full function prototype is (re)set from a model, names, and data-types The new input and output parameters are both assumed to be locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieces</td><td>is the raw collection of names and data-types </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structPrototypePieces.html#a06df4f0bbd4f67847962c3ae35e8945d">PrototypePieces::dotdotdot</a>, <a class="el" href="structPrototypePieces.html#ab424fb1bcab5c7d008b590a24a3ad34e">PrototypePieces::innames</a>, <a class="el" href="structPrototypePieces.html#aca89ccc6fb7ef4527613909e341efe64">PrototypePieces::intypes</a>, <a class="el" href="structPrototypePieces.html#a35b3c9fbc711e8623021f4e21284de13">PrototypePieces::model</a>, and <a class="el" href="structPrototypePieces.html#ab145dec69a82cf13bef723679f6800b0">PrototypePieces::outtype</a>.</p>

<p>Referenced by <a class="el" href="classArchitecture.html#a10d78ec7be0df339288b7b3adc4c38e7">Architecture::setPrototype()</a>.</p>

</div>
</div>
<a class="anchor" id="abd05102695a39cdad0170eeb92884b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::setReturnBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of bytes consumed by callers of <b>this</b>. </p>
<p>This value can be used as a hint as to how much of the return value is important and is used to inform the dead code <em>consume</em> algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the estimated number of bytes or 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the value was changed </dd></dl>

<p>Referenced by <a class="el" href="classRulePiecePathology.html#a681659c18d630bbf9064fbf7191dd02d">RulePiecePathology::tracePathologyForward()</a>.</p>

</div>
</div>
<a class="anchor" id="adc83eddece4cb123d198ad288dfa89bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::setScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>startpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a backing symbol <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> for <b>this</b>. </p>
<p>Input parameters are set based on an existing function <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> and if there is no prototype model the default model is set. Parameters that are added to <b>this</b> during analysis will automatically be reflected in the symbol table. This should only be called during initialization of <b>this</b> prototype. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> to set </td></tr>
    <tr><td class="paramname">startpoint</td><td>is a usepoint to associate with the parameters </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classArchitecture.html#a1e0f5d45f6dcd494b15bb55f81f656b2">Architecture::defaultfp</a>, and <a class="el" href="classScope.html#adb0e2018c6c10aaca1403cc9850e065e">Scope::getArch()</a>.</p>

<p>Referenced by <a class="el" href="classFuncdata.html#a979faf589906b1a1937623f7a2a186f2">Funcdata::Funcdata()</a>, and <a class="el" href="classFuncdata.html#a7419de8057421b8e9300c4a26c60ecef">Funcdata::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cd0d3d5c6568b3102ac220afde1649d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncProto::unjustifiedInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given storage location looks like an <em>unjustified</em> input parameter. </p>
<p>The storage for a value may be contained in a normal parameter location but be unjustified within that container, i.e. the least significant bytes are not being used. If this is the case, pass back the full parameter location and return <b>true</b>. If the input is locked, checking is againt the set parameters, otherwise the check is against the prototype model. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given storage </td></tr>
    <tr><td class="paramname">res</td><td>is the full parameter storage to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the given storage is unjustified within its parameter container </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classProtoParameter.html#a155b564b34ae0b36d39d5a1caf5d0014">ProtoParameter::isTypeLocked()</a>, <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

</div>
</div>
<a class="anchor" id="a9ad6aba5f6731281a4c16fdfac76de2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::updateAllTypes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>typelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dtdtdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <b>this</b> entire function prototype based on a list of names and data-types. </p>
<p>Prototype information is provided as separate lists of names and data-types, where the first entry corresponds to the output parameter (return value) and the remaining entries correspond to input parameters. Storage locations and hidden return parameters are calculated, creating a complete function protototype. Existing locks are overridden. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namelist</td><td>is the list of parameter names </td></tr>
    <tr><td class="paramname">typelist</td><td>is the list of data-types </td></tr>
    <tr><td class="paramname">dtdtdt</td><td>is <b>true</b> if the new prototype accepts variable argument lists </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">AddrSpace::flags</a>, and <a class="el" href="structParameterPieces.html#afc17dcffd5b1b61a870d56603141df2baab9b7725bf05d092537566b207e8c225">ParameterPieces::hiddenretparm</a>.</p>

</div>
</div>
<a class="anchor" id="a33463f351b0ebc8c8f6065eff896dbc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::updateInputNoTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>triallist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>activeinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but do not store the data-type. </p>
<p>This is accomplished in the same way as if there were data-types but instead of pulling a data-type from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, only the size is used. Undefined data-types are pulled from the given <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture. ">TypeFactory</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the function containing the trial Varnodes </td></tr>
    <tr><td class="paramname">triallist</td><td>is the list of Varnodes </td></tr>
    <tr><td class="paramname">activeinput</td><td>is the trial container </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structParameterPieces.html#a64a8ea85886ffa493a625e75cb5b01e0">ParameterPieces::addr</a>, <a class="el" href="classFuncdata.html#a17e49052fa778084431a6b744cc388cb">Funcdata::findDisjointCover()</a>, <a class="el" href="structParameterPieces.html#aedb19159c26f9137c4ec68238f25933a">ParameterPieces::flags</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">Funcdata::getArch()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#aa3f603299bd7de14e1cef73e32981f84">Varnode::isPersist()</a>, <a class="el" href="classVarnode.html#a98825616d50a27a615057e625a61285e">Varnode::setMark()</a>, <a class="el" href="structParameterPieces.html#a628fd8428a2331db63516291840e8409">ParameterPieces::type</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>.</p>

<p>Referenced by <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ae89afc199ba2c4c8261dac381c5e426b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::updateInputTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>triallist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>activeinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials. </p>
<p>If the input parameters are locked, don't do anything. Otherwise, given a list of Varnodes and their associated trial information, create an input parameter for each trial in order, grabbing data-type information from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. Any old input parameters are cleared. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the function containing the trial Varnodes </td></tr>
    <tr><td class="paramname">triallist</td><td>is the list of Varnodes </td></tr>
    <tr><td class="paramname">activeinput</td><td>is the trial container </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structParameterPieces.html#a64a8ea85886ffa493a625e75cb5b01e0">ParameterPieces::addr</a>, <a class="el" href="classFuncdata.html#a17e49052fa778084431a6b744cc388cb">Funcdata::findDisjointCover()</a>, <a class="el" href="structParameterPieces.html#aedb19159c26f9137c4ec68238f25933a">ParameterPieces::flags</a>, <a class="el" href="classFuncdata.html#ae0912e60caaf80197b82ff00ddf6af73">Funcdata::getArch()</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="classVarnode.html#a5447a89dab68024b2cd6b7fede45ef6b">Varnode::getHigh()</a>, <a class="el" href="classParamActive.html#a4c76cdbce84cfd194060814ae438e5c5">ParamActive::getNumTrials()</a>, <a class="el" href="classVarnode.html#aca832a0d913c941a82c0d4d4d1254db9">Varnode::getSize()</a>, <a class="el" href="classParamActive.html#a88fb46565155de0123b634951a186f74">ParamActive::getTrial()</a>, <a class="el" href="classHighVariable.html#a0c8ec9e93d04729dc0f45f327b7de519">HighVariable::getType()</a>, <a class="el" href="classVarnode.html#ab4fc1d0a8678502254225109c80afda1">Varnode::isMark()</a>, <a class="el" href="classVarnode.html#aa3f603299bd7de14e1cef73e32981f84">Varnode::isPersist()</a>, <a class="el" href="classVarnode.html#a98825616d50a27a615057e625a61285e">Varnode::setMark()</a>, <a class="el" href="structParameterPieces.html#a628fd8428a2331db63516291840e8409">ParameterPieces::type</a>, <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>, and <a class="el" href="classArchitecture.html#a8225ba7bd6ac802660e03ee793289dd1">Architecture::types</a>.</p>

<p>Referenced by <a class="el" href="classActionInputPrototype.html#ace1078c436c86aba604abb99b82180ae">ActionInputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a882e34d08f3e4e44ba5aa25b87c84bfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::updateOutputNoTypes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>triallist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeFactory.html">TypeFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but don't store the data-type. </p>
<p>If the output parameter is locked, don't do anything. Otherwise, given a list of (at most 1) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, create a return value, grabbing size information from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. An undefined data-type is created from the given <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture. ">TypeFactory</a>. Any old return value is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triallist</td><td>is the list of Varnodes </td></tr>
    <tr><td class="paramname">factory</td><td>is the given <a class="el" href="classTypeFactory.html" title="Container class for all Datatype objects in an Architecture. ">TypeFactory</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structParameterPieces.html#a64a8ea85886ffa493a625e75cb5b01e0">ParameterPieces::addr</a>, <a class="el" href="structParameterPieces.html#aedb19159c26f9137c4ec68238f25933a">ParameterPieces::flags</a>, <a class="el" href="classTypeFactory.html#a5fe1ae26c0b76b18d59d5cd27a9b8ff1">TypeFactory::getBase()</a>, <a class="el" href="structParameterPieces.html#a628fd8428a2331db63516291840e8409">ParameterPieces::type</a>, and <a class="el" href="type_8hh.html#aef6429f2523cdf4d415ba04a0209e61fa64599dea7071bc28732936e0bfddff3e">TYPE_UNKNOWN</a>.</p>

<p>Referenced by <a class="el" href="classActionOutputPrototype.html#a1ed1275253a29c1d09d2383c00e34a9c">ActionOutputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a56cbde2e23cdcf41ddb870721e02be6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::updateOutputTypes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>triallist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials. </p>
<p>If the output parameter is locked, don't do anything. Otherwise, given a list of (at most 1) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, create a return value, grabbing data-type information from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. Any old return value is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triallist</td><td>is the list of Varnodes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structParameterPieces.html#a64a8ea85886ffa493a625e75cb5b01e0">ParameterPieces::addr</a>, <a class="el" href="structParameterPieces.html#aedb19159c26f9137c4ec68238f25933a">ParameterPieces::flags</a>, <a class="el" href="classProtoParameter.html#a33c604ed7e06ae0ca6ac491b46739343">ProtoParameter::getAddress()</a>, <a class="el" href="classProtoParameter.html#a910cfb9ed6ce57e9bf6e9789b8ed3e0f">ProtoParameter::getSize()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classProtoParameter.html#ad1a249d140c17d040845d0bcf8307fd0">ProtoParameter::isSizeTypeLocked()</a>, <a class="el" href="classProtoParameter.html#a155b564b34ae0b36d39d5a1caf5d0014">ProtoParameter::isTypeLocked()</a>, <a class="el" href="classProtoParameter.html#a05418aa9f8e8fa0c7499b99cd51e24d3">ProtoParameter::overrideSizeLockType()</a>, and <a class="el" href="structParameterPieces.html#a628fd8428a2331db63516291840e8409">ParameterPieces::type</a>.</p>

<p>Referenced by <a class="el" href="classActionOutputPrototype.html#a1ed1275253a29c1d09d2383c00e34a9c">ActionOutputPrototype::apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a987b9ee85738005c25a6916b1219be97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncProto::updateThisPointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure any "this" parameter is properly marked. </p>
<p>This is called after a new prototype is established (via restoreXml or updateAllTypes) It makes sure that if the <a class="el" href="classProtoModel.html" title="A prototype model: a model for passing parameters between functions. ">ProtoModel</a> calls for a "this" parameter, then the appropriate parameter is explicitly marked as the "this". </p>

<p>References <a class="el" href="classProtoParameter.html#a104c1c7a9873fafe0394d23bb35feeb4">ProtoParameter::isHiddenReturn()</a>, and <a class="el" href="classProtoParameter.html#aa1e07ccbfd23d2929115525ddfc385d6">ProtoParameter::setThisPointer()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fspec_8hh.html">fspec.hh</a></li>
<li>fspec.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
