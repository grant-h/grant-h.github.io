<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>decompiler: VarnodeData Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structVarnodeData-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VarnodeData Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data defining a specific memory location.  
 <a href="structVarnodeData.html#details">More...</a></p>

<p><code>#include &lt;pcoderaw.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a253e48d84f2b17cfc0a1a6c9e6bdc4a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#a253e48d84f2b17cfc0a1a6c9e6bdc4a9">operator&lt;</a> (const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;op2) const </td></tr>
<tr class="memdesc:a253e48d84f2b17cfc0a1a6c9e6bdc4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ordering for <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a>.  <a href="#a253e48d84f2b17cfc0a1a6c9e6bdc4a9">More...</a><br /></td></tr>
<tr class="separator:a253e48d84f2b17cfc0a1a6c9e6bdc4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840a507dd2bb049a3a4d457cf2cb47bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#a840a507dd2bb049a3a4d457cf2cb47bd">operator==</a> (const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;op2) const </td></tr>
<tr class="memdesc:a840a507dd2bb049a3a4d457cf2cb47bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for equality.  <a href="#a840a507dd2bb049a3a4d457cf2cb47bd">More...</a><br /></td></tr>
<tr class="separator:a840a507dd2bb049a3a4d457cf2cb47bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf802f3849ea3bd16fafe90fb4b6b3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#afbf802f3849ea3bd16fafe90fb4b6b3c">operator!=</a> (const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;op2) const </td></tr>
<tr class="memdesc:afbf802f3849ea3bd16fafe90fb4b6b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for inequality.  <a href="#afbf802f3849ea3bd16fafe90fb4b6b3c">More...</a><br /></td></tr>
<tr class="separator:afbf802f3849ea3bd16fafe90fb4b6b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65999536ac7abe8240fcc2f506abfe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#ae65999536ac7abe8240fcc2f506abfe4">getAddr</a> (void) const </td></tr>
<tr class="memdesc:ae65999536ac7abe8240fcc2f506abfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of the varnode as an address.  <a href="#ae65999536ac7abe8240fcc2f506abfe4">More...</a><br /></td></tr>
<tr class="separator:ae65999536ac7abe8240fcc2f506abfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a4c1ccbaa1f2477d036be8be923894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#a20a4c1ccbaa1f2477d036be8be923894">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el, const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *manage)</td></tr>
<tr class="memdesc:a20a4c1ccbaa1f2477d036be8be923894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover this object from an XML tag.  <a href="#a20a4c1ccbaa1f2477d036be8be923894">More...</a><br /></td></tr>
<tr class="separator:a20a4c1ccbaa1f2477d036be8be923894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad652adb3b8f20d3071fc82a206265dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#ad652adb3b8f20d3071fc82a206265dc4">contains</a> (const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;op2) const </td></tr>
<tr class="memdesc:ad652adb3b8f20d3071fc82a206265dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> container another given <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a>.  <a href="#ad652adb3b8f20d3071fc82a206265dc4">More...</a><br /></td></tr>
<tr class="separator:ad652adb3b8f20d3071fc82a206265dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1a69a5187f7a6376c0c93c08962ea68d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a69a5187f7a6376c0c93c08962ea68d"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a></td></tr>
<tr class="memdesc:a1a69a5187f7a6376c0c93c08962ea68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address space. <br /></td></tr>
<tr class="separator:a1a69a5187f7a6376c0c93c08962ea68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a511384ee72e847b51423cc99c8233e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a511384ee72e847b51423cc99c8233e"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a></td></tr>
<tr class="memdesc:a1a511384ee72e847b51423cc99c8233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset within the space. <br /></td></tr>
<tr class="separator:a1a511384ee72e847b51423cc99c8233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d39ae46d51c8854b962f3ec4ee4e25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d39ae46d51c8854b962f3ec4ee4e25"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">size</a></td></tr>
<tr class="memdesc:a50d39ae46d51c8854b962f3ec4ee4e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes in the location. <br /></td></tr>
<tr class="separator:a50d39ae46d51c8854b962f3ec4ee4e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data defining a specific memory location. </p>
<p>Within the decompiler's model of a processor, any register, memory location, or other variable can always be represented as an address space, an offset within the space, and the size of the sequence of bytes. This is more commonly referred to as a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, but this is a bare-bones container for the data that doesn't have the cached attributes and the dataflow links of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> within its syntax tree. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad652adb3b8f20d3071fc82a206265dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VarnodeData::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does <b>this</b> container another given <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a>. </p>
<p>Return <b>true</b>, if <b>this</b>, as an address range, contains the other address range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the other <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a> to test for containment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>this</b> contains the other </dd></dl>

<p>References <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a>.</p>

</div>
</div>
<a class="anchor" id="ae65999536ac7abe8240fcc2f506abfe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> VarnodeData::getAddr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the location of the varnode as an address. </p>
<p>This is a convenience function to construct a full <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> from the <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a>'s address space and offset </p><dl class="section return"><dt>Returns</dt><dd>the address of the varnode </dd></dl>

<p>References <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a>.</p>

<p>Referenced by <a class="el" href="classActionUnjustifiedParams.html#a76dd93b62ac18bb4d18cba2a79c0ac55">ActionUnjustifiedParams::apply()</a>, <a class="el" href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">AddrSpaceManager::constructFloatExtensionAddress()</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>, <a class="el" href="classEmulatePcodeCache.html#a6108efef1c0291ca887228781e4c1238">EmulatePcodeCache::executeBranch()</a>, <a class="el" href="classActionPrototypeTypes.html#ad501f68fdd5e2adec6bbb3d2f30fa462">ActionPrototypeTypes::extendInput()</a>, <a class="el" href="classActionFuncLink.html#a12f4fb6bff2243b2632cc82a3b884dbc">ActionFuncLink::funcLinkOutput()</a>, and <a class="el" href="classParamEntry.html#a4b24b93262b29c34e46462fb589f01ee">ParamEntry::justifiedContain()</a>.</p>

</div>
</div>
<a class="anchor" id="afbf802f3849ea3bd16fafe90fb4b6b3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VarnodeData::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for inequality. </p>
<p>Compare <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a> for inequality. If either the space, offset, or size is not equal, return <b>true</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the object being compared to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>this</em> is not equal to <em>op2</em> </dd></dl>

<p>References <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a>.</p>

</div>
</div>
<a class="anchor" id="a253e48d84f2b17cfc0a1a6c9e6bdc4a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VarnodeData::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An ordering for <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a>. </p>
<p><a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a> can be sorted in terms of the space its in (the space's <em>index</em>), the offset within the space, and finally by the size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the object being compared to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>this</em> is less than <em>op2</em> </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a>.</p>

</div>
</div>
<a class="anchor" id="a840a507dd2bb049a3a4d457cf2cb47bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VarnodeData::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for equality. </p>
<p>Compare <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a> for equality. The space, offset, and size must all be exactly equal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the object being compared to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>this</em> is equal to <em>op2</em> </dd></dl>

<p>References <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a>.</p>

</div>
</div>
<a class="anchor" id="a20a4c1ccbaa1f2477d036be8be923894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VarnodeData::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td>
          <td class="paramname"><em>manage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover this object from an XML tag. </p>
<p>Build this <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a> from an <b>&lt;addr&gt;</b> tag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the parsed tag </td></tr>
    <tr><td class="paramname">manage</td><td>is the address space manager </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classAddrSpaceManager.html#adfc70d6b8586d28e2b8fe95abf4290a8">AddrSpaceManager::getDefaultCodeSpace()</a>, <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>, <a class="el" href="classTranslate.html#a3a62c460db4eccc285fa3dd29dd4a29b">Translate::getRegister()</a>, <a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">AddrSpaceManager::getSpaceByName()</a>, <a class="el" href="classAddrSpace.html#affd0745190cc202feaec683a31f043d9">AddrSpace::getTrans()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">offset</a>, <a class="el" href="classAddrSpace.html#ac217f5d6478adec5241bc96b7bc06408">AddrSpace::restoreXmlAttributes()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">space</a>.</p>

<p>Referenced by <a class="el" href="classArchitecture.html#a8b2290f8d9cf479d4b49fb26c83ff8c5">Architecture::parseIncidentalCopy()</a>, <a class="el" href="classArchitecture.html#a7cbe749d5bcc143838f2590fc08acf26">Architecture::parsePreferSplit()</a>, <a class="el" href="classAddress.html#a31fdc8c33088abb3040027d35e7c4026">Address::restoreXml()</a>, <a class="el" href="classLanedRegister.html#aac521602aa1d317bdd521b489fc6e546">LanedRegister::restoreXml()</a>, and <a class="el" href="classPcodeEmit.html#a7e440d43aba89c358ffcab1f2d88b3db">PcodeEmit::restoreXmlOp()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="pcoderaw_8hh.html">pcoderaw.hh</a></li>
<li>pcoderaw.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
